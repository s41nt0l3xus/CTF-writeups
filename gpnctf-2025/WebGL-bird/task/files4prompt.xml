<documents>
<document index="1">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLTransformFeedback.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/WebGL/Types.h>
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLTransformFeedback : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLTransformFeedback, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLTransformFeedback);
17  
18  public:
19      static GC::Ref<WebGLTransformFeedback> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
20  
21      virtual ~WebGLTransformFeedback() override;
22  
23  protected:
24      explicit WebGLTransformFeedback(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
25  
26      virtual void initialize(JS::Realm&) override;
27  };
28  
29  }
</document_content>
</document>
<document index="2">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLObject.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #include <LibWeb/Bindings/Intrinsics.h>
10  #include <LibWeb/Bindings/WebGLObjectPrototype.h>
11  #include <LibWeb/WebGL/WebGLObject.h>
12  
13  #include <GLES2/gl2.h>
14  
15  namespace Web::WebGL {
16  
17  WebGLObject::WebGLObject(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
18      : Bindings::PlatformObject(realm)
19      , m_context(&context)
20      , m_handle(handle)
21  {
22  }
23  
24  WebGLObject::~WebGLObject() = default;
25  
26  void WebGLObject::initialize(JS::Realm& realm)
27  {
28      Base::initialize(realm);
29      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLObject);
30  }
31  
32  void WebGLObject::visit_edges(Visitor& visitor)
33  {
34      Base::visit_edges(visitor);
35      visitor.visit(m_context->gc_cell());
36  }
37  
38  ErrorOr<GLuint> WebGLObject::handle(WebGLRenderingContextBase const* context) const
39  {
40      if (context == m_context)
41          return m_handle;
42      return Error::from_errno(GL_INVALID_OPERATION);
43  }
44  
45  }
</document_content>
</document>
<document index="3">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLSampler.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/Intrinsics.h>
 9  #include <LibWeb/Bindings/WebGLSamplerPrototype.h>
10  #include <LibWeb/WebGL/WebGLSampler.h>
11  
12  namespace Web::WebGL {
13  
14  GC_DEFINE_ALLOCATOR(WebGLSampler);
15  
16  GC::Ref<WebGLSampler> WebGLSampler::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
17  {
18      return realm.create<WebGLSampler>(realm, context, handle);
19  }
20  
21  WebGLSampler::WebGLSampler(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
22      : WebGLObject(realm, context, handle)
23  {
24  }
25  
26  WebGLSampler::~WebGLSampler() = default;
27  
28  void WebGLSampler::initialize(JS::Realm& realm)
29  {
30      Base::initialize(realm);
31      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLSampler);
32  }
33  
34  }
</document_content>
</document>
<document index="4">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLFramebuffer.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #pragma once
 9  
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLFramebuffer final : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLFramebuffer, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLFramebuffer);
17  
18  public:
19      static GC::Ref<WebGLFramebuffer> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
20  
21      virtual ~WebGLFramebuffer();
22  
23  protected:
24      explicit WebGLFramebuffer(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
25  
26      virtual void initialize(JS::Realm&) override;
27  };
28  
29  }
</document_content>
</document>
<document index="5">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLSampler.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/WebGL/Types.h>
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLSampler : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLSampler, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLSampler);
17  
18  public:
19      static GC::Ref<WebGLSampler> create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle);
20  
21      virtual ~WebGLSampler() override;
22  
23  protected:
24      explicit WebGLSampler(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
25  
26      virtual void initialize(JS::Realm&) override;
27  };
28  
29  }
</document_content>
</document>
<document index="6">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLActiveInfo.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/Intrinsics.h>
 9  #include <LibWeb/Bindings/WebGLActiveInfoPrototype.h>
10  #include <LibWeb/WebGL/WebGLActiveInfo.h>
11  
12  namespace Web::WebGL {
13  
14  GC_DEFINE_ALLOCATOR(WebGLActiveInfo);
15  
16  GC::Ptr<WebGLActiveInfo> WebGLActiveInfo::create(JS::Realm& realm, String name, GLenum type, GLsizei size)
17  {
18      return realm.create<WebGLActiveInfo>(realm, move(name), type, size);
19  }
20  
21  WebGLActiveInfo::WebGLActiveInfo(JS::Realm& realm, String name, GLenum type, GLsizei size)
22      : Bindings::PlatformObject(realm)
23      , m_name(move(name))
24      , m_type(type)
25      , m_size(size)
26  {
27  }
28  
29  WebGLActiveInfo::~WebGLActiveInfo() = default;
30  
31  void WebGLActiveInfo::initialize(JS::Realm& realm)
32  {
33      Base::initialize(realm);
34      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLActiveInfo);
35  }
36  
37  }
</document_content>
</document>
<document index="7">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLActiveInfo.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/Bindings/PlatformObject.h>
10  
11  typedef unsigned int GLenum;
12  typedef int GLsizei;
13  
14  namespace Web::WebGL {
15  
16  class WebGLActiveInfo : public Bindings::PlatformObject {
17      WEB_PLATFORM_OBJECT(WebGLActiveInfo, Bindings::PlatformObject);
18      GC_DECLARE_ALLOCATOR(WebGLActiveInfo);
19  
20  public:
21      static GC::Ptr<WebGLActiveInfo> create(JS::Realm&, String name, GLenum type, GLsizei size);
22      virtual ~WebGLActiveInfo();
23  
24      GLsizei size() const { return m_size; }
25      GLenum type() const { return m_type; }
26      String const& name() const { return m_name; }
27  
28  protected:
29      explicit WebGLActiveInfo(JS::Realm&, String name, GLenum type, GLsizei size);
30  
31  private:
32      virtual void initialize(JS::Realm&) override;
33  
34      String m_name;
35      GLenum m_type { 0 };
36      GLsizei m_size { 0 };
37  };
38  
39  }
</document_content>
</document>
<document index="8">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLContextAttributes.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibJS/Forward.h>
10  #include <LibWeb/Bindings/WebGLRenderingContextPrototype.h>
11  
12  namespace Web::WebGL {
13  
14  // https://www.khronos.org/registry/webgl/specs/latest/1.0/#WEBGLCONTEXTATTRIBUTES
15  struct WebGLContextAttributes {
16      bool alpha { true };
17      bool depth { true };
18      bool stencil { false };
19      bool antialias { true };
20      bool premultiplied_alpha { true };
21      bool preserve_drawing_buffer { false };
22      Bindings::WebGLPowerPreference power_preference { Bindings::WebGLPowerPreference::Default };
23      bool fail_if_major_performance_caveat { false };
24      bool desynchronized { false };
25  };
26  
27  JS::ThrowCompletionOr<WebGLContextAttributes> convert_value_to_context_attributes_dictionary(JS::VM&, JS::Value value);
28  
29  }
</document_content>
</document>
<document index="9">
<source>./Ladybird/Libraries/LibWeb/WebGL/OpenGLContext.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibGfx/Forward.h>
10  #include <LibGfx/Size.h>
11  
12  namespace Web::WebGL {
13  
14  class OpenGLContext {
15  public:
16      static OwnPtr<OpenGLContext> create(NonnullRefPtr<Gfx::SkiaBackendContext>);
17  
18      void notify_content_will_change();
19      void clear_buffer_to_default_values();
20      void allocate_painting_surface_if_needed();
21  
22      struct Impl;
23      OpenGLContext(NonnullRefPtr<Gfx::SkiaBackendContext>, Impl);
24  
25      ~OpenGLContext();
26  
27      void make_current();
28  
29      void set_size(Gfx::IntSize const&);
30  
31      RefPtr<Gfx::PaintingSurface> surface();
32  
33      Vector<String> get_supported_extensions();
34  
35  private:
36      NonnullRefPtr<Gfx::SkiaBackendContext> m_skia_backend_context;
37      Gfx::IntSize m_size;
38      RefPtr<Gfx::PaintingSurface> m_painting_surface;
39      NonnullOwnPtr<Impl> m_impl;
40  };
41  
42  }
</document_content>
</document>
<document index="10">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLUniformLocation.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #pragma once
 9  
10  #include <LibWeb/Bindings/PlatformObject.h>
11  #include <LibWeb/WebGL/Types.h>
12  
13  namespace Web::WebGL {
14  
15  class WebGLUniformLocation final : public Bindings::PlatformObject {
16      WEB_PLATFORM_OBJECT(WebGLUniformLocation, Bindings::PlatformObject);
17      GC_DECLARE_ALLOCATOR(WebGLUniformLocation);
18  
19  public:
20      static GC::Ref<WebGLUniformLocation> create(JS::Realm& realm, GLuint handle);
21  
22      virtual ~WebGLUniformLocation();
23  
24      GLuint handle() const { return m_handle; }
25  
26  protected:
27      explicit WebGLUniformLocation(JS::Realm&, GLuint handle);
28  
29      virtual void initialize(JS::Realm&) override;
30  
31      GLuint m_handle { 0 };
32  };
33  
34  }
</document_content>
</document>
<document index="11">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGL2RenderingContext.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
 3   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 4   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #pragma once
10  
11  #include <LibGC/Ptr.h>
12  #include <LibWeb/Bindings/PlatformObject.h>
13  #include <LibWeb/Forward.h>
14  #include <LibWeb/WebGL/Types.h>
15  #include <LibWeb/WebGL/WebGL2RenderingContextImpl.h>
16  #include <LibWeb/WebGL/WebGLContextAttributes.h>
17  
18  namespace Web::WebGL {
19  
20  class WebGL2RenderingContext : public Bindings::PlatformObject
21      , public WebGL2RenderingContextImpl {
22      WEB_PLATFORM_OBJECT(WebGL2RenderingContext, Bindings::PlatformObject);
23      GC_DECLARE_ALLOCATOR(WebGL2RenderingContext);
24  
25  public:
26      static JS::ThrowCompletionOr<GC::Ptr<WebGL2RenderingContext>> create(JS::Realm&, HTML::HTMLCanvasElement& canvas_element, JS::Value options);
27  
28      virtual ~WebGL2RenderingContext() override;
29  
30      // FIXME: This is a hack required to visit context from WebGLObject.
31      //        It should be gone once WebGLRenderingContextBase inherits from PlatformObject.
32      GC::Cell const* gc_cell() const override { return this; }
33  
34      void present() override;
35      void needs_to_present() override;
36  
37      GC::Ref<HTML::HTMLCanvasElement> canvas_for_binding() const;
38  
39      bool is_context_lost() const;
40      Optional<WebGLContextAttributes> get_context_attributes();
41  
42      RefPtr<Gfx::PaintingSurface> surface();
43      void allocate_painting_surface_if_needed();
44  
45      void set_size(Gfx::IntSize const&);
46      void reset_to_default_state();
47  
48      Optional<Vector<String>> get_supported_extensions();
49      JS::Object* get_extension(String const& name);
50  
51      WebIDL::Long drawing_buffer_width() const;
52      WebIDL::Long drawing_buffer_height() const;
53  
54  private:
55      virtual void initialize(JS::Realm&) override;
56  
57      WebGL2RenderingContext(JS::Realm&, HTML::HTMLCanvasElement&, NonnullOwnPtr<OpenGLContext> context, WebGLContextAttributes context_creation_parameters, WebGLContextAttributes actual_context_parameters);
58  
59      virtual void visit_edges(Cell::Visitor&) override;
60  
61      GC::Ref<HTML::HTMLCanvasElement> m_canvas_element;
62  
63      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#context-creation-parameters
64      // Each WebGLRenderingContext has context creation parameters, set upon creation, in a WebGLContextAttributes object.
65      WebGLContextAttributes m_context_creation_parameters {};
66  
67      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#actual-context-parameters
68      // Each WebGLRenderingContext has actual context parameters, set each time the drawing buffer is created, in a WebGLContextAttributes object.
69      WebGLContextAttributes m_actual_context_parameters {};
70  
71      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#webgl-context-lost-flag
72      // Each WebGLRenderingContext has a webgl context lost flag, which is initially unset.
73      bool m_context_lost { false };
74  
75      // WebGL presents its drawing buffer to the HTML page compositor immediately before a compositing operation, but only if at least one of the following has occurred since the previous compositing operation:
76      // - Context creation
77      // - Canvas resize
78      // - clear, drawArrays, or drawElements has been called while the drawing buffer is the currently bound framebuffer
79      bool m_should_present { true };
80  
81      GLenum m_error { 0 };
82  
83      virtual void set_error(GLenum error) override;
84  };
85  
86  }
</document_content>
</document>
<document index="12">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLTransformFeedback.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/Intrinsics.h>
 9  #include <LibWeb/Bindings/WebGLTransformFeedbackPrototype.h>
10  #include <LibWeb/WebGL/WebGLTransformFeedback.h>
11  
12  namespace Web::WebGL {
13  
14  GC_DEFINE_ALLOCATOR(WebGLTransformFeedback);
15  
16  GC::Ref<WebGLTransformFeedback> WebGLTransformFeedback::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
17  {
18      return realm.create<WebGLTransformFeedback>(realm, context, handle);
19  }
20  
21  WebGLTransformFeedback::WebGLTransformFeedback(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
22      : WebGLObject(realm, context, handle)
23  {
24  }
25  
26  WebGLTransformFeedback::~WebGLTransformFeedback() = default;
27  
28  void WebGLTransformFeedback::initialize(JS::Realm& realm)
29  {
30      Base::initialize(realm);
31      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLTransformFeedback);
32  }
33  
34  }
</document_content>
</document>
<document index="13">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLTexture.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #pragma once
10  
11  #include <LibWeb/WebGL/Types.h>
12  #include <LibWeb/WebGL/WebGLObject.h>
13  
14  namespace Web::WebGL {
15  
16  class WebGLTexture final : public WebGLObject {
17      WEB_PLATFORM_OBJECT(WebGLTexture, WebGLObject);
18      GC_DECLARE_ALLOCATOR(WebGLTexture);
19  
20  public:
21      static GC::Ref<WebGLTexture> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
22  
23      virtual ~WebGLTexture();
24  
25  protected:
26      explicit WebGLTexture(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
27  
28      virtual void initialize(JS::Realm&) override;
29  };
30  
31  }
</document_content>
</document>
<document index="14">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLShader.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #pragma once
10  
11  #include <LibWeb/WebGL/Types.h>
12  #include <LibWeb/WebGL/WebGLObject.h>
13  
14  namespace Web::WebGL {
15  
16  class WebGLShader final : public WebGLObject {
17      WEB_PLATFORM_OBJECT(WebGLShader, WebGLObject);
18      GC_DECLARE_ALLOCATOR(WebGLShader);
19  
20  public:
21      static GC::Ref<WebGLShader> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
22  
23      virtual ~WebGLShader();
24  
25  protected:
26      explicit WebGLShader(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
27  
28      virtual void initialize(JS::Realm&) override;
29  };
30  
31  }
</document_content>
</document>
<document index="15">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLRenderingContext.cpp</source>
<document_content>
  1  /*
  2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
  3   * Copyright (c) 2023, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
  4   *
  5   * SPDX-License-Identifier: BSD-2-Clause
  6   */
  7  
  8  #include <LibJS/Runtime/ArrayBuffer.h>
  9  #include <LibJS/Runtime/TypedArray.h>
 10  #include <LibWeb/Bindings/Intrinsics.h>
 11  #include <LibWeb/Bindings/WebGLRenderingContextPrototype.h>
 12  #include <LibWeb/HTML/HTMLCanvasElement.h>
 13  #include <LibWeb/HTML/TraversableNavigable.h>
 14  #include <LibWeb/Painting/Paintable.h>
 15  #include <LibWeb/WebGL/ANGLEInstancedArrays.h>
 16  #include <LibWeb/WebGL/EventNames.h>
 17  #include <LibWeb/WebGL/OpenGLContext.h>
 18  #include <LibWeb/WebGL/WebGLContextEvent.h>
 19  #include <LibWeb/WebGL/WebGLRenderingContext.h>
 20  #include <LibWeb/WebGL/WebGLShader.h>
 21  #include <LibWeb/WebIDL/Buffers.h>
 22  
 23  #include <GLES2/gl2.h>
 24  #include <GLES2/gl2ext.h>
 25  
 26  namespace Web::WebGL {
 27  
 28  GC_DEFINE_ALLOCATOR(WebGLRenderingContext);
 29  
 30  // https://www.khronos.org/registry/webgl/specs/latest/1.0/#fire-a-webgl-context-event
 31  void fire_webgl_context_event(HTML::HTMLCanvasElement& canvas_element, FlyString const& type)
 32  {
 33      // To fire a WebGL context event named e means that an event using the WebGLContextEvent interface, with its type attribute [DOM4] initialized to e, its cancelable attribute initialized to true, and its isTrusted attribute [DOM4] initialized to true, is to be dispatched at the given object.
 34      // FIXME: Consider setting a status message.
 35      auto event = WebGLContextEvent::create(canvas_element.realm(), type, WebGLContextEventInit {});
 36      event->set_is_trusted(true);
 37      event->set_cancelable(true);
 38      canvas_element.dispatch_event(*event);
 39  }
 40  
 41  // https://www.khronos.org/registry/webgl/specs/latest/1.0/#fire-a-webgl-context-creation-error
 42  void fire_webgl_context_creation_error(HTML::HTMLCanvasElement& canvas_element)
 43  {
 44      // 1. Fire a WebGL context event named "webglcontextcreationerror" at canvas, optionally with its statusMessage attribute set to a platform dependent string about the nature of the failure.
 45      fire_webgl_context_event(canvas_element, EventNames::webglcontextcreationerror);
 46  }
 47  
 48  JS::ThrowCompletionOr<GC::Ptr<WebGLRenderingContext>> WebGLRenderingContext::create(JS::Realm& realm, HTML::HTMLCanvasElement& canvas_element, JS::Value options)
 49  {
 50      // We should be coming here from getContext being called on a wrapped <canvas> element.
 51      auto context_attributes = TRY(convert_value_to_context_attributes_dictionary(canvas_element.vm(), options));
 52  
 53      auto skia_backend_context = canvas_element.navigable()->traversable_navigable()->skia_backend_context();
 54      if (!skia_backend_context) {
 55          fire_webgl_context_creation_error(canvas_element);
 56          return GC::Ptr<WebGLRenderingContext> { nullptr };
 57      }
 58      auto context = OpenGLContext::create(*skia_backend_context);
 59      if (!context) {
 60          fire_webgl_context_creation_error(canvas_element);
 61          return GC::Ptr<WebGLRenderingContext> { nullptr };
 62      }
 63  
 64      context->set_size(canvas_element.bitmap_size_for_canvas(1, 1));
 65  
 66      return realm.create<WebGLRenderingContext>(realm, canvas_element, context.release_nonnull(), context_attributes, context_attributes);
 67  }
 68  
 69  WebGLRenderingContext::WebGLRenderingContext(JS::Realm& realm, HTML::HTMLCanvasElement& canvas_element, NonnullOwnPtr<OpenGLContext> context, WebGLContextAttributes context_creation_parameters, WebGLContextAttributes actual_context_parameters)
 70      : PlatformObject(realm)
 71      , WebGLRenderingContextImpl(realm, move(context))
 72      , m_canvas_element(canvas_element)
 73      , m_context_creation_parameters(context_creation_parameters)
 74      , m_actual_context_parameters(actual_context_parameters)
 75  {
 76  }
 77  
 78  WebGLRenderingContext::~WebGLRenderingContext() = default;
 79  
 80  void WebGLRenderingContext::initialize(JS::Realm& realm)
 81  {
 82      Base::initialize(realm);
 83      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLRenderingContext);
 84  }
 85  
 86  void WebGLRenderingContext::visit_edges(Cell::Visitor& visitor)
 87  {
 88      Base::visit_edges(visitor);
 89      visitor.visit(m_canvas_element);
 90  }
 91  
 92  void WebGLRenderingContext::present()
 93  {
 94      if (!m_should_present)
 95          return;
 96  
 97      m_should_present = false;
 98  
 99      // "Before the drawing buffer is presented for compositing the implementation shall ensure that all rendering operations have been flushed to the drawing buffer."
100      glFlush();
101  
102      // "By default, after compositing the contents of the drawing buffer shall be cleared to their default values, as shown in the table above.
103      // This default behavior can be changed by setting the preserveDrawingBuffer attribute of the WebGLContextAttributes object.
104      // If this flag is true, the contents of the drawing buffer shall be preserved until the author either clears or overwrites them."
105      if (!m_context_creation_parameters.preserve_drawing_buffer) {
106          context().clear_buffer_to_default_values();
107      }
108  }
109  
110  GC::Ref<HTML::HTMLCanvasElement> WebGLRenderingContext::canvas_for_binding() const
111  {
112      return *m_canvas_element;
113  }
114  
115  void WebGLRenderingContext::needs_to_present()
116  {
117      m_should_present = true;
118  
119      if (!m_canvas_element->paintable())
120          return;
121      m_canvas_element->paintable()->set_needs_display();
122  }
123  
124  void WebGLRenderingContext::set_error(GLenum error)
125  {
126      auto context_error = glGetError();
127      if (context_error != GL_NO_ERROR)
128          m_error = context_error;
129      else
130          m_error = error;
131  }
132  
133  bool WebGLRenderingContext::is_context_lost() const
134  {
135      dbgln_if(WEBGL_CONTEXT_DEBUG, "WebGLRenderingContext::is_context_lost()");
136      return m_context_lost;
137  }
138  
139  Optional<WebGLContextAttributes> WebGLRenderingContext::get_context_attributes()
140  {
141      if (is_context_lost())
142          return {};
143      return m_actual_context_parameters;
144  }
145  
146  void WebGLRenderingContext::set_size(Gfx::IntSize const& size)
147  {
148      context().set_size(size);
149  }
150  
151  void WebGLRenderingContext::reset_to_default_state()
152  {
153  }
154  
155  RefPtr<Gfx::PaintingSurface> WebGLRenderingContext::surface()
156  {
157      return context().surface();
158  }
159  
160  void WebGLRenderingContext::allocate_painting_surface_if_needed()
161  {
162      context().allocate_painting_surface_if_needed();
163  }
164  
165  Optional<Vector<String>> WebGLRenderingContext::get_supported_extensions()
166  {
167      return context().get_supported_extensions();
168  }
169  
170  JS::Object* WebGLRenderingContext::get_extension(String const& name)
171  {
172      if (name == "ANGLE_instanced_arrays"sv) {
173          return MUST(ANGLEInstancedArrays::create(realm()));
174      }
175      return nullptr;
176  }
177  
178  WebIDL::Long WebGLRenderingContext::drawing_buffer_width() const
179  {
180      auto size = canvas_for_binding()->bitmap_size_for_canvas();
181      return size.width();
182  }
183  
184  WebIDL::Long WebGLRenderingContext::drawing_buffer_height() const
185  {
186      auto size = canvas_for_binding()->bitmap_size_for_canvas();
187      return size.height();
188  }
189  
190  }
</document_content>
</document>
<document index="16">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLProgram.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #include <LibJS/Runtime/Realm.h>
10  #include <LibWeb/Bindings/Intrinsics.h>
11  #include <LibWeb/Bindings/WebGLProgramPrototype.h>
12  #include <LibWeb/WebGL/WebGLProgram.h>
13  
14  namespace Web::WebGL {
15  
16  GC_DEFINE_ALLOCATOR(WebGLProgram);
17  
18  GC::Ref<WebGLProgram> WebGLProgram::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
19  {
20      return realm.create<WebGLProgram>(realm, context, handle);
21  }
22  
23  WebGLProgram::WebGLProgram(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
24      : WebGLObject(realm, context, handle)
25  {
26  }
27  
28  WebGLProgram::~WebGLProgram() = default;
29  
30  void WebGLProgram::initialize(JS::Realm& realm)
31  {
32      Base::initialize(realm);
33      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLProgram);
34  }
35  
36  }
</document_content>
</document>
<document index="17">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLQuery.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/WebGL/Types.h>
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLQuery : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLQuery, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLQuery);
17  
18  public:
19      static GC::Ref<WebGLQuery> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
20  
21      virtual ~WebGLQuery() override;
22  
23  protected:
24      explicit WebGLQuery(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
25  
26      virtual void initialize(JS::Realm&) override;
27  };
28  
29  }
</document_content>
</document>
<document index="18">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLRenderingContextBase.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  namespace Web::WebGL {
10  
11  // FIXME: This object should inherit from Bindings::PlatformObject and implement the WebGLRenderingContextBase IDL interface.
12  //        We should make WebGL code generator to produce implementation for this interface.
13  class WebGLRenderingContextBase {
14  public:
15      virtual GC::Cell const* gc_cell() const = 0;
16  };
17  
18  }
</document_content>
</document>
<document index="19">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLTexture.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #include <LibJS/Runtime/Realm.h>
10  #include <LibWeb/Bindings/Intrinsics.h>
11  #include <LibWeb/Bindings/WebGLTexturePrototype.h>
12  #include <LibWeb/WebGL/WebGLTexture.h>
13  
14  namespace Web::WebGL {
15  
16  GC_DEFINE_ALLOCATOR(WebGLTexture);
17  
18  GC::Ref<WebGLTexture> WebGLTexture::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
19  {
20      return realm.create<WebGLTexture>(realm, context, handle);
21  }
22  
23  WebGLTexture::WebGLTexture(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
24      : WebGLObject(realm, context, handle)
25  {
26  }
27  
28  WebGLTexture::~WebGLTexture() = default;
29  
30  void WebGLTexture::initialize(JS::Realm& realm)
31  {
32      Base::initialize(realm);
33      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLTexture);
34  }
35  
36  }
</document_content>
</document>
<document index="20">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLShaderPrecisionFormat.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #pragma once
 9  
10  #include <LibWeb/Bindings/PlatformObject.h>
11  #include <LibWeb/WebGL/Types.h>
12  
13  namespace Web::WebGL {
14  
15  class WebGLShaderPrecisionFormat final : public Bindings::PlatformObject {
16      WEB_PLATFORM_OBJECT(WebGLShaderPrecisionFormat, Bindings::PlatformObject);
17      GC_DECLARE_ALLOCATOR(WebGLShaderPrecisionFormat);
18  
19  public:
20      static GC::Ref<WebGLShaderPrecisionFormat> create(JS::Realm& realm, GLint range_min, GLint range_max, GLint precision);
21  
22      virtual ~WebGLShaderPrecisionFormat() override;
23  
24      GLint range_min() const { return m_range_min; }
25      GLint range_max() const { return m_range_max; }
26      GLint precision() const { return m_precision; }
27  
28  protected:
29      explicit WebGLShaderPrecisionFormat(JS::Realm&, GLint range_min, GLint range_max, GLint precision);
30  
31      virtual void initialize(JS::Realm&) override;
32  
33  private:
34      GLint m_range_min { 0 };
35      GLint m_range_max { 0 };
36      GLint m_precision { 0 };
37  };
38  
39  }
</document_content>
</document>
<document index="21">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLRenderbuffer.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #include <LibJS/Runtime/Realm.h>
 9  #include <LibWeb/Bindings/Intrinsics.h>
10  #include <LibWeb/Bindings/WebGLRenderbufferPrototype.h>
11  #include <LibWeb/WebGL/WebGLRenderbuffer.h>
12  
13  namespace Web::WebGL {
14  
15  GC_DEFINE_ALLOCATOR(WebGLRenderbuffer);
16  
17  GC::Ref<WebGLRenderbuffer> WebGLRenderbuffer::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
18  {
19      return realm.create<WebGLRenderbuffer>(realm, context, handle);
20  }
21  
22  WebGLRenderbuffer::WebGLRenderbuffer(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
23      : WebGLObject(realm, context, handle)
24  {
25  }
26  
27  WebGLRenderbuffer::~WebGLRenderbuffer() = default;
28  
29  void WebGLRenderbuffer::initialize(JS::Realm& realm)
30  {
31      Base::initialize(realm);
32      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLRenderbuffer);
33  }
34  
35  }
</document_content>
</document>
<document index="22">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLFramebuffer.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #include <LibJS/Runtime/Realm.h>
 9  #include <LibWeb/Bindings/Intrinsics.h>
10  #include <LibWeb/Bindings/WebGLFramebufferPrototype.h>
11  #include <LibWeb/WebGL/WebGLFramebuffer.h>
12  
13  namespace Web::WebGL {
14  
15  GC_DEFINE_ALLOCATOR(WebGLFramebuffer);
16  
17  GC::Ref<WebGLFramebuffer> WebGLFramebuffer::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
18  {
19      return realm.create<WebGLFramebuffer>(realm, context, handle);
20  }
21  
22  WebGLFramebuffer::WebGLFramebuffer(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
23      : WebGLObject(realm, context, handle)
24  {
25  }
26  
27  WebGLFramebuffer::~WebGLFramebuffer() = default;
28  
29  void WebGLFramebuffer::initialize(JS::Realm& realm)
30  {
31      Base::initialize(realm);
32      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLFramebuffer);
33  }
34  
35  }
</document_content>
</document>
<document index="23">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLContextAttributes.cpp</source>
<document_content>
  1  /*
  2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
  3   *
  4   * SPDX-License-Identifier: BSD-2-Clause
  5   */
  6  
  7  #include <LibJS/Runtime/Completion.h>
  8  #include <LibJS/Runtime/GlobalObject.h>
  9  #include <LibJS/Runtime/ValueInlines.h>
 10  #include <LibWeb/WebGL/WebGLContextAttributes.h>
 11  
 12  namespace Web::WebGL {
 13  
 14  JS::ThrowCompletionOr<WebGLContextAttributes> convert_value_to_context_attributes_dictionary(JS::VM& vm, JS::Value value)
 15  {
 16      // NOTE: This code was generated by the IDL code generator and then cleaned up.
 17      if (!value.is_nullish() && !value.is_object())
 18          return vm.throw_completion<JS::TypeError>(JS::ErrorType::NotAnObjectOfType, "WebGLContextAttributes");
 19  
 20      WebGLContextAttributes context_attributes {};
 21  
 22      JS::Value alpha;
 23      if (value.is_nullish())
 24          alpha = JS::js_undefined();
 25      else
 26          alpha = TRY(value.as_object().get("alpha"));
 27  
 28      bool alpha_value;
 29      if (!alpha.is_undefined())
 30          alpha_value = alpha.to_boolean();
 31      else
 32          alpha_value = true;
 33  
 34      context_attributes.alpha = alpha_value;
 35  
 36      JS::Value antialias;
 37      if (value.is_nullish())
 38          antialias = JS::js_undefined();
 39      else
 40          antialias = TRY(value.as_object().get("antialias"));
 41  
 42      bool antialias_value;
 43      if (!antialias.is_undefined())
 44          antialias_value = antialias.to_boolean();
 45      else
 46          antialias_value = true;
 47  
 48      context_attributes.antialias = antialias_value;
 49  
 50      JS::Value depth;
 51      if (value.is_nullish())
 52          depth = JS::js_undefined();
 53      else
 54          depth = TRY(value.as_object().get("depth"));
 55  
 56      bool depth_value;
 57      if (!depth.is_undefined())
 58          depth_value = depth.to_boolean();
 59      else
 60          depth_value = true;
 61  
 62      context_attributes.depth = depth_value;
 63  
 64      JS::Value desynchronized;
 65      if (value.is_nullish())
 66          desynchronized = JS::js_undefined();
 67      else
 68          desynchronized = TRY(value.as_object().get("desynchronized"));
 69  
 70      bool desynchronized_value;
 71  
 72      if (!desynchronized.is_undefined())
 73          desynchronized_value = desynchronized.to_boolean();
 74      else
 75          desynchronized_value = false;
 76  
 77      context_attributes.desynchronized = desynchronized_value;
 78  
 79      JS::Value fail_if_major_performance_caveat;
 80      if (value.is_nullish())
 81          fail_if_major_performance_caveat = JS::js_undefined();
 82      else
 83          fail_if_major_performance_caveat = TRY(value.as_object().get("failIfMajorPerformanceCaveat"));
 84  
 85      bool fail_if_major_performance_caveat_value;
 86      if (!fail_if_major_performance_caveat.is_undefined())
 87          fail_if_major_performance_caveat_value = fail_if_major_performance_caveat.to_boolean();
 88      else
 89          fail_if_major_performance_caveat_value = false;
 90  
 91      context_attributes.fail_if_major_performance_caveat = fail_if_major_performance_caveat_value;
 92  
 93      JS::Value power_preference;
 94      if (value.is_nullish())
 95          power_preference = JS::js_undefined();
 96      else
 97          power_preference = TRY(value.as_object().get("powerPreference"));
 98  
 99      Bindings::WebGLPowerPreference power_preference_value { Bindings::WebGLPowerPreference::Default };
100  
101      if (!power_preference.is_undefined()) {
102          auto power_preference_string = TRY(power_preference.to_string(vm));
103  
104          if (power_preference_string == "high-performance"sv)
105              power_preference_value = Bindings::WebGLPowerPreference::HighPerformance;
106          else if (power_preference_string == "low-power"sv)
107              power_preference_value = Bindings::WebGLPowerPreference::LowPower;
108          else if (power_preference_string == "default"sv)
109              power_preference_value = Bindings::WebGLPowerPreference::Default;
110          else
111              return vm.throw_completion<JS::TypeError>(JS::ErrorType::InvalidEnumerationValue, power_preference_string, "WebGLPowerPreference");
112      }
113  
114      context_attributes.power_preference = power_preference_value;
115  
116      JS::Value premultiplied_alpha;
117      if (value.is_nullish())
118          premultiplied_alpha = JS::js_undefined();
119      else
120          premultiplied_alpha = TRY(value.as_object().get("premultipliedAlpha"));
121  
122      bool premultiplied_alpha_value;
123  
124      if (!premultiplied_alpha.is_undefined())
125          premultiplied_alpha_value = premultiplied_alpha.to_boolean();
126      else
127          premultiplied_alpha_value = true;
128  
129      context_attributes.premultiplied_alpha = premultiplied_alpha_value;
130  
131      JS::Value preserve_drawing_buffer;
132      if (value.is_nullish())
133          preserve_drawing_buffer = JS::js_undefined();
134      else
135          preserve_drawing_buffer = TRY(value.as_object().get("preserveDrawingBuffer"));
136  
137      bool preserve_drawing_buffer_value;
138      if (!preserve_drawing_buffer.is_undefined())
139          preserve_drawing_buffer_value = preserve_drawing_buffer.to_boolean();
140      else
141          preserve_drawing_buffer_value = false;
142  
143      context_attributes.preserve_drawing_buffer = preserve_drawing_buffer_value;
144  
145      JS::Value stencil;
146      if (value.is_nullish())
147          stencil = JS::js_undefined();
148      else
149          stencil = TRY(value.as_object().get("stencil"));
150  
151      bool stencil_value;
152  
153      if (!stencil.is_undefined())
154          stencil_value = stencil.to_boolean();
155      else
156          stencil_value = false;
157  
158      context_attributes.stencil = stencil_value;
159  
160      return context_attributes;
161  }
162  
163  }
</document_content>
</document>
<document index="24">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLBuffer.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #include <LibJS/Runtime/Realm.h>
10  #include <LibWeb/Bindings/Intrinsics.h>
11  #include <LibWeb/Bindings/WebGLBufferPrototype.h>
12  #include <LibWeb/WebGL/WebGLBuffer.h>
13  
14  namespace Web::WebGL {
15  
16  GC_DEFINE_ALLOCATOR(WebGLBuffer);
17  
18  GC::Ref<WebGLBuffer> WebGLBuffer::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
19  {
20      return realm.create<WebGLBuffer>(realm, context, handle);
21  }
22  
23  WebGLBuffer::WebGLBuffer(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
24      : WebGLObject(realm, context, handle)
25  {
26  }
27  
28  WebGLBuffer::~WebGLBuffer() = default;
29  
30  void WebGLBuffer::initialize(JS::Realm& realm)
31  {
32      Base::initialize(realm);
33      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLBuffer);
34  }
35  
36  }
</document_content>
</document>
<document index="25">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLShaderPrecisionFormat.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #include <LibJS/Runtime/Realm.h>
 9  #include <LibWeb/Bindings/Intrinsics.h>
10  #include <LibWeb/Bindings/WebGLShaderPrecisionFormatPrototype.h>
11  #include <LibWeb/WebGL/WebGLShaderPrecisionFormat.h>
12  
13  namespace Web::WebGL {
14  
15  GC_DEFINE_ALLOCATOR(WebGLShaderPrecisionFormat);
16  
17  GC::Ref<WebGLShaderPrecisionFormat> WebGLShaderPrecisionFormat::create(JS::Realm& realm, GLint range_min, GLint range_max, GLint precision)
18  {
19      return realm.create<WebGLShaderPrecisionFormat>(realm, range_min, range_max, precision);
20  }
21  
22  WebGLShaderPrecisionFormat::WebGLShaderPrecisionFormat(JS::Realm& realm, GLint range_min, GLint range_max, GLint precision)
23      : Bindings::PlatformObject(realm)
24      , m_range_min(range_min)
25      , m_range_max(range_max)
26      , m_precision(precision)
27  {
28  }
29  
30  WebGLShaderPrecisionFormat::~WebGLShaderPrecisionFormat() = default;
31  
32  void WebGLShaderPrecisionFormat::initialize(JS::Realm& realm)
33  {
34      Base::initialize(realm);
35      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLShaderPrecisionFormat);
36  }
37  
38  }
</document_content>
</document>
<document index="26">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLBuffer.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #pragma once
10  
11  #include <LibWeb/WebGL/Types.h>
12  #include <LibWeb/WebGL/WebGLObject.h>
13  
14  namespace Web::WebGL {
15  
16  class WebGLBuffer final : public WebGLObject {
17      WEB_PLATFORM_OBJECT(WebGLBuffer, WebGLObject);
18      GC_DECLARE_ALLOCATOR(WebGLBuffer);
19  
20  public:
21      static GC::Ref<WebGLBuffer> create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle);
22  
23      virtual ~WebGLBuffer();
24  
25  protected:
26      explicit WebGLBuffer(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
27  
28      virtual void initialize(JS::Realm&) override;
29  };
30  
31  }
</document_content>
</document>
<document index="27">
<source>./Ladybird/Libraries/LibWeb/WebGL/EventNames.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2023, Kenneth Myhra <kennethmyhra@serenityos.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibWeb/WebGL/EventNames.h>
 8  
 9  namespace Web::WebGL::EventNames {
10  
11  #define __ENUMERATE_GL_EVENT(name) FlyString name;
12  ENUMERATE_GL_EVENTS
13  #undef __ENUMERATE_GL_EVENT
14  
15  void initialize_strings()
16  {
17      static bool s_initialized = false;
18      VERIFY(!s_initialized);
19  
20  #define __ENUMERATE_GL_EVENT(name) \
21      name = #name##_fly_string;
22      ENUMERATE_GL_EVENTS
23  #undef __ENUMERATE_GL_EVENT
24  
25      s_initialized = true;
26  }
27  
28  }
</document_content>
</document>
<document index="28">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLVertexArrayObject.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/Intrinsics.h>
 9  #include <LibWeb/Bindings/WebGLVertexArrayObjectPrototype.h>
10  #include <LibWeb/WebGL/WebGLVertexArrayObject.h>
11  
12  namespace Web::WebGL {
13  
14  GC_DEFINE_ALLOCATOR(WebGLVertexArrayObject);
15  
16  GC::Ref<WebGLVertexArrayObject> WebGLVertexArrayObject::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
17  {
18      return realm.create<WebGLVertexArrayObject>(realm, context, handle);
19  }
20  
21  WebGLVertexArrayObject::WebGLVertexArrayObject(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
22      : WebGLObject(realm, context, handle)
23  {
24  }
25  
26  WebGLVertexArrayObject::~WebGLVertexArrayObject() = default;
27  
28  void WebGLVertexArrayObject::initialize(JS::Realm& realm)
29  {
30      Base::initialize(realm);
31      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLVertexArrayObject);
32  }
33  
34  }
</document_content>
</document>
<document index="29">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLSync.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/Intrinsics.h>
 9  #include <LibWeb/Bindings/WebGLSyncPrototype.h>
10  #include <LibWeb/WebGL/WebGLSync.h>
11  
12  namespace Web::WebGL {
13  
14  GC_DEFINE_ALLOCATOR(WebGLSync);
15  
16  GC::Ref<WebGLSync> WebGLSync::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLsyncInternal handle)
17  {
18      return realm.create<WebGLSync>(realm, context, handle);
19  }
20  
21  WebGLSync::WebGLSync(JS::Realm& realm, WebGLRenderingContextBase& context, GLsyncInternal handle)
22      : WebGLObject(realm, context, 0)
23      , m_sync_handle(handle)
24  {
25  }
26  
27  WebGLSync::~WebGLSync() = default;
28  
29  void WebGLSync::initialize(JS::Realm& realm)
30  {
31      Base::initialize(realm);
32      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLSync);
33  }
34  
35  }
</document_content>
</document>
<document index="30">
<source>./Ladybird/Libraries/LibWeb/WebGL/ANGLEInstancedArrays.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/Bindings/PlatformObject.h>
10  #include <LibWeb/Forward.h>
11  #include <LibWeb/WebGL/Types.h>
12  
13  namespace Web::WebGL {
14  
15  class ANGLEInstancedArrays : public Bindings::PlatformObject {
16      WEB_PLATFORM_OBJECT(ANGLEInstancedArrays, Bindings::PlatformObject);
17      GC_DECLARE_ALLOCATOR(ANGLEInstancedArrays);
18  
19  public:
20      static JS::ThrowCompletionOr<GC::Ptr<ANGLEInstancedArrays>> create(JS::Realm&);
21  
22      void draw_arrays_instanced_angle(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
23      void draw_elements_instanced_angle(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei primcount);
24      void vertex_attrib_divisor_angle(GLuint index, GLuint divisor);
25  
26  protected:
27      void initialize(JS::Realm&) override;
28  
29  private:
30      ANGLEInstancedArrays(JS::Realm&);
31  };
32  
33  }
</document_content>
</document>
<document index="31">
<source>./Ladybird/Libraries/LibWeb/WebGL/OpenGLContext.cpp</source>
<document_content>
  1  /*
  2   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
  3   *
  4   * SPDX-License-Identifier: BSD-2-Clause
  5   */
  6  
  7  #include <AK/OwnPtr.h>
  8  #include <AK/String.h>
  9  #include <LibGfx/PaintingSurface.h>
 10  #include <LibWeb/WebGL/OpenGLContext.h>
 11  
 12  #ifdef AK_OS_MACOS
 13  #    include <EGL/egl.h>
 14  #    include <EGL/eglext.h>
 15  #    include <EGL/eglext_angle.h>
 16  #    include <GLES2/gl2.h>
 17  #    include <GLES2/gl2ext.h>
 18  #    include <GLES2/gl2ext_angle.h>
 19  #endif
 20  
 21  namespace Web::WebGL {
 22  
 23  struct OpenGLContext::Impl {
 24  #ifdef AK_OS_MACOS
 25      EGLDisplay display { nullptr };
 26      EGLConfig config { nullptr };
 27      EGLContext context { nullptr };
 28      EGLSurface surface { nullptr };
 29  
 30      GLuint framebuffer { 0 };
 31      GLuint depth_buffer { 0 };
 32  #endif
 33  };
 34  
 35  OpenGLContext::OpenGLContext(NonnullRefPtr<Gfx::SkiaBackendContext> skia_backend_context, Impl impl)
 36      : m_skia_backend_context(move(skia_backend_context))
 37      , m_impl(make<Impl>(impl))
 38  {
 39  }
 40  
 41  OpenGLContext::~OpenGLContext()
 42  {
 43  #ifdef AK_OS_MACOS
 44      eglMakeCurrent(m_impl->display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
 45      glDeleteFramebuffers(1, &m_impl->framebuffer);
 46      glDeleteRenderbuffers(1, &m_impl->depth_buffer);
 47      eglDestroyContext(m_impl->display, m_impl->context);
 48      eglDestroySurface(m_impl->display, m_impl->surface);
 49  #endif
 50  }
 51  
 52  #ifdef AK_OS_MACOS
 53  static EGLConfig get_egl_config(EGLDisplay display)
 54  {
 55      EGLint const config_attribs[] = {
 56          EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
 57          EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
 58          EGL_RED_SIZE, 8,
 59          EGL_GREEN_SIZE, 8,
 60          EGL_BLUE_SIZE, 8,
 61          EGL_ALPHA_SIZE, 8,
 62          EGL_DEPTH_SIZE, 24,
 63          EGL_STENCIL_SIZE, 8,
 64          EGL_NONE
 65      };
 66  
 67      EGLint number_of_configs;
 68      eglChooseConfig(display, config_attribs, NULL, 0, &number_of_configs);
 69  
 70      Vector<EGLConfig> configs;
 71      configs.resize(number_of_configs);
 72      eglChooseConfig(display, config_attribs, configs.data(), number_of_configs, &number_of_configs);
 73      return configs[0];
 74  }
 75  #endif
 76  
 77  OwnPtr<OpenGLContext> OpenGLContext::create(NonnullRefPtr<Gfx::SkiaBackendContext> skia_backend_context)
 78  {
 79  #ifdef AK_OS_MACOS
 80      EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
 81      if (display == EGL_NO_DISPLAY) {
 82          dbgln("Failed to get EGL display");
 83          return {};
 84      }
 85  
 86      EGLint major, minor;
 87      if (!eglInitialize(display, &major, &minor)) {
 88          dbgln("Failed to initialize EGL");
 89          return {};
 90      }
 91  
 92      auto* config = get_egl_config(display);
 93  
 94      EGLint context_attributes[] = {
 95          EGL_CONTEXT_CLIENT_VERSION, 2,
 96          EGL_NONE
 97      };
 98      EGLContext context = eglCreateContext(display, config, EGL_NO_CONTEXT, context_attributes);
 99      if (context == EGL_NO_CONTEXT) {
100          dbgln("Failed to create EGL context");
101          return {};
102      }
103  
104      return make<OpenGLContext>(skia_backend_context, Impl { .display = display, .config = config, .context = context });
105  #else
106      (void)skia_backend_context;
107      return nullptr;
108  #endif
109  }
110  
111  void OpenGLContext::notify_content_will_change()
112  {
113      m_painting_surface->notify_content_will_change();
114  }
115  
116  void OpenGLContext::clear_buffer_to_default_values()
117  {
118  }
119  
120  void OpenGLContext::allocate_painting_surface_if_needed()
121  {
122  #ifdef AK_OS_MACOS
123      if (m_painting_surface)
124          return;
125  
126      VERIFY(!m_size.is_empty());
127  
128      auto iosurface = Core::IOSurfaceHandle::create(m_size.width(), m_size.height());
129      m_painting_surface = Gfx::PaintingSurface::wrap_iosurface(iosurface, m_skia_backend_context, Gfx::PaintingSurface::Origin::BottomLeft);
130  
131      auto width = m_size.width();
132      auto height = m_size.height();
133  
134      auto* display = m_impl->display;
135      auto* config = m_impl->config;
136  
137      EGLint target = 0;
138      eglGetConfigAttrib(display, config, EGL_BIND_TO_TEXTURE_TARGET_ANGLE, &target);
139  
140      EGLint const surface_attributes[] = {
141          EGL_WIDTH,
142          width,
143          EGL_HEIGHT,
144          height,
145          EGL_IOSURFACE_PLANE_ANGLE,
146          0,
147          EGL_TEXTURE_TARGET,
148          target,
149          EGL_TEXTURE_INTERNAL_FORMAT_ANGLE,
150          GL_BGRA_EXT,
151          EGL_TEXTURE_FORMAT,
152          EGL_TEXTURE_RGBA,
153          EGL_TEXTURE_TYPE_ANGLE,
154          GL_UNSIGNED_BYTE,
155          EGL_NONE,
156          EGL_NONE,
157      };
158      m_impl->surface = eglCreatePbufferFromClientBuffer(display, EGL_IOSURFACE_ANGLE, iosurface.core_foundation_pointer(), config, surface_attributes);
159  
160      eglMakeCurrent(m_impl->display, m_impl->surface, m_impl->surface, m_impl->context);
161  
162      EGLint texture_target_angle = 0;
163      eglGetConfigAttrib(display, config, EGL_BIND_TO_TEXTURE_TARGET_ANGLE, &texture_target_angle);
164      VERIFY(texture_target_angle == EGL_TEXTURE_RECTANGLE_ANGLE);
165  
166      GLuint texture = 0;
167      glGenTextures(1, &texture);
168      glBindTexture(GL_TEXTURE_RECTANGLE_ANGLE, texture);
169      auto result = eglBindTexImage(display, m_impl->surface, EGL_BACK_BUFFER);
170      VERIFY(result == EGL_TRUE);
171  
172      glGenFramebuffers(1, &m_impl->framebuffer);
173      glBindFramebuffer(GL_FRAMEBUFFER, m_impl->framebuffer);
174      glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ANGLE, texture, 0);
175  
176      // NOTE: ANGLE doesn't allocate depth buffer for us, so we need to do it manually
177      // FIXME: Depth buffer only needs to be allocated if it's configured in WebGL context attributes
178      glGenRenderbuffers(1, &m_impl->depth_buffer);
179      glBindRenderbuffer(GL_RENDERBUFFER, m_impl->depth_buffer);
180      glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);
181      glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_impl->depth_buffer);
182  #endif
183  }
184  
185  void OpenGLContext::set_size(Gfx::IntSize const& size)
186  {
187      if (m_size != size) {
188          m_painting_surface = nullptr;
189      }
190      m_size = size;
191  }
192  
193  void OpenGLContext::make_current()
194  {
195  #ifdef AK_OS_MACOS
196      allocate_painting_surface_if_needed();
197      eglMakeCurrent(m_impl->display, m_impl->surface, m_impl->surface, m_impl->context);
198  #endif
199  }
200  
201  RefPtr<Gfx::PaintingSurface> OpenGLContext::surface()
202  {
203      return m_painting_surface;
204  }
205  
206  Vector<StringView> s_available_webgl_extensions {
207      // Khronos ratified WebGL Extensions
208      "ANGLE_instanced_arrays"sv,
209      "EXT_blend_minmax"sv,
210      "EXT_frag_depth"sv,
211      "EXT_shader_texture_lod"sv,
212      "EXT_texture_filter_anisotropic"sv,
213      "OES_element_index_uint"sv,
214      "OES_standard_derivatives"sv,
215      "OES_texture_float"sv,
216      "OES_texture_float_linear"sv,
217      "OES_texture_half_float"sv,
218      "OES_texture_half_float_linear"sv,
219      "OES_vertex_array_object"sv,
220      "WEBGL_compressed_texture_s3tc"sv,
221      "WEBGL_debug_renderer_info"sv,
222      "WEBGL_debug_shaders"sv,
223      "WEBGL_depth_texture"sv,
224      "WEBGL_draw_buffers"sv,
225      "WEBGL_lose_context"sv,
226  
227      // Community approved WebGL Extensions
228      "EXT_clip_control"sv,
229      "EXT_color_buffer_float"sv,
230      "EXT_color_buffer_half_float"sv,
231      "EXT_conservative_depth"sv,
232      "EXT_depth_clamp"sv,
233      "EXT_disjoint_timer_query"sv,
234      "EXT_disjoint_timer_query_webgl2"sv,
235      "EXT_float_blend"sv,
236      "EXT_polygon_offset_clamp"sv,
237      "EXT_render_snorm"sv,
238      "EXT_sRGB"sv,
239      "EXT_texture_compression_bptc"sv,
240      "EXT_texture_compression_rgtc"sv,
241      "EXT_texture_mirror_clamp_to_edge"sv,
242      "EXT_texture_norm16"sv,
243      "KHR_parallel_shader_compile"sv,
244      "NV_shader_noperspective_interpolation"sv,
245      "OES_draw_buffers_indexed"sv,
246      "OES_fbo_render_mipmap"sv,
247      "OES_sample_variables"sv,
248      "OES_shader_multisample_interpolation"sv,
249      "OVR_multiview2"sv,
250      "WEBGL_blend_func_extended"sv,
251      "WEBGL_clip_cull_distance"sv,
252      "WEBGL_color_buffer_float"sv,
253      "WEBGL_compressed_texture_astc"sv,
254      "WEBGL_compressed_texture_etc"sv,
255      "WEBGL_compressed_texture_etc1"sv,
256      "WEBGL_compressed_texture_pvrtc"sv,
257      "WEBGL_compressed_texture_s3tc_srgb"sv,
258      "WEBGL_multi_draw"sv,
259      "WEBGL_polygon_mode"sv,
260      "WEBGL_provoking_vertex"sv,
261      "WEBGL_render_shared_exponent"sv,
262      "WEBGL_stencil_texturing"sv,
263  };
264  
265  Vector<String> OpenGLContext::get_supported_extensions()
266  {
267  #ifdef AK_OS_MACOS
268      make_current();
269  
270      auto const* extensions_string = reinterpret_cast<char const*>(glGetString(GL_EXTENSIONS));
271      StringView extensions_view(extensions_string, strlen(extensions_string));
272  
273      Vector<String> extensions;
274      for (auto const& extension : extensions_view.split_view(' ')) {
275          auto extension_name_without_gl_prefix = extension.substring_view(3);
276          // FIXME: WebGL 1 and WebGL 2 have different sets of available extensions, but for now we simply
277          //        filter out everything that is not listed in https://registry.khronos.org/webgl/extensions/
278          if (s_available_webgl_extensions.contains_slow(extension_name_without_gl_prefix))
279              extensions.append(MUST(String::from_utf8(extension_name_without_gl_prefix)));
280      }
281  
282      return extensions;
283  #else
284      return {};
285  #endif
286  }
287  
288  }
</document_content>
</document>
<document index="32">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLSync.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/WebGL/Types.h>
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLSync : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLSync, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLSync);
17  
18  public:
19      static GC::Ref<WebGLSync> create(JS::Realm& realm, WebGLRenderingContextBase&, GLsyncInternal handle);
20  
21      virtual ~WebGLSync() override;
22  
23      GLsyncInternal sync_handle() const { return m_sync_handle; }
24  
25  protected:
26      explicit WebGLSync(JS::Realm&, WebGLRenderingContextBase&, GLsyncInternal handle);
27  
28      virtual void initialize(JS::Realm&) override;
29  
30      GLsyncInternal m_sync_handle { nullptr };
31  };
32  
33  }
</document_content>
</document>
<document index="33">
<source>./Ladybird/Libraries/LibWeb/WebGL/EventNames.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2023, Kenneth Myhra <kennethmyhra@serenityos.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <AK/Error.h>
10  #include <AK/FlyString.h>
11  
12  namespace Web::WebGL::EventNames {
13  
14  #define ENUMERATE_GL_EVENTS                         \
15      __ENUMERATE_GL_EVENT(webglcontextcreationerror) \
16      __ENUMERATE_GL_EVENT(webglcontextlost)          \
17      __ENUMERATE_GL_EVENT(webglcontextrestored)
18  
19  #define __ENUMERATE_GL_EVENT(name) extern FlyString name;
20  ENUMERATE_GL_EVENTS
21  #undef __ENUMERATE_GL_EVENT
22  
23  void initialize_strings();
24  
25  }
</document_content>
</document>
<document index="34">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLRenderingContext.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #pragma once
 9  
10  #include <LibGC/Ptr.h>
11  #include <LibWeb/Bindings/PlatformObject.h>
12  #include <LibWeb/Forward.h>
13  #include <LibWeb/WebGL/Types.h>
14  #include <LibWeb/WebGL/WebGLContextAttributes.h>
15  #include <LibWeb/WebGL/WebGLRenderingContextImpl.h>
16  
17  namespace Web::WebGL {
18  
19  class WebGLRenderingContext : public Bindings::PlatformObject
20      , public WebGLRenderingContextImpl {
21      WEB_PLATFORM_OBJECT(WebGLRenderingContext, Bindings::PlatformObject);
22      GC_DECLARE_ALLOCATOR(WebGLRenderingContext);
23  
24  public:
25      static JS::ThrowCompletionOr<GC::Ptr<WebGLRenderingContext>> create(JS::Realm&, HTML::HTMLCanvasElement& canvas_element, JS::Value options);
26  
27      virtual ~WebGLRenderingContext() override;
28  
29      // FIXME: This is a hack required to visit context from WebGLObject.
30      //        It should be gone once WebGLRenderingContextBase inherits from PlatformObject.
31      GC::Cell const* gc_cell() const override { return this; }
32  
33      void present() override;
34      void needs_to_present() override;
35  
36      GC::Ref<HTML::HTMLCanvasElement> canvas_for_binding() const;
37  
38      bool is_context_lost() const;
39      Optional<WebGLContextAttributes> get_context_attributes();
40  
41      RefPtr<Gfx::PaintingSurface> surface();
42      void allocate_painting_surface_if_needed();
43  
44      void set_size(Gfx::IntSize const&);
45      void reset_to_default_state();
46  
47      Optional<Vector<String>> get_supported_extensions();
48      JS::Object* get_extension(String const& name);
49  
50      WebIDL::Long drawing_buffer_width() const;
51      WebIDL::Long drawing_buffer_height() const;
52  
53  private:
54      virtual void initialize(JS::Realm&) override;
55  
56      WebGLRenderingContext(JS::Realm&, HTML::HTMLCanvasElement&, NonnullOwnPtr<OpenGLContext> context, WebGLContextAttributes context_creation_parameters, WebGLContextAttributes actual_context_parameters);
57  
58      virtual void visit_edges(Cell::Visitor&) override;
59  
60      GC::Ref<HTML::HTMLCanvasElement> m_canvas_element;
61  
62      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#context-creation-parameters
63      // Each WebGLRenderingContext has context creation parameters, set upon creation, in a WebGLContextAttributes object.
64      WebGLContextAttributes m_context_creation_parameters {};
65  
66      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#actual-context-parameters
67      // Each WebGLRenderingContext has actual context parameters, set each time the drawing buffer is created, in a WebGLContextAttributes object.
68      WebGLContextAttributes m_actual_context_parameters {};
69  
70      // https://www.khronos.org/registry/webgl/specs/latest/1.0/#webgl-context-lost-flag
71      // Each WebGLRenderingContext has a webgl context lost flag, which is initially unset.
72      bool m_context_lost { false };
73  
74      // WebGL presents its drawing buffer to the HTML page compositor immediately before a compositing operation, but only if at least one of the following has occurred since the previous compositing operation:
75      // - Context creation
76      // - Canvas resize
77      // - clear, drawArrays, or drawElements has been called while the drawing buffer is the currently bound framebuffer
78      bool m_should_present { true };
79  
80      GLenum m_error { 0 };
81  
82      virtual void set_error(GLenum error) override;
83  };
84  
85  void fire_webgl_context_event(HTML::HTMLCanvasElement& canvas_element, FlyString const& type);
86  void fire_webgl_context_creation_error(HTML::HTMLCanvasElement& canvas_element);
87  
88  }
</document_content>
</document>
<document index="35">
<source>./Ladybird/Libraries/LibWeb/WebGL/Types.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibGC/Root.h>
10  #include <LibWeb/Forward.h>
11  
12  namespace Web::WebGL {
13  
14  using GLenum = unsigned int;
15  using GLuint = unsigned int;
16  using GLint = int;
17  using GLsizei = int;
18  using GLintptr = int;
19  
20  // FIXME: This should really be "struct __GLsync*", but the linker doesn't recognise it.
21  //        Since this conflicts with the original definition of GLsync, the suffix "Internal" has been added.
22  using GLsyncInternal = void*;
23  
24  }
</document_content>
</document>
<document index="36">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLRenderbuffer.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #pragma once
 9  
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLRenderbuffer final : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLRenderbuffer, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLRenderbuffer);
17  
18  public:
19      static GC::Ref<WebGLRenderbuffer> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
20  
21      virtual ~WebGLRenderbuffer();
22  
23  protected:
24      explicit WebGLRenderbuffer(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
25  
26      virtual void initialize(JS::Realm&) override;
27  };
28  
29  }
</document_content>
</document>
<document index="37">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLContextEvent.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2022, Andreas Kling <andreas@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibWeb/Bindings/Intrinsics.h>
 8  #include <LibWeb/Bindings/WebGLContextEventPrototype.h>
 9  #include <LibWeb/WebGL/WebGLContextEvent.h>
10  
11  namespace Web::WebGL {
12  
13  GC_DEFINE_ALLOCATOR(WebGLContextEvent);
14  
15  GC::Ref<WebGLContextEvent> WebGLContextEvent::create(JS::Realm& realm, FlyString const& event_name, WebGLContextEventInit const& event_init)
16  {
17      return realm.create<WebGLContextEvent>(realm, event_name, event_init);
18  }
19  
20  WebIDL::ExceptionOr<GC::Ref<WebGLContextEvent>> WebGLContextEvent::construct_impl(JS::Realm& realm, FlyString const& event_name, WebGLContextEventInit const& event_init)
21  {
22      return create(realm, event_name, event_init);
23  }
24  
25  WebGLContextEvent::WebGLContextEvent(JS::Realm& realm, FlyString const& type, WebGLContextEventInit const& event_init)
26      : DOM::Event(realm, type, event_init)
27      , m_status_message(event_init.status_message)
28  {
29  }
30  
31  WebGLContextEvent::~WebGLContextEvent() = default;
32  
33  void WebGLContextEvent::initialize(JS::Realm& realm)
34  {
35      Base::initialize(realm);
36      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLContextEvent);
37  }
38  
39  }
</document_content>
</document>
<document index="38">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGL2RenderingContext.cpp</source>
<document_content>
  1  /*
  2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
  3   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
  4   * Copyright (c) 2023, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
  5   *
  6   * SPDX-License-Identifier: BSD-2-Clause
  7   */
  8  
  9  #include <LibJS/Runtime/ArrayBuffer.h>
 10  #include <LibJS/Runtime/TypedArray.h>
 11  #include <LibWeb/Bindings/Intrinsics.h>
 12  #include <LibWeb/Bindings/WebGL2RenderingContextPrototype.h>
 13  #include <LibWeb/HTML/HTMLCanvasElement.h>
 14  #include <LibWeb/HTML/TraversableNavigable.h>
 15  #include <LibWeb/Painting/Paintable.h>
 16  #include <LibWeb/WebGL/EventNames.h>
 17  #include <LibWeb/WebGL/OpenGLContext.h>
 18  #include <LibWeb/WebGL/WebGL2RenderingContext.h>
 19  #include <LibWeb/WebGL/WebGLContextEvent.h>
 20  #include <LibWeb/WebGL/WebGLRenderingContext.h>
 21  #include <LibWeb/WebGL/WebGLShader.h>
 22  #include <LibWeb/WebIDL/Buffers.h>
 23  
 24  #include <GLES2/gl2.h>
 25  #include <GLES2/gl2ext.h>
 26  
 27  namespace Web::WebGL {
 28  
 29  GC_DEFINE_ALLOCATOR(WebGL2RenderingContext);
 30  
 31  JS::ThrowCompletionOr<GC::Ptr<WebGL2RenderingContext>> WebGL2RenderingContext::create(JS::Realm& realm, HTML::HTMLCanvasElement& canvas_element, JS::Value options)
 32  {
 33      // We should be coming here from getContext being called on a wrapped <canvas> element.
 34      auto context_attributes = TRY(convert_value_to_context_attributes_dictionary(canvas_element.vm(), options));
 35  
 36      auto skia_backend_context = canvas_element.navigable()->traversable_navigable()->skia_backend_context();
 37      if (!skia_backend_context) {
 38          fire_webgl_context_creation_error(canvas_element);
 39          return GC::Ptr<WebGL2RenderingContext> { nullptr };
 40      }
 41      auto context = OpenGLContext::create(*skia_backend_context);
 42      if (!context) {
 43          fire_webgl_context_creation_error(canvas_element);
 44          return GC::Ptr<WebGL2RenderingContext> { nullptr };
 45      }
 46  
 47      context->set_size(canvas_element.bitmap_size_for_canvas(1, 1));
 48  
 49      return realm.create<WebGL2RenderingContext>(realm, canvas_element, context.release_nonnull(), context_attributes, context_attributes);
 50  }
 51  
 52  WebGL2RenderingContext::WebGL2RenderingContext(JS::Realm& realm, HTML::HTMLCanvasElement& canvas_element, NonnullOwnPtr<OpenGLContext> context, WebGLContextAttributes context_creation_parameters, WebGLContextAttributes actual_context_parameters)
 53      : PlatformObject(realm)
 54      , WebGL2RenderingContextImpl(realm, move(context))
 55      , m_canvas_element(canvas_element)
 56      , m_context_creation_parameters(context_creation_parameters)
 57      , m_actual_context_parameters(actual_context_parameters)
 58  {
 59  }
 60  
 61  WebGL2RenderingContext::~WebGL2RenderingContext() = default;
 62  
 63  void WebGL2RenderingContext::initialize(JS::Realm& realm)
 64  {
 65      Base::initialize(realm);
 66      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGL2RenderingContext);
 67  }
 68  
 69  void WebGL2RenderingContext::visit_edges(Cell::Visitor& visitor)
 70  {
 71      Base::visit_edges(visitor);
 72      visitor.visit(m_canvas_element);
 73  }
 74  
 75  void WebGL2RenderingContext::present()
 76  {
 77      if (!m_should_present)
 78          return;
 79  
 80      m_should_present = false;
 81  
 82      // "Before the drawing buffer is presented for compositing the implementation shall ensure that all rendering operations have been flushed to the drawing buffer."
 83      glFlush();
 84  
 85      // "By default, after compositing the contents of the drawing buffer shall be cleared to their default values, as shown in the table above.
 86      // This default behavior can be changed by setting the preserveDrawingBuffer attribute of the WebGLContextAttributes object.
 87      // If this flag is true, the contents of the drawing buffer shall be preserved until the author either clears or overwrites them."
 88      if (!m_context_creation_parameters.preserve_drawing_buffer) {
 89          context().clear_buffer_to_default_values();
 90      }
 91  }
 92  
 93  GC::Ref<HTML::HTMLCanvasElement> WebGL2RenderingContext::canvas_for_binding() const
 94  {
 95      return *m_canvas_element;
 96  }
 97  
 98  void WebGL2RenderingContext::needs_to_present()
 99  {
100      m_should_present = true;
101  
102      if (!m_canvas_element->paintable())
103          return;
104      m_canvas_element->paintable()->set_needs_display();
105  }
106  
107  void WebGL2RenderingContext::set_error(GLenum error)
108  {
109      auto context_error = glGetError();
110      if (context_error != GL_NO_ERROR)
111          m_error = context_error;
112      else
113          m_error = error;
114  }
115  
116  bool WebGL2RenderingContext::is_context_lost() const
117  {
118      dbgln_if(WEBGL_CONTEXT_DEBUG, "WebGLRenderingContext::is_context_lost()");
119      return m_context_lost;
120  }
121  
122  Optional<WebGLContextAttributes> WebGL2RenderingContext::get_context_attributes()
123  {
124      if (is_context_lost())
125          return {};
126      return m_actual_context_parameters;
127  }
128  
129  void WebGL2RenderingContext::set_size(Gfx::IntSize const& size)
130  {
131      context().set_size(size);
132  }
133  
134  void WebGL2RenderingContext::reset_to_default_state()
135  {
136  }
137  
138  RefPtr<Gfx::PaintingSurface> WebGL2RenderingContext::surface()
139  {
140      return context().surface();
141  }
142  
143  void WebGL2RenderingContext::allocate_painting_surface_if_needed()
144  {
145      context().allocate_painting_surface_if_needed();
146  }
147  
148  Optional<Vector<String>> WebGL2RenderingContext::get_supported_extensions()
149  {
150      return context().get_supported_extensions();
151  }
152  
153  JS::Object* WebGL2RenderingContext::get_extension(String const&)
154  {
155      return nullptr;
156  }
157  
158  WebIDL::Long WebGL2RenderingContext::drawing_buffer_width() const
159  {
160      auto size = canvas_for_binding()->bitmap_size_for_canvas();
161      return size.width();
162  }
163  
164  WebIDL::Long WebGL2RenderingContext::drawing_buffer_height() const
165  {
166      auto size = canvas_for_binding()->bitmap_size_for_canvas();
167      return size.height();
168  }
169  
170  }
</document_content>
</document>
<document index="39">
<source>./Ladybird/Libraries/LibWeb/WebGL/ANGLEInstancedArrays.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/ANGLEInstancedArraysPrototype.h>
 9  #include <LibWeb/Bindings/Intrinsics.h>
10  #include <LibWeb/WebGL/ANGLEInstancedArrays.h>
11  
12  #define GL_GLEXT_PROTOTYPES 1
13  #include <GLES2/gl2.h>
14  #include <GLES2/gl2ext.h>
15  
16  namespace Web::WebGL {
17  
18  GC_DEFINE_ALLOCATOR(ANGLEInstancedArrays);
19  
20  JS::ThrowCompletionOr<GC::Ptr<ANGLEInstancedArrays>> ANGLEInstancedArrays::create(JS::Realm& realm)
21  {
22      return realm.create<ANGLEInstancedArrays>(realm);
23  }
24  
25  ANGLEInstancedArrays::ANGLEInstancedArrays(JS::Realm& realm)
26      : PlatformObject(realm)
27  {
28  }
29  
30  void ANGLEInstancedArrays::vertex_attrib_divisor_angle(GLuint index, GLuint divisor)
31  {
32      glVertexAttribDivisorANGLE(index, divisor);
33  }
34  
35  void ANGLEInstancedArrays::draw_arrays_instanced_angle(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
36  {
37      glDrawArraysInstancedANGLE(mode, first, count, primcount);
38  }
39  
40  void ANGLEInstancedArrays::draw_elements_instanced_angle(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei primcount)
41  {
42      glDrawElementsInstancedANGLE(mode, count, type, reinterpret_cast<void*>(offset), primcount);
43  }
44  
45  void ANGLEInstancedArrays::initialize(JS::Realm& realm)
46  {
47      Base::initialize(realm);
48      WEB_SET_PROTOTYPE_FOR_INTERFACE(ANGLEInstancedArrays);
49  }
50  
51  }
</document_content>
</document>
<document index="40">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLQuery.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #include <LibJS/Runtime/Realm.h>
 8  #include <LibWeb/Bindings/Intrinsics.h>
 9  #include <LibWeb/Bindings/WebGLQueryPrototype.h>
10  #include <LibWeb/WebGL/WebGLQuery.h>
11  
12  namespace Web::WebGL {
13  
14  GC_DEFINE_ALLOCATOR(WebGLQuery);
15  
16  GC::Ref<WebGLQuery> WebGLQuery::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
17  {
18      return realm.create<WebGLQuery>(realm, context, handle);
19  }
20  
21  WebGLQuery::WebGLQuery(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
22      : WebGLObject(realm, context, handle)
23  {
24  }
25  
26  WebGLQuery::~WebGLQuery() = default;
27  
28  void WebGLQuery::initialize(JS::Realm& realm)
29  {
30      Base::initialize(realm);
31      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLQuery);
32  }
33  
34  }
</document_content>
</document>
<document index="41">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLProgram.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #pragma once
10  
11  #include <LibWeb/WebGL/Types.h>
12  #include <LibWeb/WebGL/WebGLObject.h>
13  
14  namespace Web::WebGL {
15  
16  class WebGLProgram final : public WebGLObject {
17      WEB_PLATFORM_OBJECT(WebGLProgram, WebGLObject);
18      GC_DECLARE_ALLOCATOR(WebGLProgram);
19  
20  public:
21      static GC::Ref<WebGLProgram> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
22  
23      virtual ~WebGLProgram();
24  
25  protected:
26      explicit WebGLProgram(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
27  
28      virtual void initialize(JS::Realm&) override;
29  };
30  
31  }
</document_content>
</document>
<document index="42">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLVertexArrayObject.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Andrew Kaster <andrew@ladybird.org>
 3   *
 4   * SPDX-License-Identifier: BSD-2-Clause
 5   */
 6  
 7  #pragma once
 8  
 9  #include <LibWeb/WebGL/Types.h>
10  #include <LibWeb/WebGL/WebGLObject.h>
11  
12  namespace Web::WebGL {
13  
14  class WebGLVertexArrayObject : public WebGLObject {
15      WEB_PLATFORM_OBJECT(WebGLVertexArrayObject, WebGLObject);
16      GC_DECLARE_ALLOCATOR(WebGLVertexArrayObject);
17  
18  public:
19      static GC::Ref<WebGLVertexArrayObject> create(JS::Realm& realm, WebGLRenderingContextBase&, GLuint handle);
20  
21      virtual ~WebGLVertexArrayObject() override;
22  
23  protected:
24      explicit WebGLVertexArrayObject(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
25  
26      virtual void initialize(JS::Realm&) override;
27  };
28  
29  }
</document_content>
</document>
<document index="43">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLUniformLocation.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #include <LibJS/Runtime/Realm.h>
10  #include <LibWeb/Bindings/Intrinsics.h>
11  #include <LibWeb/Bindings/WebGLUniformLocationPrototype.h>
12  #include <LibWeb/WebGL/WebGLUniformLocation.h>
13  
14  namespace Web::WebGL {
15  
16  GC_DEFINE_ALLOCATOR(WebGLUniformLocation);
17  
18  GC::Ref<WebGLUniformLocation> WebGLUniformLocation::create(JS::Realm& realm, GLuint handle)
19  {
20      return realm.create<WebGLUniformLocation>(realm, handle);
21  }
22  
23  WebGLUniformLocation::WebGLUniformLocation(JS::Realm& realm, GLuint handle)
24      : Bindings::PlatformObject(realm)
25      , m_handle(handle)
26  {
27  }
28  
29  WebGLUniformLocation::~WebGLUniformLocation() = default;
30  
31  void WebGLUniformLocation::initialize(JS::Realm& realm)
32  {
33      Base::initialize(realm);
34      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLUniformLocation);
35  }
36  
37  }
</document_content>
</document>
<document index="44">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLContextEvent.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2022, Luke Wilde <lukew@serenityos.org>
 3   * Copyright (c) 2022, Andreas Kling <andreas@ladybird.org>
 4   *
 5   * SPDX-License-Identifier: BSD-2-Clause
 6   */
 7  
 8  #pragma once
 9  
10  #include <AK/FlyString.h>
11  #include <LibWeb/DOM/Event.h>
12  
13  namespace Web::WebGL {
14  
15  struct WebGLContextEventInit final : public DOM::EventInit {
16      String status_message;
17  };
18  
19  class WebGLContextEvent final : public DOM::Event {
20      WEB_PLATFORM_OBJECT(WebGLContextEvent, DOM::Event);
21      GC_DECLARE_ALLOCATOR(WebGLContextEvent);
22  
23  public:
24      [[nodiscard]] static GC::Ref<WebGLContextEvent> create(JS::Realm&, FlyString const& type, WebGLContextEventInit const&);
25      static WebIDL::ExceptionOr<GC::Ref<WebGLContextEvent>> construct_impl(JS::Realm&, FlyString const& type, WebGLContextEventInit const&);
26  
27      virtual ~WebGLContextEvent() override;
28  
29      String const& status_message() const { return m_status_message; }
30  
31  private:
32      WebGLContextEvent(JS::Realm&, FlyString const& type, WebGLContextEventInit const& event_init);
33  
34      virtual void initialize(JS::Realm&) override;
35  
36      String m_status_message;
37  };
38  
39  }
</document_content>
</document>
<document index="45">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLShader.cpp</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #include <LibJS/Runtime/Realm.h>
10  #include <LibWeb/Bindings/Intrinsics.h>
11  #include <LibWeb/Bindings/WebGLShaderPrototype.h>
12  #include <LibWeb/WebGL/WebGLShader.h>
13  
14  namespace Web::WebGL {
15  
16  GC_DEFINE_ALLOCATOR(WebGLShader);
17  
18  GC::Ref<WebGLShader> WebGLShader::create(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
19  {
20      return realm.create<WebGLShader>(realm, context, handle);
21  }
22  
23  WebGLShader::WebGLShader(JS::Realm& realm, WebGLRenderingContextBase& context, GLuint handle)
24      : WebGLObject(realm, context, handle)
25  {
26  }
27  
28  WebGLShader::~WebGLShader() = default;
29  
30  void WebGLShader::initialize(JS::Realm& realm)
31  {
32      Base::initialize(realm);
33      WEB_SET_PROTOTYPE_FOR_INTERFACE(WebGLShader);
34  }
35  
36  }
</document_content>
</document>
<document index="46">
<source>./Ladybird/Libraries/LibWeb/WebGL/WebGLObject.h</source>
<document_content>
 1  /*
 2   * Copyright (c) 2024, Jelle Raaijmakers <jelle@ladybird.org>
 3   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
 4   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
 5   *
 6   * SPDX-License-Identifier: BSD-2-Clause
 7   */
 8  
 9  #pragma once
10  
11  #include <LibWeb/Bindings/PlatformObject.h>
12  #include <LibWeb/WebGL/Types.h>
13  #include <LibWeb/WebGL/WebGLRenderingContextBase.h>
14  
15  namespace Web::WebGL {
16  
17  class WebGLObject : public Bindings::PlatformObject {
18      WEB_PLATFORM_OBJECT(WebGLObject, Bindings::PlatformObject);
19  
20  public:
21      virtual ~WebGLObject();
22  
23      String label() const { return m_label; }
24      void set_label(String const& label) { m_label = label; }
25  
26      ErrorOr<GLuint> handle(WebGLRenderingContextBase const* context) const;
27  
28  protected:
29      explicit WebGLObject(JS::Realm&, WebGLRenderingContextBase&, GLuint handle);
30  
31      void initialize(JS::Realm&) override;
32      void visit_edges(Visitor&) override;
33  
34      bool invalidated() const { return m_invalidated; }
35  
36  private:
37      // FIXME: It should be GC::Ptr instead of raw pointer, but we need to make WebGLRenderingContextBase inherit from PlatformObject first.
38      WebGLRenderingContextBase* m_context;
39      GLuint m_handle { 0 };
40  
41      bool m_invalidated { false };
42      String m_label;
43  };
44  
45  }
</document_content>
</document>
<document index="47">
<source>./Ladybird/Meta/Lagom/Tools/CodeGenerators/LibWeb/GenerateWebGLRenderingContext.cpp</source>
<document_content>
   1  /*
   2   * Copyright (c) 2024, Aliaksandr Kalenik <kalenik.aliaksandr@gmail.com>
   3   * Copyright (c) 2024, Luke Wilde <luke@ladybird.org>
   4   *
   5   * SPDX-License-Identifier: BSD-2-Clause
   6   */
   7  
   8  #include "BindingsGenerator/IDLGenerators.h"
   9  
  10  #include <AK/LexicalPath.h>
  11  #include <AK/SourceGenerator.h>
  12  #include <AK/StringBuilder.h>
  13  #include <LibCore/ArgsParser.h>
  14  #include <LibCore/File.h>
  15  #include <LibIDL/IDLParser.h>
  16  #include <LibMain/Main.h>
  17  
  18  static bool is_webgl_object_type(StringView type_name)
  19  {
  20      return type_name == "WebGLBuffer"sv
  21          || type_name == "WebGLFramebuffer"sv
  22          || type_name == "WebGLProgram"sv
  23          || type_name == "WebGLRenderbuffer"sv
  24          || type_name == "WebGLSampler"sv
  25          || type_name == "WebGLShader"sv
  26          || type_name == "WebGLTexture"sv
  27          || type_name == "WebGLVertexArrayObject"sv;
  28  }
  29  
  30  static bool gl_function_modifies_framebuffer(StringView function_name)
  31  {
  32      return function_name == "clearColor"sv || function_name == "drawArrays"sv || function_name == "drawElements"sv;
  33  }
  34  
  35  static ByteString to_cpp_type(const IDL::Type& type, const IDL::Interface& interface)
  36  {
  37      if (type.name() == "undefined"sv)
  38          return "void"sv;
  39      if (type.name() == "object"sv) {
  40          if (type.is_nullable())
  41              return "JS::Object*"sv;
  42          return "JS::Object&"sv;
  43      }
  44      if (type.name() == "DOMString"sv) {
  45          if (type.is_nullable())
  46              return "Optional<String>"sv;
  47          return "String"sv;
  48      }
  49      auto cpp_type = idl_type_name_to_cpp_type(type, interface);
  50      return cpp_type.name;
  51  }
  52  
  53  static ByteString idl_to_gl_function_name(StringView function_name)
  54  {
  55      StringBuilder gl_function_name_builder;
  56      gl_function_name_builder.append("gl"sv);
  57      for (size_t i = 0; i < function_name.length(); ++i) {
  58          if (i == 0) {
  59              gl_function_name_builder.append(to_ascii_uppercase(function_name[i]));
  60          } else {
  61              gl_function_name_builder.append(function_name[i]);
  62          }
  63      }
  64      if (function_name == "clearDepth"sv || function_name == "depthRange"sv) {
  65          gl_function_name_builder.append("f"sv);
  66      }
  67      return gl_function_name_builder.to_byte_string();
  68  }
  69  
  70  struct NameAndType {
  71      StringView name;
  72      struct {
  73          StringView type;
  74          int element_count { 0 };
  75      } return_type;
  76      Optional<int> webgl_version { OptionalNone {} };
  77  };
  78  
  79  static void generate_get_parameter(SourceGenerator& generator, int webgl_version)
  80  {
  81      Vector<NameAndType> const name_to_type = {
  82          { "ACTIVE_TEXTURE"sv, { "GLenum"sv } },
  83          { "ALIASED_LINE_WIDTH_RANGE"sv, { "Float32Array"sv, 2 } },
  84          { "ALIASED_POINT_SIZE_RANGE"sv, { "Float32Array"sv, 2 } },
  85          { "ALPHA_BITS"sv, { "GLint"sv } },
  86          { "ARRAY_BUFFER_BINDING"sv, { "WebGLBuffer"sv } },
  87          { "BLEND"sv, { "GLboolean"sv } },
  88          { "BLEND_COLOR"sv, { "Float32Array"sv, 4 } },
  89          { "BLEND_DST_ALPHA"sv, { "GLenum"sv } },
  90          { "BLEND_DST_RGB"sv, { "GLenum"sv } },
  91          { "BLEND_EQUATION_ALPHA"sv, { "GLenum"sv } },
  92          { "BLEND_EQUATION_RGB"sv, { "GLenum"sv } },
  93          { "BLEND_SRC_ALPHA"sv, { "GLenum"sv } },
  94          { "BLEND_SRC_RGB"sv, { "GLenum"sv } },
  95          { "BLUE_BITS"sv, { "GLint"sv } },
  96          { "COLOR_CLEAR_VALUE"sv, { "Float32Array"sv, 4 } },
  97          // FIXME: { "COLOR_WRITEMASK"sv, { "sequence<GLboolean>"sv, 4 } },
  98          // FIXME: { "COMPRESSED_TEXTURE_FORMATS"sv, { "Uint32Array"sv } },
  99          { "CULL_FACE"sv, { "GLboolean"sv } },
 100          { "CULL_FACE_MODE"sv, { "GLenum"sv } },
 101          { "CURRENT_PROGRAM"sv, { "WebGLProgram"sv } },
 102          { "DEPTH_BITS"sv, { "GLint"sv } },
 103          { "DEPTH_CLEAR_VALUE"sv, { "GLfloat"sv } },
 104          { "DEPTH_FUNC"sv, { "GLenum"sv } },
 105          { "DEPTH_RANGE"sv, { "Float32Array"sv, 2 } },
 106          { "DEPTH_TEST"sv, { "GLboolean"sv } },
 107          { "DEPTH_WRITEMASK"sv, { "GLboolean"sv } },
 108          { "DITHER"sv, { "GLboolean"sv } },
 109          { "ELEMENT_ARRAY_BUFFER_BINDING"sv, { "WebGLBuffer"sv } },
 110          { "FRAMEBUFFER_BINDING"sv, { "WebGLFramebuffer"sv } },
 111          { "FRONT_FACE"sv, { "GLenum"sv } },
 112          { "GENERATE_MIPMAP_HINT"sv, { "GLenum"sv } },
 113          { "GREEN_BITS"sv, { "GLint"sv } },
 114          { "IMPLEMENTATION_COLOR_READ_FORMAT"sv, { "GLenum"sv } },
 115          { "IMPLEMENTATION_COLOR_READ_TYPE"sv, { "GLenum"sv } },
 116          { "LINE_WIDTH"sv, { "GLfloat"sv } },
 117          { "MAX_COMBINED_TEXTURE_IMAGE_UNITS"sv, { "GLint"sv } },
 118          { "MAX_CUBE_MAP_TEXTURE_SIZE"sv, { "GLint"sv } },
 119          { "MAX_FRAGMENT_UNIFORM_VECTORS"sv, { "GLint"sv } },
 120          { "MAX_RENDERBUFFER_SIZE"sv, { "GLint"sv } },
 121          { "MAX_TEXTURE_IMAGE_UNITS"sv, { "GLint"sv } },
 122          { "MAX_TEXTURE_SIZE"sv, { "GLint"sv } },
 123          { "MAX_VARYING_VECTORS"sv, { "GLint"sv } },
 124          { "MAX_VERTEX_ATTRIBS"sv, { "GLint"sv } },
 125          { "MAX_VERTEX_TEXTURE_IMAGE_UNITS"sv, { "GLint"sv } },
 126          { "MAX_VERTEX_UNIFORM_VECTORS"sv, { "GLint"sv } },
 127          { "MAX_VIEWPORT_DIMS"sv, { "Int32Array"sv, 2 } },
 128          { "PACK_ALIGNMENT"sv, { "GLint"sv } },
 129          { "POLYGON_OFFSET_FACTOR"sv, { "GLfloat"sv } },
 130          { "POLYGON_OFFSET_FILL"sv, { "GLboolean"sv } },
 131          { "POLYGON_OFFSET_UNITS"sv, { "GLfloat"sv } },
 132          { "RED_BITS"sv, { "GLint"sv } },
 133          { "RENDERBUFFER_BINDING"sv, { "WebGLRenderbuffer"sv } },
 134          { "RENDERER"sv, { "DOMString"sv } },
 135          { "SAMPLE_ALPHA_TO_COVERAGE"sv, { "GLboolean"sv } },
 136          { "SAMPLE_BUFFERS"sv, { "GLint"sv } },
 137          { "SAMPLE_COVERAGE"sv, { "GLboolean"sv } },
 138          { "SAMPLE_COVERAGE_INVERT"sv, { "GLboolean"sv } },
 139          { "SAMPLE_COVERAGE_VALUE"sv, { "GLfloat"sv } },
 140          { "SAMPLES"sv, { "GLint"sv } },
 141          { "SCISSOR_BOX"sv, { "Int32Array"sv, 4 } },
 142          { "SCISSOR_TEST"sv, { "GLboolean"sv } },
 143          { "SHADING_LANGUAGE_VERSION"sv, { "DOMString"sv } },
 144          { "STENCIL_BACK_FAIL"sv, { "GLenum"sv } },
 145          { "STENCIL_BACK_FUNC"sv, { "GLenum"sv } },
 146          { "STENCIL_BACK_PASS_DEPTH_FAIL"sv, { "GLenum"sv } },
 147          { "STENCIL_BACK_PASS_DEPTH_PASS"sv, { "GLenum"sv } },
 148          { "STENCIL_BACK_REF"sv, { "GLint"sv } },
 149          { "STENCIL_BACK_VALUE_MASK"sv, { "GLuint"sv } },
 150          { "STENCIL_BACK_WRITEMASK"sv, { "GLuint"sv } },
 151          { "STENCIL_BITS"sv, { "GLint"sv } },
 152          { "STENCIL_CLEAR_VALUE"sv, { "GLint"sv } },
 153          { "STENCIL_FAIL"sv, { "GLenum"sv } },
 154          { "STENCIL_FUNC"sv, { "GLenum"sv } },
 155          { "STENCIL_PASS_DEPTH_FAIL"sv, { "GLenum"sv } },
 156          { "STENCIL_PASS_DEPTH_PASS"sv, { "GLenum"sv } },
 157          { "STENCIL_REF"sv, { "GLint"sv } },
 158          { "STENCIL_TEST"sv, { "GLboolean"sv } },
 159          { "STENCIL_VALUE_MASK"sv, { "GLuint"sv } },
 160          { "STENCIL_WRITEMASK"sv, { "GLuint"sv } },
 161          { "SUBPIXEL_BITS"sv, { "GLint"sv } },
 162          { "TEXTURE_BINDING_2D"sv, { "WebGLTexture"sv } },
 163          { "TEXTURE_BINDING_CUBE_MAP"sv, { "WebGLTexture"sv } },
 164          { "UNPACK_ALIGNMENT"sv, { "GLint"sv } },
 165          // FIXME: { "UNPACK_COLORSPACE_CONVERSION_WEBGL"sv, { "GLenum"sv } },
 166          // FIXME: { "UNPACK_FLIP_Y_WEBGL"sv, { "GLboolean"sv } },
 167          // FIXME: { "UNPACK_PREMULTIPLY_ALPHA_WEBGL"sv, { "GLboolean"sv } },
 168          { "VENDOR"sv, { "DOMString"sv } },
 169          { "VERSION"sv, { "DOMString"sv } },
 170          { "VIEWPORT"sv, { "Int32Array"sv, 4 } },
 171          { "MAX_SAMPLES"sv, { "GLint"sv }, 2 },
 172          { "MAX_3D_TEXTURE_SIZE"sv, { "GLint"sv }, 2 },
 173          { "MAX_ARRAY_TEXTURE_LAYERS"sv, { "GLint"sv }, 2 },
 174          { "MAX_COLOR_ATTACHMENTS"sv, { "GLint"sv }, 2 },
 175          { "MAX_VERTEX_UNIFORM_COMPONENTS"sv, { "GLint"sv }, 2 },
 176          { "MAX_UNIFORM_BLOCK_SIZE"sv, { "GLint64"sv }, 2 },
 177          { "MAX_UNIFORM_BUFFER_BINDINGS"sv, { "GLint"sv }, 2 },
 178          { "UNIFORM_BUFFER_OFFSET_ALIGNMENT"sv, { "GLint"sv }, 2 },
 179          { "MAX_DRAW_BUFFERS"sv, { "GLint"sv }, 2 },
 180          { "MAX_VERTEX_UNIFORM_BLOCKS"sv, { "GLint"sv }, 2 },
 181          { "MAX_FRAGMENT_INPUT_COMPONENTS"sv, { "GLint"sv }, 2 },
 182          { "MAX_COMBINED_UNIFORM_BLOCKS"sv, { "GLint"sv }, 2 },
 183      };
 184  
 185      auto is_primitive_type = [](StringView type) {
 186          return type == "GLboolean"sv || type == "GLint"sv || type == "GLfloat"sv || type == "GLenum"sv || type == "GLuint"sv;
 187      };
 188  
 189      generator.append("    switch (pname) {");
 190      for (auto const& name_and_type : name_to_type) {
 191          if (name_and_type.webgl_version.has_value() && name_and_type.webgl_version.value() != webgl_version)
 192              continue;
 193  
 194          auto const& parameter_name = name_and_type.name;
 195          auto const& type_name = name_and_type.return_type.type;
 196  
 197          StringBuilder string_builder;
 198          SourceGenerator impl_generator { string_builder };
 199          impl_generator.set("parameter_name", parameter_name);
 200          impl_generator.set("type_name", type_name);
 201          impl_generator.append(R"~~~(
 202      case GL_@parameter_name@: {)~~~");
 203          if (is_primitive_type(type_name)) {
 204              impl_generator.append(R"~~~(
 205          GLint result;
 206          glGetIntegerv(GL_@parameter_name@, &result);
 207          return JS::Value(result);
 208  )~~~");
 209          } else if (type_name == "GLint64"sv) {
 210              impl_generator.append(R"~~~(
 211          GLint64 result;
 212          glGetInteger64v(GL_@parameter_name@, &result);
 213          return JS::Value(static_cast<double>(result));
 214  )~~~");
 215          } else if (type_name == "DOMString"sv) {
 216              impl_generator.append(R"~~~(
 217          auto result = reinterpret_cast<const char*>(glGetString(GL_@parameter_name@));
 218          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });)~~~");
 219          } else if (type_name == "Float32Array"sv || type_name == "Int32Array"sv) {
 220              auto element_count = name_and_type.return_type.element_count;
 221              impl_generator.set("element_count", MUST(String::formatted("{}", element_count)));
 222              if (type_name == "Int32Array"sv) {
 223                  impl_generator.set("gl_function_name", "glGetIntegerv"sv);
 224                  impl_generator.set("element_type", "GLint"sv);
 225              } else if (type_name == "Float32Array"sv) {
 226                  impl_generator.set("gl_function_name", "glGetFloatv"sv);
 227                  impl_generator.set("element_type", "GLfloat"sv);
 228              } else {
 229                  VERIFY_NOT_REACHED();
 230              }
 231              impl_generator.append(R"~~~(
 232          Array<@element_type@, @element_count@> result;
 233          @gl_function_name@(GL_@parameter_name@, result.data());
 234          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), @element_count@ * sizeof(@element_type@)));
 235          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
 236          return JS::@type_name@::create(m_realm, @element_count@, array_buffer);
 237  )~~~");
 238          } else if (type_name == "WebGLProgram"sv || type_name == "WebGLBuffer"sv || type_name == "WebGLTexture"sv || type_name == "WebGLFramebuffer"sv || type_name == "WebGLRenderbuffer"sv) {
 239              impl_generator.append(R"~~~(
 240          GLint result;
 241          glGetIntegerv(GL_@parameter_name@, &result);
 242          if (!result)
 243              return JS::js_null();
 244          return @type_name@::create(m_realm, *this, result);
 245  )~~~");
 246          } else {
 247              VERIFY_NOT_REACHED();
 248          }
 249  
 250          impl_generator.append("    }");
 251  
 252          generator.append(string_builder.string_view());
 253      }
 254  
 255      generator.appendln(R"~~~(
 256      default:
 257          dbgln("Unknown WebGL parameter name: {:x}", pname);
 258          set_error(GL_INVALID_ENUM);
 259          return JS::js_null();
 260      })~~~");
 261  }
 262  
 263  static void generate_get_buffer_parameter(SourceGenerator& generator)
 264  {
 265      Vector<NameAndType> const name_to_type = {
 266          { "BUFFER_SIZE"sv, { "GLint"sv } },
 267          { "BUFFER_USAGE"sv, { "GLenum"sv } },
 268      };
 269  
 270      generator.append("    switch (pname) {");
 271  
 272      for (auto const& name_and_type : name_to_type) {
 273          auto const& parameter_name = name_and_type.name;
 274          auto const& type_name = name_and_type.return_type.type;
 275  
 276          StringBuilder string_builder;
 277          SourceGenerator impl_generator { string_builder };
 278          impl_generator.set("parameter_name", parameter_name);
 279          impl_generator.set("type_name", type_name);
 280          impl_generator.append(R"~~~(
 281      case GL_@parameter_name@: {
 282          GLint result;
 283          glGetBufferParameteriv(target, GL_@parameter_name@, &result);
 284          return JS::Value(result);
 285      }
 286  )~~~");
 287  
 288          generator.append(string_builder.string_view());
 289      }
 290  
 291      generator.appendln(R"~~~(
 292      default:
 293          dbgln("Unknown WebGL buffer parameter name: {:x}", pname);
 294          set_error(GL_INVALID_ENUM);
 295          return JS::js_null();
 296      })~~~");
 297  }
 298  
 299  static void generate_get_internal_format_parameter(SourceGenerator& generator)
 300  {
 301      generator.append(R"~~~(
 302      switch (pname) {
 303      case GL_SAMPLES: {
 304          GLint num_sample_counts { 0 };
 305          glGetInternalformativ(target, internalformat, GL_NUM_SAMPLE_COUNTS, 1, &num_sample_counts);
 306          auto samples_buffer = MUST(ByteBuffer::create_zeroed(num_sample_counts * sizeof(GLint)));
 307          glGetInternalformativ(target, internalformat, GL_SAMPLES, num_sample_counts, reinterpret_cast<GLint*>(samples_buffer.data()));
 308          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(samples_buffer));
 309          return JS::Int32Array::create(m_realm, num_sample_counts, array_buffer);
 310      }
 311      default:
 312          dbgln("Unknown WebGL internal format parameter name: {:x}", pname);
 313          set_error(GL_INVALID_ENUM);
 314          return JS::js_null();
 315      }
 316  )~~~");
 317  }
 318  
 319  static void generate_webgl_object_handle_unwrap(SourceGenerator& generator, StringView object_name, StringView early_return_value)
 320  {
 321      StringBuilder string_builder;
 322      SourceGenerator unwrap_generator { string_builder };
 323      unwrap_generator.set("object_name", object_name);
 324      unwrap_generator.set("early_return_value", early_return_value);
 325      unwrap_generator.append(R"~~~(
 326      GLuint @object_name@_handle = 0;
 327      if (@object_name@) {
 328          auto handle_or_error = @object_name@->handle(this);
 329          if (handle_or_error.is_error()) {
 330              set_error(GL_INVALID_OPERATION);
 331              return @early_return_value@;
 332          }
 333          @object_name@_handle = handle_or_error.release_value();
 334      }
 335  )~~~");
 336  
 337      generator.append(unwrap_generator.as_string_view());
 338  }
 339  
 340  ErrorOr<int> serenity_main(Main::Arguments arguments)
 341  {
 342      StringView generated_header_path;
 343      StringView generated_implementation_path;
 344      Vector<ByteString> base_paths;
 345      StringView webgl_context_idl_path;
 346  
 347      Core::ArgsParser args_parser;
 348      args_parser.add_option(webgl_context_idl_path, "Path to the WebGLRenderingContext idl file", "webgl-idl-path", 'i', "webgl-idl-path");
 349      args_parser.add_option(Core::ArgsParser::Option {
 350          .argument_mode = Core::ArgsParser::OptionArgumentMode::Required,
 351          .help_string = "Path to root of IDL file tree(s)",
 352          .long_name = "base-path",
 353          .short_name = 'b',
 354          .value_name = "base-path",
 355          .accept_value = [&](StringView s) {
 356              base_paths.append(s);
 357              return true;
 358          },
 359      });
 360      args_parser.add_option(generated_header_path, "Path to the header file to generate", "generated-header-path", 'h', "generated-header-path");
 361      args_parser.add_option(generated_implementation_path, "Path to the implementation file to generate", "generated-implementation-path", 'c', "generated-implementation-path");
 362      args_parser.parse(arguments);
 363  
 364      auto generated_header_file = TRY(Core::File::open(generated_header_path, Core::File::OpenMode::Write));
 365      auto generated_implementation_file = TRY(Core::File::open(generated_implementation_path, Core::File::OpenMode::Write));
 366  
 367      auto idl_file = MUST(Core::File::open(webgl_context_idl_path, Core::File::OpenMode::Read));
 368      auto webgl_context_idl_file_content = MUST(idl_file->read_until_eof());
 369  
 370      Vector<ByteString> import_base_paths;
 371      for (auto const& base_path : base_paths) {
 372          VERIFY(!base_path.is_empty());
 373          import_base_paths.append(base_path);
 374      }
 375  
 376      IDL::Parser parser(webgl_context_idl_path, StringView(webgl_context_idl_file_content), import_base_paths);
 377      auto const& interface = parser.parse();
 378  
 379      auto path = LexicalPath(generated_header_path);
 380      auto title = path.title();
 381      auto first_dot = title.find('.');
 382      ByteString class_name = title;
 383      if (first_dot.has_value())
 384          class_name = title.substring_view(0, *first_dot);
 385  
 386      StringBuilder header_file_string_builder;
 387      SourceGenerator header_file_generator { header_file_string_builder };
 388      header_file_generator.set("class_name", class_name);
 389  
 390      StringBuilder implementation_file_string_builder;
 391      SourceGenerator implementation_file_generator { implementation_file_string_builder };
 392      implementation_file_generator.set("class_name", class_name);
 393  
 394      auto webgl_version = class_name == "WebGLRenderingContextImpl" ? 1 : 2;
 395      if (webgl_version == 1) {
 396          implementation_file_generator.append(R"~~~(
 397  #include <GLES2/gl2.h>
 398  #include <GLES2/gl2ext.h>
 399  )~~~");
 400      } else {
 401          implementation_file_generator.append(R"~~~(
 402  #include <GLES3/gl3.h>
 403  )~~~");
 404      }
 405  
 406      implementation_file_generator.append(R"~~~(
 407  #include <LibJS/Runtime/ArrayBuffer.h>
 408  #include <LibJS/Runtime/DataView.h>
 409  #include <LibJS/Runtime/TypedArray.h>
 410  #include <LibWeb/HTML/HTMLCanvasElement.h>
 411  #include <LibWeb/HTML/HTMLImageElement.h>
 412  #include <LibWeb/HTML/HTMLVideoElement.h>
 413  #include <LibWeb/HTML/ImageBitmap.h>
 414  #include <LibWeb/HTML/ImageData.h>
 415  #include <LibWeb/WebGL/OpenGLContext.h>
 416  #include <LibWeb/WebGL/WebGLActiveInfo.h>
 417  #include <LibWeb/WebGL/WebGLBuffer.h>
 418  #include <LibWeb/WebGL/WebGLFramebuffer.h>
 419  #include <LibWeb/WebGL/WebGLProgram.h>
 420  #include <LibWeb/WebGL/WebGLRenderbuffer.h>
 421  #include <LibWeb/WebGL/@class_name@.h>
 422  #include <LibWeb/WebGL/WebGLSampler.h>
 423  #include <LibWeb/WebGL/WebGLShader.h>
 424  #include <LibWeb/WebGL/WebGLSync.h>
 425  #include <LibWeb/WebGL/WebGLShaderPrecisionFormat.h>
 426  #include <LibWeb/WebGL/WebGLTexture.h>
 427  #include <LibWeb/WebGL/WebGLUniformLocation.h>
 428  #include <LibWeb/WebGL/WebGLVertexArrayObject.h>
 429  #include <LibWeb/WebIDL/Buffers.h>
 430  
 431  namespace Web::WebGL {
 432  
 433  static Vector<GLchar> null_terminated_string(StringView string)
 434  {
 435      Vector<GLchar> result;
 436      for (auto c : string.bytes())
 437          result.append(c);
 438      result.append('\\0');
 439      return result;
 440  }
 441  
 442  @class_name@::@class_name@(JS::Realm& realm, NonnullOwnPtr<OpenGLContext> context)
 443      : m_realm(realm)
 444      , m_context(move(context))
 445  {
 446  }
 447  
 448  )~~~");
 449  
 450      header_file_generator.append(R"~~~(
 451  #pragma once
 452  
 453  #include <AK/NonnullOwnPtr.h>
 454  #include <LibGC/Ptr.h>
 455  #include <LibGfx/Bitmap.h>
 456  #include <LibWeb/Bindings/PlatformObject.h>
 457  #include <LibWeb/Forward.h>
 458  #include <LibWeb/WebGL/WebGLRenderingContextBase.h>
 459  #include <LibWeb/WebIDL/Types.h>
 460  
 461  namespace Web::WebGL {
 462  
 463  using namespace Web::HTML;
 464  
 465  class @class_name@ : public WebGLRenderingContextBase {
 466  public:
 467      @class_name@(JS::Realm&, NonnullOwnPtr<OpenGLContext>);
 468  
 469      OpenGLContext& context() { return *m_context; }
 470  
 471      virtual void present() = 0;
 472      virtual void needs_to_present() = 0;
 473      virtual void set_error(GLenum) = 0;
 474  )~~~");
 475  
 476      for (auto const& function : interface.functions) {
 477          if (function.extended_attributes.contains("FIXME")) {
 478              continue;
 479          }
 480  
 481          if (function.name == "getSupportedExtensions"sv || function.name == "getExtension"sv || function.name == "getContextAttributes"sv || function.name == "isContextLost"sv) {
 482              // Implemented in WebGLRenderingContext
 483              continue;
 484          }
 485  
 486          StringBuilder function_declaration;
 487  
 488          StringBuilder function_parameters;
 489          for (size_t i = 0; i < function.parameters.size(); ++i) {
 490              auto const& parameter = function.parameters[i];
 491              function_parameters.append(to_cpp_type(*parameter.type, interface));
 492              function_parameters.append(" "sv);
 493              function_parameters.append(parameter.name.to_snakecase());
 494              if (i != function.parameters.size() - 1) {
 495                  function_parameters.append(", "sv);
 496              }
 497          }
 498  
 499          auto function_name = function.name.to_snakecase();
 500          function_declaration.append(to_cpp_type(*function.return_type, interface));
 501          function_declaration.append(" "sv);
 502          function_declaration.append(function_name);
 503          function_declaration.append("("sv);
 504  
 505          function_declaration.append(function_parameters.string_view());
 506          function_declaration.append(");"sv);
 507  
 508          header_file_generator.append("    "sv);
 509          header_file_generator.append(function_declaration.string_view());
 510          header_file_generator.append("\n"sv);
 511  
 512          StringBuilder function_impl;
 513          SourceGenerator function_impl_generator { function_impl };
 514          function_impl_generator.set("class_name", class_name);
 515  
 516          ScopeGuard function_guard { [&] {
 517              function_impl_generator.append("}\n"sv);
 518              implementation_file_generator.append(function_impl_generator.as_string_view().bytes());
 519          } };
 520  
 521          function_impl_generator.set("function_name", function_name);
 522          function_impl_generator.set("function_parameters", function_parameters.string_view());
 523          function_impl_generator.set("function_return_type", to_cpp_type(*function.return_type, interface));
 524          function_impl_generator.append(R"~~~(
 525  @function_return_type@ @class_name@::@function_name@(@function_parameters@)
 526  {
 527      m_context->make_current();
 528  )~~~");
 529  
 530          if (gl_function_modifies_framebuffer(function.name)) {
 531              function_impl_generator.append("    m_context->notify_content_will_change();\n"sv);
 532          }
 533  
 534          if (function.name == "getUniformLocation"sv) {
 535              generate_webgl_object_handle_unwrap(function_impl_generator, "program"sv, "{}"sv);
 536              function_impl_generator.append(R"~~~(
 537      auto name_null_terminated = null_terminated_string(name);
 538      return WebGLUniformLocation::create(m_realm, glGetUniformLocation(program_handle, name_null_terminated.data()));
 539  )~~~");
 540              continue;
 541          }
 542  
 543          if (function.name == "createBuffer"sv) {
 544              function_impl_generator.append(R"~~~(
 545      GLuint handle = 0;
 546      glGenBuffers(1, &handle);
 547      return WebGLBuffer::create(m_realm, *this, handle);
 548  )~~~");
 549              continue;
 550          }
 551  
 552          if (function.name == "createTexture"sv) {
 553              function_impl_generator.append(R"~~~(
 554      GLuint handle = 0;
 555      glGenTextures(1, &handle);
 556      return WebGLTexture::create(m_realm, *this, handle);
 557  )~~~");
 558              continue;
 559          }
 560  
 561          if (function.name == "createFramebuffer"sv) {
 562              function_impl_generator.append(R"~~~(
 563      GLuint handle = 0;
 564      glGenFramebuffers(1, &handle);
 565      return WebGLFramebuffer::create(m_realm, *this, handle);
 566  )~~~");
 567              continue;
 568          }
 569  
 570          if (function.name == "createRenderbuffer"sv) {
 571              function_impl_generator.append(R"~~~(
 572      GLuint handle = 0;
 573      glGenRenderbuffers(1, &handle);
 574      return WebGLRenderbuffer::create(m_realm, *this, handle);
 575  )~~~");
 576              continue;
 577          }
 578  
 579          if (function.name == "createVertexArray"sv) {
 580              function_impl_generator.append(R"~~~(
 581      GLuint handle = 0;
 582      glGenVertexArrays(1, &handle);
 583      return WebGLVertexArrayObject::create(m_realm, *this, handle);
 584  )~~~");
 585              continue;
 586          }
 587  
 588          if (function.name == "createSampler"sv) {
 589              function_impl_generator.append(R"~~~(
 590      GLuint handle = 0;
 591      glGenSamplers(1, &handle);
 592      return WebGLSampler::create(m_realm, *this, handle);
 593  )~~~");
 594              continue;
 595          }
 596  
 597          if (function.name == "fenceSync"sv) {
 598              function_impl_generator.append(R"~~~(
 599      GLsync handle = glFenceSync(condition, flags);
 600      return WebGLSync::create(m_realm, *this, handle);
 601  )~~~");
 602              continue;
 603          }
 604  
 605          if (function.name == "shaderSource"sv) {
 606              generate_webgl_object_handle_unwrap(function_impl_generator, "shader"sv, ""sv);
 607              function_impl_generator.append(R"~~~(
 608      Vector<GLchar*> strings;
 609      auto string = null_terminated_string(source);
 610      strings.append(string.data());
 611      Vector<GLint> length;
 612      length.append(source.bytes().size());
 613      glShaderSource(shader_handle, 1, strings.data(), length.data());
 614  )~~~");
 615              continue;
 616          }
 617  
 618          if (function.name == "vertexAttribPointer"sv) {
 619              function_impl_generator.append(R"~~~(
 620      glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast<void*>(offset));
 621  )~~~");
 622              continue;
 623          }
 624  
 625          if (function.name == "texStorage2D") {
 626              function_impl_generator.append(R"~~~(
 627      glTexStorage2D(target, levels, internalformat, width, height);
 628  )~~~");
 629              continue;
 630          }
 631  
 632          if (function.name == "texImage2D"sv && function.overload_index == 0) {
 633              function_impl_generator.append(R"~~~(
 634      void const* pixels_ptr = nullptr;
 635      if (pixels) {
 636          auto const& viewed_array_buffer = pixels->viewed_array_buffer();
 637          auto const& byte_buffer = viewed_array_buffer->buffer();
 638          pixels_ptr = byte_buffer.data();
 639      }
 640      glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
 641  )~~~");
 642              continue;
 643          }
 644  
 645          if (function.name == "texImage3D"sv && function.overload_index == 0) {
 646              // FIXME: If a WebGLBuffer is bound to the PIXEL_UNPACK_BUFFER target, generates an INVALID_OPERATION error.
 647              // FIXME: If srcData is null, a buffer of sufficient size initialized to 0 is passed.
 648              // FIXME: If type is specified as FLOAT_32_UNSIGNED_INT_24_8_REV, srcData must be null; otherwise, generates an INVALID_OPERATION error.
 649              // FIXME: If srcData is non-null, the type of srcData must match the type according to the above table; otherwise, generate an INVALID_OPERATION error.
 650              // FIXME: If an attempt is made to call this function with no WebGLTexture bound (see above), generates an INVALID_OPERATION error.
 651              // FIXME: If there's not enough data in srcData starting at srcOffset, generate INVALID_OPERATION.
 652              function_impl_generator.append(R"~~~(
 653      void const* src_data_ptr = nullptr;
 654      if (src_data) {
 655          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 656          auto const& byte_buffer = viewed_array_buffer->buffer();
 657          src_data_ptr = byte_buffer.data();
 658      }
 659      glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, src_data_ptr);
 660  )~~~");
 661              continue;
 662          }
 663  
 664          if (function.name == "texImage3D"sv && function.overload_index == 1) {
 665              // FIXME: If a WebGLBuffer is bound to the PIXEL_UNPACK_BUFFER target, generates an INVALID_OPERATION error.
 666              // FIXME: If srcData is null, a buffer of sufficient size initialized to 0 is passed.
 667              // FIXME: If type is specified as FLOAT_32_UNSIGNED_INT_24_8_REV, srcData must be null; otherwise, generates an INVALID_OPERATION error.
 668              // FIXME: If srcData is non-null, the type of srcData must match the type according to the above table; otherwise, generate an INVALID_OPERATION error.
 669              // FIXME: If an attempt is made to call this function with no WebGLTexture bound (see above), generates an INVALID_OPERATION error.
 670              // FIXME: If there's not enough data in srcData starting at srcOffset, generate INVALID_OPERATION.
 671              function_impl_generator.append(R"~~~(
 672      void const* src_data_ptr = nullptr;
 673      if (src_data) {
 674          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 675          auto const& byte_buffer = viewed_array_buffer->buffer();
 676          src_data_ptr = byte_buffer.data() + src_offset;
 677      }
 678      glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, src_data_ptr);
 679  )~~~");
 680              continue;
 681          }
 682  
 683          if (function.name == "texImage2D"sv && function.overload_index == 1) {
 684              // FIXME: If this function is called with an ImageData whose data attribute has been neutered,
 685              //        an INVALID_VALUE error is generated.
 686              // FIXME: If this function is called with an ImageBitmap that has been neutered, an INVALID_VALUE
 687              //        error is generated.
 688              // FIXME: If this function is called with an HTMLImageElement or HTMLVideoElement whose origin
 689              //        differs from the origin of the containing Document, or with an HTMLCanvasElement,
 690              //        ImageBitmap or OffscreenCanvas whose bitmap's origin-clean flag is set to false,
 691              //        a SECURITY_ERR exception must be thrown. See Origin Restrictions.
 692              // FIXME: If source is null then an INVALID_VALUE error is generated.
 693              function_impl_generator.append(R"~~~(
 694      auto bitmap = source.visit(
 695          [](GC::Root<HTMLImageElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 696              return source->immutable_bitmap();
 697          },
 698          [](GC::Root<HTMLCanvasElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 699              auto surface = source->surface();
 700              if (!surface)
 701                  return {};
 702              auto bitmap = MUST(Gfx::Bitmap::create(Gfx::BitmapFormat::RGBA8888, Gfx::AlphaType::Premultiplied, surface->size()));
 703              surface->read_into_bitmap(*bitmap);
 704              return Gfx::ImmutableBitmap::create(*bitmap);
 705          },
 706          [](GC::Root<HTMLVideoElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 707              return Gfx::ImmutableBitmap::create(*source->bitmap());
 708          },
 709          [](GC::Root<ImageBitmap> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 710              return Gfx::ImmutableBitmap::create(*source->bitmap());
 711          },
 712          [](GC::Root<ImageData> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 713              return Gfx::ImmutableBitmap::create(source->bitmap());
 714          });
 715      if (!bitmap)
 716          return;
 717  
 718      void const* pixels_ptr = bitmap->bitmap()->begin();
 719      int width = bitmap->width();
 720      int height = bitmap->height();
 721      glTexImage2D(target, level, internalformat, width, height, 0, format, type, pixels_ptr);
 722  )~~~");
 723              continue;
 724          }
 725  
 726          if (webgl_version == 2 && function.name == "texImage2D"sv && function.overload_index == 2) {
 727              function_impl_generator.append(R"~~~(
 728      void const* pixels_ptr = nullptr;
 729      if (src_data) {
 730          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 731          auto const& byte_buffer = viewed_array_buffer->buffer();
 732          pixels_ptr = byte_buffer.data() + src_offset;
 733      }
 734      glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
 735  )~~~");
 736              continue;
 737          }
 738  
 739          if (function.name == "texSubImage2D"sv && function.overload_index == 0) {
 740              function_impl_generator.append(R"~~~(
 741      void const* pixels_ptr = nullptr;
 742      if (pixels) {
 743          auto const& viewed_array_buffer = pixels->viewed_array_buffer();
 744          auto const& byte_buffer = viewed_array_buffer->buffer();
 745          pixels_ptr = byte_buffer.data();
 746      }
 747      glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
 748  )~~~");
 749              continue;
 750          }
 751  
 752          if (webgl_version == 2 && function.name == "texSubImage2D"sv && function.overload_index == 1) {
 753              function_impl_generator.append(R"~~~(
 754      void const* pixels_ptr = nullptr;
 755      if (src_data) {
 756          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 757          auto const& byte_buffer = viewed_array_buffer->buffer();
 758          pixels_ptr = byte_buffer.data() + src_offset;
 759      }
 760      glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
 761  )~~~");
 762              continue;
 763          }
 764  
 765          if (function.name == "texSubImage3D"sv && function.overload_index == 0) {
 766              function_impl_generator.append(R"~~~(
 767      void const* pixels_ptr = nullptr;
 768      if (src_data) {
 769          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 770          auto const& byte_buffer = viewed_array_buffer->buffer();
 771          pixels_ptr = byte_buffer.data() + src_offset;
 772      }
 773      glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
 774  )~~~");
 775              continue;
 776          }
 777  
 778          if (function.name == "getShaderParameter"sv) {
 779              generate_webgl_object_handle_unwrap(function_impl_generator, "shader"sv, "JS::js_null()"sv);
 780              function_impl_generator.append(R"~~~(
 781      GLint result = 0;
 782      glGetShaderiv(shader_handle, pname, &result);
 783      return JS::Value(result);
 784  )~~~");
 785              continue;
 786          }
 787  
 788          if (function.name == "getProgramParameter"sv) {
 789              generate_webgl_object_handle_unwrap(function_impl_generator, "program"sv, "JS::js_null()"sv);
 790              function_impl_generator.append(R"~~~(
 791      GLint result = 0;
 792      glGetProgramiv(program_handle, pname, &result);
 793      return JS::Value(result);
 794  )~~~");
 795              continue;
 796          }
 797  
 798          if (function.name == "bufferData"sv && function.overload_index == 0) {
 799              function_impl_generator.append(R"~~~(
 800      glBufferData(target, size, 0, usage);
 801  )~~~");
 802              continue;
 803          }
 804  
 805          if (function.name == "readPixels"sv) {
 806              function_impl_generator.append(R"~~~(
 807      if (!pixels) {
 808          return;
 809      }
 810  
 811      void *ptr = nullptr;
 812      if (pixels->is_data_view()) {
 813          auto& data_view = static_cast<JS::DataView&>(*pixels->raw_object());
 814          ptr = data_view.viewed_array_buffer()->buffer().data();
 815      } else if (pixels->is_typed_array_base()) {
 816          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*pixels->raw_object());
 817          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
 818      } else {
 819          VERIFY_NOT_REACHED();
 820      }
 821  
 822      glReadPixels(x, y, width, height, format, type, ptr);
 823  )~~~");
 824              continue;
 825          }
 826  
 827          if (function.name == "drawElements"sv) {
 828              function_impl_generator.append(R"~~~(
 829      glDrawElements(mode, count, type, reinterpret_cast<void*>(offset));
 830      needs_to_present();
 831  )~~~");
 832              continue;
 833          }
 834  
 835          if (function.name == "drawBuffers"sv) {
 836              function_impl_generator.append(R"~~~(
 837      glDrawBuffers(buffers.size(), buffers.data());
 838  )~~~");
 839              continue;
 840          }
 841  
 842          if (function.name.starts_with("uniformMatrix"sv)) {
 843              auto number_of_matrix_elements = function.name.substring_view(13, 1);
 844              function_impl_generator.set("number_of_matrix_elements", number_of_matrix_elements);
 845  
 846              if (webgl_version == 1) {
 847                  function_impl_generator.set("array_argument_name", "value");
 848              } else {
 849                  function_impl_generator.set("array_argument_name", "data");
 850              }
 851  
 852              function_impl_generator.append(R"~~~(
 853      auto matrix_size = @number_of_matrix_elements@ * @number_of_matrix_elements@;
 854      float const* raw_data = nullptr;
 855      u64 count = 0;
 856      if (@array_argument_name@.has<Vector<float>>()) {
 857          auto& vector_data = @array_argument_name@.get<Vector<float>>();
 858          raw_data = vector_data.data();
 859          count = vector_data.size() / matrix_size;
 860      } else {
 861          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*@array_argument_name@.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 862          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 863          raw_data = float32_array.data().data();
 864          count = float32_array.array_length().length() / matrix_size;
 865      }
 866  )~~~");
 867  
 868              if (webgl_version == 2) {
 869                  function_impl_generator.append(R"~~~(
 870      raw_data += src_offset;
 871      if (src_length == 0) {
 872          count -= src_offset;
 873      }
 874  
 875      if (src_offset + src_length <= count) {
 876          set_error(GL_INVALID_VALUE);
 877          return;
 878      }
 879  )~~~");
 880              }
 881  
 882              function_impl_generator.append(R"~~~(
 883      glUniformMatrix@number_of_matrix_elements@fv(location->handle(), count, transpose, raw_data);
 884  )~~~");
 885              continue;
 886          }
 887  
 888          if (function.name == "uniform1fv"sv || function.name == "uniform2fv"sv || function.name == "uniform3fv"sv || function.name == "uniform4fv"sv || function.name == "uniform1iv"sv || function.name == "uniform2iv"sv || function.name == "uniform3iv"sv || function.name == "uniform4iv"sv) {
 889              auto number_of_vector_elements = function.name.substring_view(7, 1);
 890              auto element_type = function.name.substring_view(8, 1);
 891              if (element_type == "f"sv) {
 892                  function_impl_generator.set("cpp_element_type", "float"sv);
 893                  function_impl_generator.set("typed_array_type", "Float32Array"sv);
 894                  function_impl_generator.set("gl_postfix", "f"sv);
 895              } else if (element_type == "i"sv) {
 896                  function_impl_generator.set("cpp_element_type", "int"sv);
 897                  function_impl_generator.set("typed_array_type", "Int32Array"sv);
 898                  function_impl_generator.set("gl_postfix", "i"sv);
 899              } else {
 900                  VERIFY_NOT_REACHED();
 901              }
 902              function_impl_generator.set("number_of_vector_elements", number_of_vector_elements);
 903              function_impl_generator.append(R"~~~(
 904      @cpp_element_type@ const* data = nullptr;
 905      size_t count = 0;
 906      if (v.has<Vector<@cpp_element_type@>>()) {
 907          auto& vector = v.get<Vector<@cpp_element_type@>>();
 908          data = vector.data();
 909          count = vector.size();
 910      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 911          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 912          auto& typed_array = verify_cast<JS::@typed_array_type@>(typed_array_base);
 913          data = typed_array.data().data();
 914          count = typed_array.array_length().length();
 915      } else {
 916          VERIFY_NOT_REACHED();
 917      }
 918  )~~~");
 919  
 920              if (webgl_version == 2) {
 921                  function_impl_generator.append(R"~~~(
 922      data += src_offset;
 923      if (src_length == 0) {
 924          count -= src_offset;
 925      }
 926  
 927      if (src_offset + src_length <= count) {
 928          set_error(GL_INVALID_VALUE);
 929          return;
 930      }
 931  )~~~");
 932              }
 933  
 934              function_impl_generator.append(R"~~~(
 935      glUniform@number_of_vector_elements@@gl_postfix@v(location->handle(), count / @number_of_vector_elements@, data);
 936  )~~~");
 937              continue;
 938          }
 939  
 940          if (function.name == "vertexAttrib1fv"sv || function.name == "vertexAttrib2fv"sv || function.name == "vertexAttrib3fv"sv || function.name == "vertexAttrib4fv"sv) {
 941              auto number_of_vector_elements = function.name.substring_view(12, 1);
 942              function_impl_generator.set("number_of_vector_elements", number_of_vector_elements);
 943              function_impl_generator.append(R"~~~(
 944      if (values.has<Vector<float>>()) {
 945          auto& data = values.get<Vector<float>>();
 946          glVertexAttrib@number_of_vector_elements@fv(index, data.data());
 947          return;
 948      }
 949  
 950      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 951      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 952      float const* data = float32_array.data().data();
 953      glVertexAttrib@number_of_vector_elements@fv(index, data);
 954  )~~~");
 955              continue;
 956          }
 957  
 958          if (function.name == "getParameter"sv) {
 959              generate_get_parameter(function_impl_generator, webgl_version);
 960              continue;
 961          }
 962  
 963          if (function.name == "getBufferParameter"sv) {
 964              generate_get_buffer_parameter(function_impl_generator);
 965              continue;
 966          }
 967  
 968          if (function.name == "getInternalformatParameter") {
 969              generate_get_internal_format_parameter(function_impl_generator);
 970              continue;
 971          }
 972  
 973          if (function.name == "getActiveUniform"sv) {
 974              generate_webgl_object_handle_unwrap(function_impl_generator, "program"sv, "{}"sv);
 975              function_impl_generator.append(R"~~~(
 976      GLint size = 0;
 977      GLenum type = 0;
 978      GLsizei buf_size = 256;
 979      GLsizei length = 0;
 980      GLchar name[256];
 981      glGetActiveUniform(program_handle, index, buf_size, &length, &size, &type, name);
 982      auto readonly_bytes = ReadonlyBytes { name, static_cast<size_t>(length) };
 983      return WebGLActiveInfo::create(m_realm, String::from_utf8_without_validation(readonly_bytes), type, size);
 984  )~~~");
 985              continue;
 986          }
 987  
 988          if (function.name == "getActiveAttrib"sv) {
 989              generate_webgl_object_handle_unwrap(function_impl_generator, "program"sv, "{}"sv);
 990              function_impl_generator.append(R"~~~(
 991      GLint size = 0;
 992      GLenum type = 0;
 993      GLsizei buf_size = 256;
 994      GLsizei length = 0;
 995      GLchar name[256];
 996      glGetActiveAttrib(program_handle, index, buf_size, &length, &size, &type, name);
 997      auto readonly_bytes = ReadonlyBytes { name, static_cast<size_t>(length) };
 998      return WebGLActiveInfo::create(m_realm, String::from_utf8_without_validation(readonly_bytes), type, size);
 999  )~~~");
1000              continue;
1001          }
1002  
1003          if (function.name == "getShaderInfoLog"sv) {
1004              generate_webgl_object_handle_unwrap(function_impl_generator, "shader"sv, "{}"sv);
1005              function_impl_generator.append(R"~~~(
1006      GLint info_log_length = 0;
1007      glGetShaderiv(shader_handle, GL_INFO_LOG_LENGTH, &info_log_length);
1008      Vector<GLchar> info_log;
1009      info_log.resize(info_log_length);
1010      if (!info_log_length)
1011          return String {};
1012      glGetShaderInfoLog(shader_handle, info_log_length, nullptr, info_log.data());
1013      return String::from_utf8_without_validation(ReadonlyBytes { info_log.data(), static_cast<size_t>(info_log_length - 1) });
1014  )~~~");
1015              continue;
1016          }
1017  
1018          if (function.name == "getProgramInfoLog"sv) {
1019              generate_webgl_object_handle_unwrap(function_impl_generator, "program"sv, "{}"sv);
1020              function_impl_generator.append(R"~~~(
1021      GLint info_log_length = 0;
1022      glGetProgramiv(program_handle, GL_INFO_LOG_LENGTH, &info_log_length);
1023      Vector<GLchar> info_log;
1024      info_log.resize(info_log_length);
1025      if (!info_log_length)
1026          return String {};
1027      glGetProgramInfoLog(program_handle, info_log_length, nullptr, info_log.data());
1028      return String::from_utf8_without_validation(ReadonlyBytes { info_log.data(), static_cast<size_t>(info_log_length - 1) });
1029  )~~~");
1030              continue;
1031          }
1032  
1033          if (function.name == "getShaderPrecisionFormat"sv) {
1034              function_impl_generator.append(R"~~~(
1035      GLint range[2];
1036      GLint precision;
1037      glGetShaderPrecisionFormat(shadertype, precisiontype, range, &precision);
1038      return WebGLShaderPrecisionFormat::create(m_realm, range[0], range[1], precision);
1039  )~~~");
1040              continue;
1041          }
1042  
1043          if (function.name == "deleteBuffer"sv) {
1044              generate_webgl_object_handle_unwrap(function_impl_generator, "buffer"sv, ""sv);
1045              function_impl_generator.append(R"~~~(
1046      glDeleteBuffers(1, &buffer_handle);
1047  )~~~");
1048              continue;
1049          }
1050  
1051          if (function.name == "deleteFramebuffer"sv) {
1052              generate_webgl_object_handle_unwrap(function_impl_generator, "framebuffer"sv, ""sv);
1053              function_impl_generator.append(R"~~~(
1054      glDeleteFramebuffers(1, &framebuffer_handle);
1055  )~~~");
1056              continue;
1057          }
1058  
1059          if (function.name == "deleteTexture"sv) {
1060              generate_webgl_object_handle_unwrap(function_impl_generator, "texture"sv, ""sv);
1061              function_impl_generator.append(R"~~~(
1062      glDeleteTextures(1, &texture_handle);
1063  )~~~");
1064              continue;
1065          }
1066  
1067          if (function.name == "deleteVertexArray"sv) {
1068              generate_webgl_object_handle_unwrap(function_impl_generator, "vertex_array"sv, ""sv);
1069              function_impl_generator.append(R"~~~(
1070      glDeleteVertexArrays(1, &vertex_array_handle);
1071  )~~~");
1072              continue;
1073          }
1074  
1075          Vector<ByteString> gl_call_arguments;
1076          for (size_t i = 0; i < function.parameters.size(); ++i) {
1077              auto const& parameter = function.parameters[i];
1078              auto parameter_name = parameter.name.to_snakecase();
1079              if (parameter.type->is_numeric() || parameter.type->is_boolean()) {
1080                  gl_call_arguments.append(parameter_name);
1081                  continue;
1082              }
1083              if (parameter.type->is_string()) {
1084                  function_impl_generator.set("parameter_name", parameter_name);
1085                  function_impl_generator.append(R"~~~(
1086      auto @parameter_name@_null_terminated = null_terminated_string(@parameter_name@);
1087  )~~~");
1088                  gl_call_arguments.append(ByteString::formatted("{}_null_terminated.data()", parameter_name));
1089                  continue;
1090              }
1091              if (is_webgl_object_type(parameter.type->name())) {
1092                  if (function.return_type->name() == "undefined"sv) {
1093                      function_impl_generator.set("early_return_value", "");
1094                  } else if (function.return_type->is_integer()) {
1095                      function_impl_generator.set("early_return_value", "-1");
1096                  } else if (function.return_type->is_boolean()) {
1097                      function_impl_generator.set("early_return_value", "false");
1098                  } else {
1099                      VERIFY_NOT_REACHED();
1100                  }
1101                  function_impl_generator.set("handle_parameter_name", parameter_name);
1102                  function_impl_generator.append(R"~~~(
1103      auto @handle_parameter_name@_handle = 0;
1104      if (@handle_parameter_name@) {
1105          auto handle_or_error = @handle_parameter_name@->handle(this);
1106          if (handle_or_error.is_error()) {
1107              set_error(GL_INVALID_OPERATION);
1108              return @early_return_value@;
1109          }
1110          @handle_parameter_name@_handle = handle_or_error.release_value();
1111      }
1112  )~~~");
1113                  gl_call_arguments.append(ByteString::formatted("{}_handle", parameter_name));
1114                  continue;
1115              }
1116              if (parameter.type->name() == "WebGLUniformLocation"sv) {
1117                  gl_call_arguments.append(ByteString::formatted("{} ? {}->handle() : 0", parameter_name, parameter_name));
1118                  continue;
1119              }
1120              if (parameter.type->name() == "WebGLSync"sv) {
1121                  // FIXME: Remove the GLsync cast once sync_handle actually returns the proper GLsync type.
1122                  gl_call_arguments.append(ByteString::formatted("(GLsync)({} ? {}->sync_handle() : nullptr)", parameter_name, parameter_name));
1123                  continue;
1124              }
1125              if (parameter.type->name() == "BufferSource"sv) {
1126                  function_impl_generator.set("buffer_source_name", parameter_name);
1127                  function_impl_generator.append(R"~~~(
1128      void const* ptr = nullptr;
1129      size_t byte_size = 0;
1130      if (@buffer_source_name@->is_typed_array_base()) {
1131          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*@buffer_source_name@->raw_object());
1132          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
1133          byte_size = typed_array_base.viewed_array_buffer()->byte_length();
1134      } else if (@buffer_source_name@->is_data_view()) {
1135          auto& data_view = static_cast<JS::DataView&>(*@buffer_source_name@->raw_object());
1136          ptr = data_view.viewed_array_buffer()->buffer().data();
1137          byte_size = data_view.viewed_array_buffer()->byte_length();
1138      } else if (@buffer_source_name@->is_array_buffer()) {
1139          auto& array_buffer = static_cast<JS::ArrayBuffer&>(*@buffer_source_name@->raw_object());
1140          ptr = array_buffer.buffer().data();
1141          byte_size = array_buffer.byte_length();
1142      } else {
1143          VERIFY_NOT_REACHED();
1144      }
1145  )~~~");
1146                  gl_call_arguments.append(ByteString::formatted("byte_size"));
1147                  gl_call_arguments.append(ByteString::formatted("ptr"));
1148                  continue;
1149              }
1150              VERIFY_NOT_REACHED();
1151          }
1152  
1153          StringBuilder gl_call_arguments_string_builder;
1154          gl_call_arguments_string_builder.join(", "sv, gl_call_arguments);
1155  
1156          auto gl_call_string = ByteString::formatted("{}({})", idl_to_gl_function_name(function.name), gl_call_arguments_string_builder.string_view());
1157          function_impl_generator.set("call_string", gl_call_string);
1158  
1159          if (gl_function_modifies_framebuffer(function.name)) {
1160              function_impl_generator.append("    needs_to_present();\n"sv);
1161          }
1162  
1163          if (function.return_type->name() == "undefined"sv) {
1164              function_impl_generator.append("    @call_string@;"sv);
1165          } else if (function.return_type->is_integer() || function.return_type->is_boolean()) {
1166              function_impl_generator.append("    return @call_string@;"sv);
1167          } else if (is_webgl_object_type(function.return_type->name())) {
1168              function_impl_generator.set("return_type_name", function.return_type->name());
1169              function_impl_generator.append("    return @return_type_name@::create(m_realm, *this, @call_string@);"sv);
1170          } else {
1171              VERIFY_NOT_REACHED();
1172          }
1173  
1174          function_impl_generator.append("\n"sv);
1175      }
1176  
1177      header_file_generator.append(R"~~~(
1178  private:
1179      GC::Ref<JS::Realm> m_realm;
1180      NonnullOwnPtr<OpenGLContext> m_context;
1181  };
1182  
1183  }
1184  )~~~");
1185  
1186      implementation_file_generator.append(R"~~~(
1187  }
1188  )~~~");
1189  
1190      MUST(generated_header_file->write_until_depleted(header_file_generator.as_string_view().bytes()));
1191      MUST(generated_implementation_file->write_until_depleted(implementation_file_generator.as_string_view().bytes()));
1192  
1193      return 0;
1194  }
</document_content>
</document>
<document index="48">
<source>./LadybirdBuild/WebGL2RenderingContextImpl.h</source>
<document_content>
  1  
  2  #pragma once
  3  
  4  #include <AK/NonnullOwnPtr.h>
  5  #include <LibGC/Ptr.h>
  6  #include <LibGfx/Bitmap.h>
  7  #include <LibWeb/Bindings/PlatformObject.h>
  8  #include <LibWeb/Forward.h>
  9  #include <LibWeb/WebGL/WebGLRenderingContextBase.h>
 10  #include <LibWeb/WebIDL/Types.h>
 11  
 12  namespace Web::WebGL {
 13  
 14  using namespace Web::HTML;
 15  
 16  class WebGL2RenderingContextImpl : public WebGLRenderingContextBase {
 17  public:
 18      WebGL2RenderingContextImpl(JS::Realm&, NonnullOwnPtr<OpenGLContext>);
 19  
 20      OpenGLContext& context() { return *m_context; }
 21  
 22      virtual void present() = 0;
 23      virtual void needs_to_present() = 0;
 24      virtual void set_error(GLenum) = 0;
 25      void blit_framebuffer(WebIDL::Long src_x0, WebIDL::Long src_y0, WebIDL::Long src_x1, WebIDL::Long src_y1, WebIDL::Long dst_x0, WebIDL::Long dst_y0, WebIDL::Long dst_x1, WebIDL::Long dst_y1, WebIDL::UnsignedLong mask, WebIDL::UnsignedLong filter);
 26      void read_buffer(WebIDL::UnsignedLong src);
 27      JS::Value get_internalformat_parameter(WebIDL::UnsignedLong target, WebIDL::UnsignedLong internalformat, WebIDL::UnsignedLong pname);
 28      void renderbuffer_storage_multisample(WebIDL::UnsignedLong target, WebIDL::Long samples, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height);
 29      void tex_storage2d(WebIDL::UnsignedLong target, WebIDL::Long levels, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height);
 30      void tex_storage3d(WebIDL::UnsignedLong target, WebIDL::Long levels, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth);
 31      void tex_image3d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data);
 32      void tex_image3d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset);
 33      void tex_sub_image3d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long zoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset);
 34      void draw_buffers(Vector<WebIDL::UnsignedLong> buffers);
 35      GC::Root<WebGLSampler> create_sampler();
 36      void bind_sampler(WebIDL::UnsignedLong unit, GC::Root<WebGLSampler> sampler);
 37      GC::Root<WebGLSync> fence_sync(WebIDL::UnsignedLong condition, WebIDL::UnsignedLong flags);
 38      void delete_sync(GC::Root<WebGLSync> sync);
 39      WebIDL::UnsignedLong client_wait_sync(GC::Root<WebGLSync> sync, WebIDL::UnsignedLong flags, WebIDL::UnsignedLongLong timeout);
 40      void bind_buffer_base(WebIDL::UnsignedLong target, WebIDL::UnsignedLong index, GC::Root<WebGLBuffer> buffer);
 41      GC::Root<WebGLVertexArrayObject> create_vertex_array();
 42      void delete_vertex_array(GC::Root<WebGLVertexArrayObject> vertex_array);
 43      bool is_vertex_array(GC::Root<WebGLVertexArrayObject> vertex_array);
 44      void bind_vertex_array(GC::Root<WebGLVertexArrayObject> array);
 45      void buffer_data(WebIDL::UnsignedLong target, WebIDL::LongLong size, WebIDL::UnsignedLong usage);
 46      void buffer_data(WebIDL::UnsignedLong target, GC::Root<WebIDL::BufferSource> src_data, WebIDL::UnsignedLong usage);
 47      void buffer_sub_data(WebIDL::UnsignedLong target, WebIDL::LongLong dst_byte_offset, GC::Root<WebIDL::BufferSource> src_data);
 48      void tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels);
 49      void tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, Variant<GC::Root<ImageBitmap>, GC::Root<ImageData>, GC::Root<HTMLImageElement>, GC::Root<HTMLCanvasElement>, GC::Root<HTMLVideoElement>> source);
 50      void tex_sub_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels);
 51      void tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset);
 52      void tex_sub_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset);
 53      void uniform1fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 54      void uniform2fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 55      void uniform3fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 56      void uniform4fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 57      void uniform1iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 58      void uniform2iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 59      void uniform3iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 60      void uniform4iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 61      void uniform_matrix2fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> data, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 62      void uniform_matrix3fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> data, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 63      void uniform_matrix4fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> data, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length);
 64      void read_pixels(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels);
 65      void active_texture(WebIDL::UnsignedLong texture);
 66      void attach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader);
 67      void bind_attrib_location(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index, String name);
 68      void bind_buffer(WebIDL::UnsignedLong target, GC::Root<WebGLBuffer> buffer);
 69      void bind_framebuffer(WebIDL::UnsignedLong target, GC::Root<WebGLFramebuffer> framebuffer);
 70      void bind_renderbuffer(WebIDL::UnsignedLong target, GC::Root<WebGLRenderbuffer> renderbuffer);
 71      void bind_texture(WebIDL::UnsignedLong target, GC::Root<WebGLTexture> texture);
 72      void blend_color(float red, float green, float blue, float alpha);
 73      void blend_equation(WebIDL::UnsignedLong mode);
 74      void blend_equation_separate(WebIDL::UnsignedLong mode_rgb, WebIDL::UnsignedLong mode_alpha);
 75      void blend_func(WebIDL::UnsignedLong sfactor, WebIDL::UnsignedLong dfactor);
 76      void blend_func_separate(WebIDL::UnsignedLong src_rgb, WebIDL::UnsignedLong dst_rgb, WebIDL::UnsignedLong src_alpha, WebIDL::UnsignedLong dst_alpha);
 77      WebIDL::UnsignedLong check_framebuffer_status(WebIDL::UnsignedLong target);
 78      void clear(WebIDL::UnsignedLong mask);
 79      void clear_color(float red, float green, float blue, float alpha);
 80      void clear_depth(float depth);
 81      void clear_stencil(WebIDL::Long s);
 82      void color_mask(bool red, bool green, bool blue, bool alpha);
 83      void compile_shader(GC::Root<WebGLShader> shader);
 84      GC::Root<WebGLBuffer> create_buffer();
 85      GC::Root<WebGLFramebuffer> create_framebuffer();
 86      GC::Root<WebGLProgram> create_program();
 87      GC::Root<WebGLRenderbuffer> create_renderbuffer();
 88      GC::Root<WebGLShader> create_shader(WebIDL::UnsignedLong type);
 89      GC::Root<WebGLTexture> create_texture();
 90      void cull_face(WebIDL::UnsignedLong mode);
 91      void delete_buffer(GC::Root<WebGLBuffer> buffer);
 92      void delete_framebuffer(GC::Root<WebGLFramebuffer> framebuffer);
 93      void delete_program(GC::Root<WebGLProgram> program);
 94      void delete_shader(GC::Root<WebGLShader> shader);
 95      void delete_texture(GC::Root<WebGLTexture> texture);
 96      void depth_func(WebIDL::UnsignedLong func);
 97      void depth_mask(bool flag);
 98      void depth_range(float z_near, float z_far);
 99      void detach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader);
100      void disable(WebIDL::UnsignedLong cap);
101      void disable_vertex_attrib_array(WebIDL::UnsignedLong index);
102      void draw_arrays(WebIDL::UnsignedLong mode, WebIDL::Long first, WebIDL::Long count);
103      void draw_elements(WebIDL::UnsignedLong mode, WebIDL::Long count, WebIDL::UnsignedLong type, WebIDL::LongLong offset);
104      void enable(WebIDL::UnsignedLong cap);
105      void enable_vertex_attrib_array(WebIDL::UnsignedLong index);
106      void finish();
107      void flush();
108      void framebuffer_renderbuffer(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong renderbuffertarget, GC::Root<WebGLRenderbuffer> renderbuffer);
109      void framebuffer_texture2d(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong textarget, GC::Root<WebGLTexture> texture, WebIDL::Long level);
110      void front_face(WebIDL::UnsignedLong mode);
111      void generate_mipmap(WebIDL::UnsignedLong target);
112      GC::Root<WebGLActiveInfo> get_active_attrib(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index);
113      GC::Root<WebGLActiveInfo> get_active_uniform(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index);
114      WebIDL::Long get_attrib_location(GC::Root<WebGLProgram> program, String name);
115      JS::Value get_buffer_parameter(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname);
116      JS::Value get_parameter(WebIDL::UnsignedLong pname);
117      WebIDL::UnsignedLong get_error();
118      JS::Value get_program_parameter(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong pname);
119      Optional<String> get_program_info_log(GC::Root<WebGLProgram> program);
120      JS::Value get_shader_parameter(GC::Root<WebGLShader> shader, WebIDL::UnsignedLong pname);
121      GC::Root<WebGLShaderPrecisionFormat> get_shader_precision_format(WebIDL::UnsignedLong shadertype, WebIDL::UnsignedLong precisiontype);
122      Optional<String> get_shader_info_log(GC::Root<WebGLShader> shader);
123      GC::Root<WebGLUniformLocation> get_uniform_location(GC::Root<WebGLProgram> program, String name);
124      void hint(WebIDL::UnsignedLong target, WebIDL::UnsignedLong mode);
125      bool is_buffer(GC::Root<WebGLBuffer> buffer);
126      bool is_enabled(WebIDL::UnsignedLong cap);
127      bool is_framebuffer(GC::Root<WebGLFramebuffer> framebuffer);
128      bool is_program(GC::Root<WebGLProgram> program);
129      bool is_renderbuffer(GC::Root<WebGLRenderbuffer> renderbuffer);
130      bool is_shader(GC::Root<WebGLShader> shader);
131      bool is_texture(GC::Root<WebGLTexture> texture);
132      void line_width(float width);
133      void link_program(GC::Root<WebGLProgram> program);
134      void pixel_storei(WebIDL::UnsignedLong pname, WebIDL::Long param);
135      void polygon_offset(float factor, float units);
136      void renderbuffer_storage(WebIDL::UnsignedLong target, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height);
137      void sample_coverage(float value, bool invert);
138      void scissor(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height);
139      void shader_source(GC::Root<WebGLShader> shader, String source);
140      void stencil_func(WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask);
141      void stencil_func_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask);
142      void stencil_mask(WebIDL::UnsignedLong mask);
143      void stencil_mask_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong mask);
144      void stencil_op(WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass);
145      void stencil_op_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass);
146      void tex_parameterf(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, float param);
147      void tex_parameteri(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, WebIDL::Long param);
148      void uniform1f(GC::Root<WebGLUniformLocation> location, float x);
149      void uniform2f(GC::Root<WebGLUniformLocation> location, float x, float y);
150      void uniform3f(GC::Root<WebGLUniformLocation> location, float x, float y, float z);
151      void uniform4f(GC::Root<WebGLUniformLocation> location, float x, float y, float z, float w);
152      void uniform1i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x);
153      void uniform2i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y);
154      void uniform3i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z);
155      void uniform4i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z, WebIDL::Long w);
156      void use_program(GC::Root<WebGLProgram> program);
157      void validate_program(GC::Root<WebGLProgram> program);
158      void vertex_attrib1f(WebIDL::UnsignedLong index, float x);
159      void vertex_attrib2f(WebIDL::UnsignedLong index, float x, float y);
160      void vertex_attrib3f(WebIDL::UnsignedLong index, float x, float y, float z);
161      void vertex_attrib4f(WebIDL::UnsignedLong index, float x, float y, float z, float w);
162      void vertex_attrib1fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
163      void vertex_attrib2fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
164      void vertex_attrib3fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
165      void vertex_attrib4fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
166      void vertex_attrib_pointer(WebIDL::UnsignedLong index, WebIDL::Long size, WebIDL::UnsignedLong type, bool normalized, WebIDL::Long stride, WebIDL::LongLong offset);
167      void viewport(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height);
168  
169  private:
170      GC::Ref<JS::Realm> m_realm;
171      NonnullOwnPtr<OpenGLContext> m_context;
172  };
173  
174  }
</document_content>
</document>
<document index="49">
<source>./LadybirdBuild/WebGL2RenderingContextImpl.cpp</source>
<document_content>
   1  
   2  #include <GLES3/gl3.h>
   3  
   4  #include <LibJS/Runtime/ArrayBuffer.h>
   5  #include <LibJS/Runtime/DataView.h>
   6  #include <LibJS/Runtime/TypedArray.h>
   7  #include <LibWeb/HTML/HTMLCanvasElement.h>
   8  #include <LibWeb/HTML/HTMLImageElement.h>
   9  #include <LibWeb/HTML/HTMLVideoElement.h>
  10  #include <LibWeb/HTML/ImageBitmap.h>
  11  #include <LibWeb/HTML/ImageData.h>
  12  #include <LibWeb/WebGL/OpenGLContext.h>
  13  #include <LibWeb/WebGL/WebGLActiveInfo.h>
  14  #include <LibWeb/WebGL/WebGLBuffer.h>
  15  #include <LibWeb/WebGL/WebGLFramebuffer.h>
  16  #include <LibWeb/WebGL/WebGLProgram.h>
  17  #include <LibWeb/WebGL/WebGLRenderbuffer.h>
  18  #include <LibWeb/WebGL/WebGL2RenderingContextImpl.h>
  19  #include <LibWeb/WebGL/WebGLSampler.h>
  20  #include <LibWeb/WebGL/WebGLShader.h>
  21  #include <LibWeb/WebGL/WebGLSync.h>
  22  #include <LibWeb/WebGL/WebGLShaderPrecisionFormat.h>
  23  #include <LibWeb/WebGL/WebGLTexture.h>
  24  #include <LibWeb/WebGL/WebGLUniformLocation.h>
  25  #include <LibWeb/WebGL/WebGLVertexArrayObject.h>
  26  #include <LibWeb/WebIDL/Buffers.h>
  27  
  28  namespace Web::WebGL {
  29  
  30  static Vector<GLchar> null_terminated_string(StringView string)
  31  {
  32      Vector<GLchar> result;
  33      for (auto c : string.bytes())
  34          result.append(c);
  35      result.append('\0');
  36      return result;
  37  }
  38  
  39  WebGL2RenderingContextImpl::WebGL2RenderingContextImpl(JS::Realm& realm, NonnullOwnPtr<OpenGLContext> context)
  40      : m_realm(realm)
  41      , m_context(move(context))
  42  {
  43  }
  44  
  45  
  46  void WebGL2RenderingContextImpl::blit_framebuffer(WebIDL::Long src_x0, WebIDL::Long src_y0, WebIDL::Long src_x1, WebIDL::Long src_y1, WebIDL::Long dst_x0, WebIDL::Long dst_y0, WebIDL::Long dst_x1, WebIDL::Long dst_y1, WebIDL::UnsignedLong mask, WebIDL::UnsignedLong filter)
  47  {
  48      m_context->make_current();
  49      glBlitFramebuffer(src_x0, src_y0, src_x1, src_y1, dst_x0, dst_y0, dst_x1, dst_y1, mask, filter);
  50  }
  51  
  52  void WebGL2RenderingContextImpl::read_buffer(WebIDL::UnsignedLong src)
  53  {
  54      m_context->make_current();
  55      glReadBuffer(src);
  56  }
  57  
  58  JS::Value WebGL2RenderingContextImpl::get_internalformat_parameter(WebIDL::UnsignedLong target, WebIDL::UnsignedLong internalformat, WebIDL::UnsignedLong pname)
  59  {
  60      m_context->make_current();
  61  
  62      switch (pname) {
  63      case GL_SAMPLES: {
  64          GLint num_sample_counts { 0 };
  65          glGetInternalformativ(target, internalformat, GL_NUM_SAMPLE_COUNTS, 1, &num_sample_counts);
  66          auto samples_buffer = MUST(ByteBuffer::create_zeroed(num_sample_counts * sizeof(GLint)));
  67          glGetInternalformativ(target, internalformat, GL_SAMPLES, num_sample_counts, reinterpret_cast<GLint*>(samples_buffer.data()));
  68          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(samples_buffer));
  69          return JS::Int32Array::create(m_realm, num_sample_counts, array_buffer);
  70      }
  71      default:
  72          dbgln("Unknown WebGL internal format parameter name: {:x}", pname);
  73          set_error(GL_INVALID_ENUM);
  74          return JS::js_null();
  75      }
  76  }
  77  
  78  void WebGL2RenderingContextImpl::renderbuffer_storage_multisample(WebIDL::UnsignedLong target, WebIDL::Long samples, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height)
  79  {
  80      m_context->make_current();
  81      glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
  82  }
  83  
  84  void WebGL2RenderingContextImpl::tex_storage2d(WebIDL::UnsignedLong target, WebIDL::Long levels, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height)
  85  {
  86      m_context->make_current();
  87  
  88      glTexStorage2D(target, levels, internalformat, width, height);
  89  }
  90  
  91  void WebGL2RenderingContextImpl::tex_storage3d(WebIDL::UnsignedLong target, WebIDL::Long levels, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth)
  92  {
  93      m_context->make_current();
  94      glTexStorage3D(target, levels, internalformat, width, height, depth);
  95  }
  96  
  97  void WebGL2RenderingContextImpl::tex_image3d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data)
  98  {
  99      m_context->make_current();
 100  
 101      void const* src_data_ptr = nullptr;
 102      if (src_data) {
 103          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 104          auto const& byte_buffer = viewed_array_buffer->buffer();
 105          src_data_ptr = byte_buffer.data();
 106      }
 107      glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, src_data_ptr);
 108  }
 109  
 110  void WebGL2RenderingContextImpl::tex_image3d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset)
 111  {
 112      m_context->make_current();
 113  
 114      void const* src_data_ptr = nullptr;
 115      if (src_data) {
 116          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 117          auto const& byte_buffer = viewed_array_buffer->buffer();
 118          src_data_ptr = byte_buffer.data() + src_offset;
 119      }
 120      glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, src_data_ptr);
 121  }
 122  
 123  void WebGL2RenderingContextImpl::tex_sub_image3d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long zoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::Long depth, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset)
 124  {
 125      m_context->make_current();
 126  
 127      void const* pixels_ptr = nullptr;
 128      if (src_data) {
 129          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 130          auto const& byte_buffer = viewed_array_buffer->buffer();
 131          pixels_ptr = byte_buffer.data() + src_offset;
 132      }
 133      glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels_ptr);
 134  }
 135  
 136  void WebGL2RenderingContextImpl::draw_buffers(Vector<WebIDL::UnsignedLong> buffers)
 137  {
 138      m_context->make_current();
 139  
 140      glDrawBuffers(buffers.size(), buffers.data());
 141  }
 142  
 143  GC::Root<WebGLSampler> WebGL2RenderingContextImpl::create_sampler()
 144  {
 145      m_context->make_current();
 146  
 147      GLuint handle = 0;
 148      glGenSamplers(1, &handle);
 149      return WebGLSampler::create(m_realm, *this, handle);
 150  }
 151  
 152  void WebGL2RenderingContextImpl::bind_sampler(WebIDL::UnsignedLong unit, GC::Root<WebGLSampler> sampler)
 153  {
 154      m_context->make_current();
 155  
 156      auto sampler_handle = 0;
 157      if (sampler) {
 158          auto handle_or_error = sampler->handle(this);
 159          if (handle_or_error.is_error()) {
 160              set_error(GL_INVALID_OPERATION);
 161              return ;
 162          }
 163          sampler_handle = handle_or_error.release_value();
 164      }
 165      glBindSampler(unit, sampler_handle);
 166  }
 167  
 168  GC::Root<WebGLSync> WebGL2RenderingContextImpl::fence_sync(WebIDL::UnsignedLong condition, WebIDL::UnsignedLong flags)
 169  {
 170      m_context->make_current();
 171  
 172      GLsync handle = glFenceSync(condition, flags);
 173      return WebGLSync::create(m_realm, *this, handle);
 174  }
 175  
 176  void WebGL2RenderingContextImpl::delete_sync(GC::Root<WebGLSync> sync)
 177  {
 178      m_context->make_current();
 179      glDeleteSync((GLsync)(sync ? sync->sync_handle() : nullptr));
 180  }
 181  
 182  WebIDL::UnsignedLong WebGL2RenderingContextImpl::client_wait_sync(GC::Root<WebGLSync> sync, WebIDL::UnsignedLong flags, WebIDL::UnsignedLongLong timeout)
 183  {
 184      m_context->make_current();
 185      return glClientWaitSync((GLsync)(sync ? sync->sync_handle() : nullptr), flags, timeout);
 186  }
 187  
 188  void WebGL2RenderingContextImpl::bind_buffer_base(WebIDL::UnsignedLong target, WebIDL::UnsignedLong index, GC::Root<WebGLBuffer> buffer)
 189  {
 190      m_context->make_current();
 191  
 192      auto buffer_handle = 0;
 193      if (buffer) {
 194          auto handle_or_error = buffer->handle(this);
 195          if (handle_or_error.is_error()) {
 196              set_error(GL_INVALID_OPERATION);
 197              return ;
 198          }
 199          buffer_handle = handle_or_error.release_value();
 200      }
 201      glBindBufferBase(target, index, buffer_handle);
 202  }
 203  
 204  GC::Root<WebGLVertexArrayObject> WebGL2RenderingContextImpl::create_vertex_array()
 205  {
 206      m_context->make_current();
 207  
 208      GLuint handle = 0;
 209      glGenVertexArrays(1, &handle);
 210      return WebGLVertexArrayObject::create(m_realm, *this, handle);
 211  }
 212  
 213  void WebGL2RenderingContextImpl::delete_vertex_array(GC::Root<WebGLVertexArrayObject> vertex_array)
 214  {
 215      m_context->make_current();
 216  
 217      GLuint vertex_array_handle = 0;
 218      if (vertex_array) {
 219          auto handle_or_error = vertex_array->handle(this);
 220          if (handle_or_error.is_error()) {
 221              set_error(GL_INVALID_OPERATION);
 222              return ;
 223          }
 224          vertex_array_handle = handle_or_error.release_value();
 225      }
 226  
 227      glDeleteVertexArrays(1, &vertex_array_handle);
 228  }
 229  
 230  bool WebGL2RenderingContextImpl::is_vertex_array(GC::Root<WebGLVertexArrayObject> vertex_array)
 231  {
 232      m_context->make_current();
 233  
 234      auto vertex_array_handle = 0;
 235      if (vertex_array) {
 236          auto handle_or_error = vertex_array->handle(this);
 237          if (handle_or_error.is_error()) {
 238              set_error(GL_INVALID_OPERATION);
 239              return false;
 240          }
 241          vertex_array_handle = handle_or_error.release_value();
 242      }
 243      return glIsVertexArray(vertex_array_handle);
 244  }
 245  
 246  void WebGL2RenderingContextImpl::bind_vertex_array(GC::Root<WebGLVertexArrayObject> array)
 247  {
 248      m_context->make_current();
 249  
 250      auto array_handle = 0;
 251      if (array) {
 252          auto handle_or_error = array->handle(this);
 253          if (handle_or_error.is_error()) {
 254              set_error(GL_INVALID_OPERATION);
 255              return ;
 256          }
 257          array_handle = handle_or_error.release_value();
 258      }
 259      glBindVertexArray(array_handle);
 260  }
 261  
 262  void WebGL2RenderingContextImpl::buffer_data(WebIDL::UnsignedLong target, WebIDL::LongLong size, WebIDL::UnsignedLong usage)
 263  {
 264      m_context->make_current();
 265  
 266      glBufferData(target, size, 0, usage);
 267  }
 268  
 269  void WebGL2RenderingContextImpl::buffer_data(WebIDL::UnsignedLong target, GC::Root<WebIDL::BufferSource> src_data, WebIDL::UnsignedLong usage)
 270  {
 271      m_context->make_current();
 272  
 273      void const* ptr = nullptr;
 274      size_t byte_size = 0;
 275      if (src_data->is_typed_array_base()) {
 276          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*src_data->raw_object());
 277          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
 278          byte_size = typed_array_base.viewed_array_buffer()->byte_length();
 279      } else if (src_data->is_data_view()) {
 280          auto& data_view = static_cast<JS::DataView&>(*src_data->raw_object());
 281          ptr = data_view.viewed_array_buffer()->buffer().data();
 282          byte_size = data_view.viewed_array_buffer()->byte_length();
 283      } else if (src_data->is_array_buffer()) {
 284          auto& array_buffer = static_cast<JS::ArrayBuffer&>(*src_data->raw_object());
 285          ptr = array_buffer.buffer().data();
 286          byte_size = array_buffer.byte_length();
 287      } else {
 288          VERIFY_NOT_REACHED();
 289      }
 290      glBufferData(target, byte_size, ptr, usage);
 291  }
 292  
 293  void WebGL2RenderingContextImpl::buffer_sub_data(WebIDL::UnsignedLong target, WebIDL::LongLong dst_byte_offset, GC::Root<WebIDL::BufferSource> src_data)
 294  {
 295      m_context->make_current();
 296  
 297      void const* ptr = nullptr;
 298      size_t byte_size = 0;
 299      if (src_data->is_typed_array_base()) {
 300          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*src_data->raw_object());
 301          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
 302          byte_size = typed_array_base.viewed_array_buffer()->byte_length();
 303      } else if (src_data->is_data_view()) {
 304          auto& data_view = static_cast<JS::DataView&>(*src_data->raw_object());
 305          ptr = data_view.viewed_array_buffer()->buffer().data();
 306          byte_size = data_view.viewed_array_buffer()->byte_length();
 307      } else if (src_data->is_array_buffer()) {
 308          auto& array_buffer = static_cast<JS::ArrayBuffer&>(*src_data->raw_object());
 309          ptr = array_buffer.buffer().data();
 310          byte_size = array_buffer.byte_length();
 311      } else {
 312          VERIFY_NOT_REACHED();
 313      }
 314      glBufferSubData(target, dst_byte_offset, byte_size, ptr);
 315  }
 316  
 317  void WebGL2RenderingContextImpl::tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels)
 318  {
 319      m_context->make_current();
 320  
 321      void const* pixels_ptr = nullptr;
 322      if (pixels) {
 323          auto const& viewed_array_buffer = pixels->viewed_array_buffer();
 324          auto const& byte_buffer = viewed_array_buffer->buffer();
 325          pixels_ptr = byte_buffer.data();
 326      }
 327      glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
 328  }
 329  
 330  void WebGL2RenderingContextImpl::tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, Variant<GC::Root<ImageBitmap>, GC::Root<ImageData>, GC::Root<HTMLImageElement>, GC::Root<HTMLCanvasElement>, GC::Root<HTMLVideoElement>> source)
 331  {
 332      m_context->make_current();
 333  
 334      auto bitmap = source.visit(
 335          [](GC::Root<HTMLImageElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 336              return source->immutable_bitmap();
 337          },
 338          [](GC::Root<HTMLCanvasElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 339              auto surface = source->surface();
 340              if (!surface)
 341                  return {};
 342              auto bitmap = MUST(Gfx::Bitmap::create(Gfx::BitmapFormat::RGBA8888, Gfx::AlphaType::Premultiplied, surface->size()));
 343              surface->read_into_bitmap(*bitmap);
 344              return Gfx::ImmutableBitmap::create(*bitmap);
 345          },
 346          [](GC::Root<HTMLVideoElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 347              return Gfx::ImmutableBitmap::create(*source->bitmap());
 348          },
 349          [](GC::Root<ImageBitmap> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 350              return Gfx::ImmutableBitmap::create(*source->bitmap());
 351          },
 352          [](GC::Root<ImageData> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 353              return Gfx::ImmutableBitmap::create(source->bitmap());
 354          });
 355      if (!bitmap)
 356          return;
 357  
 358      void const* pixels_ptr = bitmap->bitmap()->begin();
 359      int width = bitmap->width();
 360      int height = bitmap->height();
 361      glTexImage2D(target, level, internalformat, width, height, 0, format, type, pixels_ptr);
 362  }
 363  
 364  void WebGL2RenderingContextImpl::tex_sub_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels)
 365  {
 366      m_context->make_current();
 367  
 368      void const* pixels_ptr = nullptr;
 369      if (pixels) {
 370          auto const& viewed_array_buffer = pixels->viewed_array_buffer();
 371          auto const& byte_buffer = viewed_array_buffer->buffer();
 372          pixels_ptr = byte_buffer.data();
 373      }
 374      glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
 375  }
 376  
 377  void WebGL2RenderingContextImpl::tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset)
 378  {
 379      m_context->make_current();
 380  
 381      void const* pixels_ptr = nullptr;
 382      if (src_data) {
 383          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 384          auto const& byte_buffer = viewed_array_buffer->buffer();
 385          pixels_ptr = byte_buffer.data() + src_offset;
 386      }
 387      glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
 388  }
 389  
 390  void WebGL2RenderingContextImpl::tex_sub_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> src_data, WebIDL::UnsignedLongLong src_offset)
 391  {
 392      m_context->make_current();
 393  
 394      void const* pixels_ptr = nullptr;
 395      if (src_data) {
 396          auto const& viewed_array_buffer = src_data->viewed_array_buffer();
 397          auto const& byte_buffer = viewed_array_buffer->buffer();
 398          pixels_ptr = byte_buffer.data() + src_offset;
 399      }
 400      glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
 401  }
 402  
 403  void WebGL2RenderingContextImpl::uniform1fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 404  {
 405      m_context->make_current();
 406  
 407      float const* data = nullptr;
 408      size_t count = 0;
 409      if (v.has<Vector<float>>()) {
 410          auto& vector = v.get<Vector<float>>();
 411          data = vector.data();
 412          count = vector.size();
 413      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 414          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 415          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 416          data = typed_array.data().data();
 417          count = typed_array.array_length().length();
 418      } else {
 419          VERIFY_NOT_REACHED();
 420      }
 421  
 422      data += src_offset;
 423      if (src_length == 0) {
 424          count -= src_offset;
 425      }
 426  
 427      if (src_offset + src_length <= count) {
 428          set_error(GL_INVALID_VALUE);
 429          return;
 430      }
 431  
 432      glUniform1fv(location->handle(), count / 1, data);
 433  }
 434  
 435  void WebGL2RenderingContextImpl::uniform2fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 436  {
 437      m_context->make_current();
 438  
 439      float const* data = nullptr;
 440      size_t count = 0;
 441      if (v.has<Vector<float>>()) {
 442          auto& vector = v.get<Vector<float>>();
 443          data = vector.data();
 444          count = vector.size();
 445      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 446          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 447          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 448          data = typed_array.data().data();
 449          count = typed_array.array_length().length();
 450      } else {
 451          VERIFY_NOT_REACHED();
 452      }
 453  
 454      data += src_offset;
 455      if (src_length == 0) {
 456          count -= src_offset;
 457      }
 458  
 459      if (src_offset + src_length <= count) {
 460          set_error(GL_INVALID_VALUE);
 461          return;
 462      }
 463  
 464      glUniform2fv(location->handle(), count / 2, data);
 465  }
 466  
 467  void WebGL2RenderingContextImpl::uniform3fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 468  {
 469      m_context->make_current();
 470  
 471      float const* data = nullptr;
 472      size_t count = 0;
 473      if (v.has<Vector<float>>()) {
 474          auto& vector = v.get<Vector<float>>();
 475          data = vector.data();
 476          count = vector.size();
 477      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 478          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 479          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 480          data = typed_array.data().data();
 481          count = typed_array.array_length().length();
 482      } else {
 483          VERIFY_NOT_REACHED();
 484      }
 485  
 486      data += src_offset;
 487      if (src_length == 0) {
 488          count -= src_offset;
 489      }
 490  
 491      if (src_offset + src_length <= count) {
 492          set_error(GL_INVALID_VALUE);
 493          return;
 494      }
 495  
 496      glUniform3fv(location->handle(), count / 3, data);
 497  }
 498  
 499  void WebGL2RenderingContextImpl::uniform4fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 500  {
 501      m_context->make_current();
 502  
 503      float const* data = nullptr;
 504      size_t count = 0;
 505      if (v.has<Vector<float>>()) {
 506          auto& vector = v.get<Vector<float>>();
 507          data = vector.data();
 508          count = vector.size();
 509      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 510          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 511          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 512          data = typed_array.data().data();
 513          count = typed_array.array_length().length();
 514      } else {
 515          VERIFY_NOT_REACHED();
 516      }
 517  
 518      data += src_offset;
 519      if (src_length == 0) {
 520          count -= src_offset;
 521      }
 522  
 523      if (src_offset + src_length <= count) {
 524          set_error(GL_INVALID_VALUE);
 525          return;
 526      }
 527  
 528      glUniform4fv(location->handle(), count / 4, data);
 529  }
 530  
 531  void WebGL2RenderingContextImpl::uniform1iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 532  {
 533      m_context->make_current();
 534  
 535      int const* data = nullptr;
 536      size_t count = 0;
 537      if (v.has<Vector<int>>()) {
 538          auto& vector = v.get<Vector<int>>();
 539          data = vector.data();
 540          count = vector.size();
 541      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 542          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 543          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 544          data = typed_array.data().data();
 545          count = typed_array.array_length().length();
 546      } else {
 547          VERIFY_NOT_REACHED();
 548      }
 549  
 550      data += src_offset;
 551      if (src_length == 0) {
 552          count -= src_offset;
 553      }
 554  
 555      if (src_offset + src_length <= count) {
 556          set_error(GL_INVALID_VALUE);
 557          return;
 558      }
 559  
 560      glUniform1iv(location->handle(), count / 1, data);
 561  }
 562  
 563  void WebGL2RenderingContextImpl::uniform2iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 564  {
 565      m_context->make_current();
 566  
 567      int const* data = nullptr;
 568      size_t count = 0;
 569      if (v.has<Vector<int>>()) {
 570          auto& vector = v.get<Vector<int>>();
 571          data = vector.data();
 572          count = vector.size();
 573      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 574          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 575          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 576          data = typed_array.data().data();
 577          count = typed_array.array_length().length();
 578      } else {
 579          VERIFY_NOT_REACHED();
 580      }
 581  
 582      data += src_offset;
 583      if (src_length == 0) {
 584          count -= src_offset;
 585      }
 586  
 587      if (src_offset + src_length <= count) {
 588          set_error(GL_INVALID_VALUE);
 589          return;
 590      }
 591  
 592      glUniform2iv(location->handle(), count / 2, data);
 593  }
 594  
 595  void WebGL2RenderingContextImpl::uniform3iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 596  {
 597      m_context->make_current();
 598  
 599      int const* data = nullptr;
 600      size_t count = 0;
 601      if (v.has<Vector<int>>()) {
 602          auto& vector = v.get<Vector<int>>();
 603          data = vector.data();
 604          count = vector.size();
 605      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 606          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 607          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 608          data = typed_array.data().data();
 609          count = typed_array.array_length().length();
 610      } else {
 611          VERIFY_NOT_REACHED();
 612      }
 613  
 614      data += src_offset;
 615      if (src_length == 0) {
 616          count -= src_offset;
 617      }
 618  
 619      if (src_offset + src_length <= count) {
 620          set_error(GL_INVALID_VALUE);
 621          return;
 622      }
 623  
 624      glUniform3iv(location->handle(), count / 3, data);
 625  }
 626  
 627  void WebGL2RenderingContextImpl::uniform4iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 628  {
 629      m_context->make_current();
 630  
 631      int const* data = nullptr;
 632      size_t count = 0;
 633      if (v.has<Vector<int>>()) {
 634          auto& vector = v.get<Vector<int>>();
 635          data = vector.data();
 636          count = vector.size();
 637      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 638          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 639          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 640          data = typed_array.data().data();
 641          count = typed_array.array_length().length();
 642      } else {
 643          VERIFY_NOT_REACHED();
 644      }
 645  
 646      data += src_offset;
 647      if (src_length == 0) {
 648          count -= src_offset;
 649      }
 650  
 651      if (src_offset + src_length <= count) {
 652          set_error(GL_INVALID_VALUE);
 653          return;
 654      }
 655  
 656      glUniform4iv(location->handle(), count / 4, data);
 657  }
 658  
 659  void WebGL2RenderingContextImpl::uniform_matrix2fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> data, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 660  {
 661      m_context->make_current();
 662  
 663      auto matrix_size = 2 * 2;
 664      float const* raw_data = nullptr;
 665      u64 count = 0;
 666      if (data.has<Vector<float>>()) {
 667          auto& vector_data = data.get<Vector<float>>();
 668          raw_data = vector_data.data();
 669          count = vector_data.size() / matrix_size;
 670      } else {
 671          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*data.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 672          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 673          raw_data = float32_array.data().data();
 674          count = float32_array.array_length().length() / matrix_size;
 675      }
 676  
 677      raw_data += src_offset;
 678      if (src_length == 0) {
 679          count -= src_offset;
 680      }
 681  
 682      if (src_offset + src_length <= count) {
 683          set_error(GL_INVALID_VALUE);
 684          return;
 685      }
 686  
 687      glUniformMatrix2fv(location->handle(), count, transpose, raw_data);
 688  }
 689  
 690  void WebGL2RenderingContextImpl::uniform_matrix3fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> data, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 691  {
 692      m_context->make_current();
 693  
 694      auto matrix_size = 3 * 3;
 695      float const* raw_data = nullptr;
 696      u64 count = 0;
 697      if (data.has<Vector<float>>()) {
 698          auto& vector_data = data.get<Vector<float>>();
 699          raw_data = vector_data.data();
 700          count = vector_data.size() / matrix_size;
 701      } else {
 702          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*data.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 703          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 704          raw_data = float32_array.data().data();
 705          count = float32_array.array_length().length() / matrix_size;
 706      }
 707  
 708      raw_data += src_offset;
 709      if (src_length == 0) {
 710          count -= src_offset;
 711      }
 712  
 713      if (src_offset + src_length <= count) {
 714          set_error(GL_INVALID_VALUE);
 715          return;
 716      }
 717  
 718      glUniformMatrix3fv(location->handle(), count, transpose, raw_data);
 719  }
 720  
 721  void WebGL2RenderingContextImpl::uniform_matrix4fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> data, WebIDL::UnsignedLongLong src_offset, WebIDL::UnsignedLong src_length)
 722  {
 723      m_context->make_current();
 724  
 725      auto matrix_size = 4 * 4;
 726      float const* raw_data = nullptr;
 727      u64 count = 0;
 728      if (data.has<Vector<float>>()) {
 729          auto& vector_data = data.get<Vector<float>>();
 730          raw_data = vector_data.data();
 731          count = vector_data.size() / matrix_size;
 732      } else {
 733          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*data.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 734          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 735          raw_data = float32_array.data().data();
 736          count = float32_array.array_length().length() / matrix_size;
 737      }
 738  
 739      raw_data += src_offset;
 740      if (src_length == 0) {
 741          count -= src_offset;
 742      }
 743  
 744      if (src_offset + src_length <= count) {
 745          set_error(GL_INVALID_VALUE);
 746          return;
 747      }
 748  
 749      glUniformMatrix4fv(location->handle(), count, transpose, raw_data);
 750  }
 751  
 752  void WebGL2RenderingContextImpl::read_pixels(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels)
 753  {
 754      m_context->make_current();
 755  
 756      if (!pixels) {
 757          return;
 758      }
 759  
 760      void *ptr = nullptr;
 761      if (pixels->is_data_view()) {
 762          auto& data_view = static_cast<JS::DataView&>(*pixels->raw_object());
 763          ptr = data_view.viewed_array_buffer()->buffer().data();
 764      } else if (pixels->is_typed_array_base()) {
 765          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*pixels->raw_object());
 766          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
 767      } else {
 768          VERIFY_NOT_REACHED();
 769      }
 770  
 771      glReadPixels(x, y, width, height, format, type, ptr);
 772  }
 773  
 774  void WebGL2RenderingContextImpl::active_texture(WebIDL::UnsignedLong texture)
 775  {
 776      m_context->make_current();
 777      glActiveTexture(texture);
 778  }
 779  
 780  void WebGL2RenderingContextImpl::attach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader)
 781  {
 782      m_context->make_current();
 783  
 784      auto program_handle = 0;
 785      if (program) {
 786          auto handle_or_error = program->handle(this);
 787          if (handle_or_error.is_error()) {
 788              set_error(GL_INVALID_OPERATION);
 789              return ;
 790          }
 791          program_handle = handle_or_error.release_value();
 792      }
 793  
 794      auto shader_handle = 0;
 795      if (shader) {
 796          auto handle_or_error = shader->handle(this);
 797          if (handle_or_error.is_error()) {
 798              set_error(GL_INVALID_OPERATION);
 799              return ;
 800          }
 801          shader_handle = handle_or_error.release_value();
 802      }
 803      glAttachShader(program_handle, shader_handle);
 804  }
 805  
 806  void WebGL2RenderingContextImpl::bind_attrib_location(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index, String name)
 807  {
 808      m_context->make_current();
 809  
 810      auto program_handle = 0;
 811      if (program) {
 812          auto handle_or_error = program->handle(this);
 813          if (handle_or_error.is_error()) {
 814              set_error(GL_INVALID_OPERATION);
 815              return ;
 816          }
 817          program_handle = handle_or_error.release_value();
 818      }
 819  
 820      auto name_null_terminated = null_terminated_string(name);
 821      glBindAttribLocation(program_handle, index, name_null_terminated.data());
 822  }
 823  
 824  void WebGL2RenderingContextImpl::bind_buffer(WebIDL::UnsignedLong target, GC::Root<WebGLBuffer> buffer)
 825  {
 826      m_context->make_current();
 827  
 828      auto buffer_handle = 0;
 829      if (buffer) {
 830          auto handle_or_error = buffer->handle(this);
 831          if (handle_or_error.is_error()) {
 832              set_error(GL_INVALID_OPERATION);
 833              return ;
 834          }
 835          buffer_handle = handle_or_error.release_value();
 836      }
 837      glBindBuffer(target, buffer_handle);
 838  }
 839  
 840  void WebGL2RenderingContextImpl::bind_framebuffer(WebIDL::UnsignedLong target, GC::Root<WebGLFramebuffer> framebuffer)
 841  {
 842      m_context->make_current();
 843  
 844      auto framebuffer_handle = 0;
 845      if (framebuffer) {
 846          auto handle_or_error = framebuffer->handle(this);
 847          if (handle_or_error.is_error()) {
 848              set_error(GL_INVALID_OPERATION);
 849              return ;
 850          }
 851          framebuffer_handle = handle_or_error.release_value();
 852      }
 853      glBindFramebuffer(target, framebuffer_handle);
 854  }
 855  
 856  void WebGL2RenderingContextImpl::bind_renderbuffer(WebIDL::UnsignedLong target, GC::Root<WebGLRenderbuffer> renderbuffer)
 857  {
 858      m_context->make_current();
 859  
 860      auto renderbuffer_handle = 0;
 861      if (renderbuffer) {
 862          auto handle_or_error = renderbuffer->handle(this);
 863          if (handle_or_error.is_error()) {
 864              set_error(GL_INVALID_OPERATION);
 865              return ;
 866          }
 867          renderbuffer_handle = handle_or_error.release_value();
 868      }
 869      glBindRenderbuffer(target, renderbuffer_handle);
 870  }
 871  
 872  void WebGL2RenderingContextImpl::bind_texture(WebIDL::UnsignedLong target, GC::Root<WebGLTexture> texture)
 873  {
 874      m_context->make_current();
 875  
 876      auto texture_handle = 0;
 877      if (texture) {
 878          auto handle_or_error = texture->handle(this);
 879          if (handle_or_error.is_error()) {
 880              set_error(GL_INVALID_OPERATION);
 881              return ;
 882          }
 883          texture_handle = handle_or_error.release_value();
 884      }
 885      glBindTexture(target, texture_handle);
 886  }
 887  
 888  void WebGL2RenderingContextImpl::blend_color(float red, float green, float blue, float alpha)
 889  {
 890      m_context->make_current();
 891      glBlendColor(red, green, blue, alpha);
 892  }
 893  
 894  void WebGL2RenderingContextImpl::blend_equation(WebIDL::UnsignedLong mode)
 895  {
 896      m_context->make_current();
 897      glBlendEquation(mode);
 898  }
 899  
 900  void WebGL2RenderingContextImpl::blend_equation_separate(WebIDL::UnsignedLong mode_rgb, WebIDL::UnsignedLong mode_alpha)
 901  {
 902      m_context->make_current();
 903      glBlendEquationSeparate(mode_rgb, mode_alpha);
 904  }
 905  
 906  void WebGL2RenderingContextImpl::blend_func(WebIDL::UnsignedLong sfactor, WebIDL::UnsignedLong dfactor)
 907  {
 908      m_context->make_current();
 909      glBlendFunc(sfactor, dfactor);
 910  }
 911  
 912  void WebGL2RenderingContextImpl::blend_func_separate(WebIDL::UnsignedLong src_rgb, WebIDL::UnsignedLong dst_rgb, WebIDL::UnsignedLong src_alpha, WebIDL::UnsignedLong dst_alpha)
 913  {
 914      m_context->make_current();
 915      glBlendFuncSeparate(src_rgb, dst_rgb, src_alpha, dst_alpha);
 916  }
 917  
 918  WebIDL::UnsignedLong WebGL2RenderingContextImpl::check_framebuffer_status(WebIDL::UnsignedLong target)
 919  {
 920      m_context->make_current();
 921      return glCheckFramebufferStatus(target);
 922  }
 923  
 924  void WebGL2RenderingContextImpl::clear(WebIDL::UnsignedLong mask)
 925  {
 926      m_context->make_current();
 927      glClear(mask);
 928  }
 929  
 930  void WebGL2RenderingContextImpl::clear_color(float red, float green, float blue, float alpha)
 931  {
 932      m_context->make_current();
 933      m_context->notify_content_will_change();
 934      needs_to_present();
 935      glClearColor(red, green, blue, alpha);
 936  }
 937  
 938  void WebGL2RenderingContextImpl::clear_depth(float depth)
 939  {
 940      m_context->make_current();
 941      glClearDepthf(depth);
 942  }
 943  
 944  void WebGL2RenderingContextImpl::clear_stencil(WebIDL::Long s)
 945  {
 946      m_context->make_current();
 947      glClearStencil(s);
 948  }
 949  
 950  void WebGL2RenderingContextImpl::color_mask(bool red, bool green, bool blue, bool alpha)
 951  {
 952      m_context->make_current();
 953      glColorMask(red, green, blue, alpha);
 954  }
 955  
 956  void WebGL2RenderingContextImpl::compile_shader(GC::Root<WebGLShader> shader)
 957  {
 958      m_context->make_current();
 959  
 960      auto shader_handle = 0;
 961      if (shader) {
 962          auto handle_or_error = shader->handle(this);
 963          if (handle_or_error.is_error()) {
 964              set_error(GL_INVALID_OPERATION);
 965              return ;
 966          }
 967          shader_handle = handle_or_error.release_value();
 968      }
 969      glCompileShader(shader_handle);
 970  }
 971  
 972  GC::Root<WebGLBuffer> WebGL2RenderingContextImpl::create_buffer()
 973  {
 974      m_context->make_current();
 975  
 976      GLuint handle = 0;
 977      glGenBuffers(1, &handle);
 978      return WebGLBuffer::create(m_realm, *this, handle);
 979  }
 980  
 981  GC::Root<WebGLFramebuffer> WebGL2RenderingContextImpl::create_framebuffer()
 982  {
 983      m_context->make_current();
 984  
 985      GLuint handle = 0;
 986      glGenFramebuffers(1, &handle);
 987      return WebGLFramebuffer::create(m_realm, *this, handle);
 988  }
 989  
 990  GC::Root<WebGLProgram> WebGL2RenderingContextImpl::create_program()
 991  {
 992      m_context->make_current();
 993      return WebGLProgram::create(m_realm, *this, glCreateProgram());
 994  }
 995  
 996  GC::Root<WebGLRenderbuffer> WebGL2RenderingContextImpl::create_renderbuffer()
 997  {
 998      m_context->make_current();
 999  
1000      GLuint handle = 0;
1001      glGenRenderbuffers(1, &handle);
1002      return WebGLRenderbuffer::create(m_realm, *this, handle);
1003  }
1004  
1005  GC::Root<WebGLShader> WebGL2RenderingContextImpl::create_shader(WebIDL::UnsignedLong type)
1006  {
1007      m_context->make_current();
1008      return WebGLShader::create(m_realm, *this, glCreateShader(type));
1009  }
1010  
1011  GC::Root<WebGLTexture> WebGL2RenderingContextImpl::create_texture()
1012  {
1013      m_context->make_current();
1014  
1015      GLuint handle = 0;
1016      glGenTextures(1, &handle);
1017      return WebGLTexture::create(m_realm, *this, handle);
1018  }
1019  
1020  void WebGL2RenderingContextImpl::cull_face(WebIDL::UnsignedLong mode)
1021  {
1022      m_context->make_current();
1023      glCullFace(mode);
1024  }
1025  
1026  void WebGL2RenderingContextImpl::delete_buffer(GC::Root<WebGLBuffer> buffer)
1027  {
1028      m_context->make_current();
1029  
1030      GLuint buffer_handle = 0;
1031      if (buffer) {
1032          auto handle_or_error = buffer->handle(this);
1033          if (handle_or_error.is_error()) {
1034              set_error(GL_INVALID_OPERATION);
1035              return ;
1036          }
1037          buffer_handle = handle_or_error.release_value();
1038      }
1039  
1040      glDeleteBuffers(1, &buffer_handle);
1041  }
1042  
1043  void WebGL2RenderingContextImpl::delete_framebuffer(GC::Root<WebGLFramebuffer> framebuffer)
1044  {
1045      m_context->make_current();
1046  
1047      GLuint framebuffer_handle = 0;
1048      if (framebuffer) {
1049          auto handle_or_error = framebuffer->handle(this);
1050          if (handle_or_error.is_error()) {
1051              set_error(GL_INVALID_OPERATION);
1052              return ;
1053          }
1054          framebuffer_handle = handle_or_error.release_value();
1055      }
1056  
1057      glDeleteFramebuffers(1, &framebuffer_handle);
1058  }
1059  
1060  void WebGL2RenderingContextImpl::delete_program(GC::Root<WebGLProgram> program)
1061  {
1062      m_context->make_current();
1063  
1064      auto program_handle = 0;
1065      if (program) {
1066          auto handle_or_error = program->handle(this);
1067          if (handle_or_error.is_error()) {
1068              set_error(GL_INVALID_OPERATION);
1069              return ;
1070          }
1071          program_handle = handle_or_error.release_value();
1072      }
1073      glDeleteProgram(program_handle);
1074  }
1075  
1076  void WebGL2RenderingContextImpl::delete_shader(GC::Root<WebGLShader> shader)
1077  {
1078      m_context->make_current();
1079  
1080      auto shader_handle = 0;
1081      if (shader) {
1082          auto handle_or_error = shader->handle(this);
1083          if (handle_or_error.is_error()) {
1084              set_error(GL_INVALID_OPERATION);
1085              return ;
1086          }
1087          shader_handle = handle_or_error.release_value();
1088      }
1089      glDeleteShader(shader_handle);
1090  }
1091  
1092  void WebGL2RenderingContextImpl::delete_texture(GC::Root<WebGLTexture> texture)
1093  {
1094      m_context->make_current();
1095  
1096      GLuint texture_handle = 0;
1097      if (texture) {
1098          auto handle_or_error = texture->handle(this);
1099          if (handle_or_error.is_error()) {
1100              set_error(GL_INVALID_OPERATION);
1101              return ;
1102          }
1103          texture_handle = handle_or_error.release_value();
1104      }
1105  
1106      glDeleteTextures(1, &texture_handle);
1107  }
1108  
1109  void WebGL2RenderingContextImpl::depth_func(WebIDL::UnsignedLong func)
1110  {
1111      m_context->make_current();
1112      glDepthFunc(func);
1113  }
1114  
1115  void WebGL2RenderingContextImpl::depth_mask(bool flag)
1116  {
1117      m_context->make_current();
1118      glDepthMask(flag);
1119  }
1120  
1121  void WebGL2RenderingContextImpl::depth_range(float z_near, float z_far)
1122  {
1123      m_context->make_current();
1124      glDepthRangef(z_near, z_far);
1125  }
1126  
1127  void WebGL2RenderingContextImpl::detach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader)
1128  {
1129      m_context->make_current();
1130  
1131      auto program_handle = 0;
1132      if (program) {
1133          auto handle_or_error = program->handle(this);
1134          if (handle_or_error.is_error()) {
1135              set_error(GL_INVALID_OPERATION);
1136              return ;
1137          }
1138          program_handle = handle_or_error.release_value();
1139      }
1140  
1141      auto shader_handle = 0;
1142      if (shader) {
1143          auto handle_or_error = shader->handle(this);
1144          if (handle_or_error.is_error()) {
1145              set_error(GL_INVALID_OPERATION);
1146              return ;
1147          }
1148          shader_handle = handle_or_error.release_value();
1149      }
1150      glDetachShader(program_handle, shader_handle);
1151  }
1152  
1153  void WebGL2RenderingContextImpl::disable(WebIDL::UnsignedLong cap)
1154  {
1155      m_context->make_current();
1156      glDisable(cap);
1157  }
1158  
1159  void WebGL2RenderingContextImpl::disable_vertex_attrib_array(WebIDL::UnsignedLong index)
1160  {
1161      m_context->make_current();
1162      glDisableVertexAttribArray(index);
1163  }
1164  
1165  void WebGL2RenderingContextImpl::draw_arrays(WebIDL::UnsignedLong mode, WebIDL::Long first, WebIDL::Long count)
1166  {
1167      m_context->make_current();
1168      m_context->notify_content_will_change();
1169      needs_to_present();
1170      glDrawArrays(mode, first, count);
1171  }
1172  
1173  void WebGL2RenderingContextImpl::draw_elements(WebIDL::UnsignedLong mode, WebIDL::Long count, WebIDL::UnsignedLong type, WebIDL::LongLong offset)
1174  {
1175      m_context->make_current();
1176      m_context->notify_content_will_change();
1177  
1178      glDrawElements(mode, count, type, reinterpret_cast<void*>(offset));
1179      needs_to_present();
1180  }
1181  
1182  void WebGL2RenderingContextImpl::enable(WebIDL::UnsignedLong cap)
1183  {
1184      m_context->make_current();
1185      glEnable(cap);
1186  }
1187  
1188  void WebGL2RenderingContextImpl::enable_vertex_attrib_array(WebIDL::UnsignedLong index)
1189  {
1190      m_context->make_current();
1191      glEnableVertexAttribArray(index);
1192  }
1193  
1194  void WebGL2RenderingContextImpl::finish()
1195  {
1196      m_context->make_current();
1197      glFinish();
1198  }
1199  
1200  void WebGL2RenderingContextImpl::flush()
1201  {
1202      m_context->make_current();
1203      glFlush();
1204  }
1205  
1206  void WebGL2RenderingContextImpl::framebuffer_renderbuffer(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong renderbuffertarget, GC::Root<WebGLRenderbuffer> renderbuffer)
1207  {
1208      m_context->make_current();
1209  
1210      auto renderbuffer_handle = 0;
1211      if (renderbuffer) {
1212          auto handle_or_error = renderbuffer->handle(this);
1213          if (handle_or_error.is_error()) {
1214              set_error(GL_INVALID_OPERATION);
1215              return ;
1216          }
1217          renderbuffer_handle = handle_or_error.release_value();
1218      }
1219      glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer_handle);
1220  }
1221  
1222  void WebGL2RenderingContextImpl::framebuffer_texture2d(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong textarget, GC::Root<WebGLTexture> texture, WebIDL::Long level)
1223  {
1224      m_context->make_current();
1225  
1226      auto texture_handle = 0;
1227      if (texture) {
1228          auto handle_or_error = texture->handle(this);
1229          if (handle_or_error.is_error()) {
1230              set_error(GL_INVALID_OPERATION);
1231              return ;
1232          }
1233          texture_handle = handle_or_error.release_value();
1234      }
1235      glFramebufferTexture2D(target, attachment, textarget, texture_handle, level);
1236  }
1237  
1238  void WebGL2RenderingContextImpl::front_face(WebIDL::UnsignedLong mode)
1239  {
1240      m_context->make_current();
1241      glFrontFace(mode);
1242  }
1243  
1244  void WebGL2RenderingContextImpl::generate_mipmap(WebIDL::UnsignedLong target)
1245  {
1246      m_context->make_current();
1247      glGenerateMipmap(target);
1248  }
1249  
1250  GC::Root<WebGLActiveInfo> WebGL2RenderingContextImpl::get_active_attrib(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index)
1251  {
1252      m_context->make_current();
1253  
1254      GLuint program_handle = 0;
1255      if (program) {
1256          auto handle_or_error = program->handle(this);
1257          if (handle_or_error.is_error()) {
1258              set_error(GL_INVALID_OPERATION);
1259              return {};
1260          }
1261          program_handle = handle_or_error.release_value();
1262      }
1263  
1264      GLint size = 0;
1265      GLenum type = 0;
1266      GLsizei buf_size = 256;
1267      GLsizei length = 0;
1268      GLchar name[256];
1269      glGetActiveAttrib(program_handle, index, buf_size, &length, &size, &type, name);
1270      auto readonly_bytes = ReadonlyBytes { name, static_cast<size_t>(length) };
1271      return WebGLActiveInfo::create(m_realm, String::from_utf8_without_validation(readonly_bytes), type, size);
1272  }
1273  
1274  GC::Root<WebGLActiveInfo> WebGL2RenderingContextImpl::get_active_uniform(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index)
1275  {
1276      m_context->make_current();
1277  
1278      GLuint program_handle = 0;
1279      if (program) {
1280          auto handle_or_error = program->handle(this);
1281          if (handle_or_error.is_error()) {
1282              set_error(GL_INVALID_OPERATION);
1283              return {};
1284          }
1285          program_handle = handle_or_error.release_value();
1286      }
1287  
1288      GLint size = 0;
1289      GLenum type = 0;
1290      GLsizei buf_size = 256;
1291      GLsizei length = 0;
1292      GLchar name[256];
1293      glGetActiveUniform(program_handle, index, buf_size, &length, &size, &type, name);
1294      auto readonly_bytes = ReadonlyBytes { name, static_cast<size_t>(length) };
1295      return WebGLActiveInfo::create(m_realm, String::from_utf8_without_validation(readonly_bytes), type, size);
1296  }
1297  
1298  WebIDL::Long WebGL2RenderingContextImpl::get_attrib_location(GC::Root<WebGLProgram> program, String name)
1299  {
1300      m_context->make_current();
1301  
1302      auto program_handle = 0;
1303      if (program) {
1304          auto handle_or_error = program->handle(this);
1305          if (handle_or_error.is_error()) {
1306              set_error(GL_INVALID_OPERATION);
1307              return -1;
1308          }
1309          program_handle = handle_or_error.release_value();
1310      }
1311  
1312      auto name_null_terminated = null_terminated_string(name);
1313      return glGetAttribLocation(program_handle, name_null_terminated.data());
1314  }
1315  
1316  JS::Value WebGL2RenderingContextImpl::get_buffer_parameter(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname)
1317  {
1318      m_context->make_current();
1319      switch (pname) {
1320      case GL_BUFFER_SIZE: {
1321          GLint result;
1322          glGetBufferParameteriv(target, GL_BUFFER_SIZE, &result);
1323          return JS::Value(result);
1324      }
1325  
1326      case GL_BUFFER_USAGE: {
1327          GLint result;
1328          glGetBufferParameteriv(target, GL_BUFFER_USAGE, &result);
1329          return JS::Value(result);
1330      }
1331  
1332      default:
1333          dbgln("Unknown WebGL buffer parameter name: {:x}", pname);
1334          set_error(GL_INVALID_ENUM);
1335          return JS::js_null();
1336      }
1337  }
1338  
1339  JS::Value WebGL2RenderingContextImpl::get_parameter(WebIDL::UnsignedLong pname)
1340  {
1341      m_context->make_current();
1342      switch (pname) {
1343      case GL_ACTIVE_TEXTURE: {
1344          GLint result;
1345          glGetIntegerv(GL_ACTIVE_TEXTURE, &result);
1346          return JS::Value(result);
1347      }
1348      case GL_ALIASED_LINE_WIDTH_RANGE: {
1349          Array<GLfloat, 2> result;
1350          glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, result.data());
1351          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLfloat)));
1352          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1353          return JS::Float32Array::create(m_realm, 2, array_buffer);
1354      }
1355      case GL_ALIASED_POINT_SIZE_RANGE: {
1356          Array<GLfloat, 2> result;
1357          glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, result.data());
1358          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLfloat)));
1359          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1360          return JS::Float32Array::create(m_realm, 2, array_buffer);
1361      }
1362      case GL_ALPHA_BITS: {
1363          GLint result;
1364          glGetIntegerv(GL_ALPHA_BITS, &result);
1365          return JS::Value(result);
1366      }
1367      case GL_ARRAY_BUFFER_BINDING: {
1368          GLint result;
1369          glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &result);
1370          if (!result)
1371              return JS::js_null();
1372          return WebGLBuffer::create(m_realm, *this, result);
1373      }
1374      case GL_BLEND: {
1375          GLint result;
1376          glGetIntegerv(GL_BLEND, &result);
1377          return JS::Value(result);
1378      }
1379      case GL_BLEND_COLOR: {
1380          Array<GLfloat, 4> result;
1381          glGetFloatv(GL_BLEND_COLOR, result.data());
1382          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLfloat)));
1383          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1384          return JS::Float32Array::create(m_realm, 4, array_buffer);
1385      }
1386      case GL_BLEND_DST_ALPHA: {
1387          GLint result;
1388          glGetIntegerv(GL_BLEND_DST_ALPHA, &result);
1389          return JS::Value(result);
1390      }
1391      case GL_BLEND_DST_RGB: {
1392          GLint result;
1393          glGetIntegerv(GL_BLEND_DST_RGB, &result);
1394          return JS::Value(result);
1395      }
1396      case GL_BLEND_EQUATION_ALPHA: {
1397          GLint result;
1398          glGetIntegerv(GL_BLEND_EQUATION_ALPHA, &result);
1399          return JS::Value(result);
1400      }
1401      case GL_BLEND_EQUATION_RGB: {
1402          GLint result;
1403          glGetIntegerv(GL_BLEND_EQUATION_RGB, &result);
1404          return JS::Value(result);
1405      }
1406      case GL_BLEND_SRC_ALPHA: {
1407          GLint result;
1408          glGetIntegerv(GL_BLEND_SRC_ALPHA, &result);
1409          return JS::Value(result);
1410      }
1411      case GL_BLEND_SRC_RGB: {
1412          GLint result;
1413          glGetIntegerv(GL_BLEND_SRC_RGB, &result);
1414          return JS::Value(result);
1415      }
1416      case GL_BLUE_BITS: {
1417          GLint result;
1418          glGetIntegerv(GL_BLUE_BITS, &result);
1419          return JS::Value(result);
1420      }
1421      case GL_COLOR_CLEAR_VALUE: {
1422          Array<GLfloat, 4> result;
1423          glGetFloatv(GL_COLOR_CLEAR_VALUE, result.data());
1424          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLfloat)));
1425          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1426          return JS::Float32Array::create(m_realm, 4, array_buffer);
1427      }
1428      case GL_CULL_FACE: {
1429          GLint result;
1430          glGetIntegerv(GL_CULL_FACE, &result);
1431          return JS::Value(result);
1432      }
1433      case GL_CULL_FACE_MODE: {
1434          GLint result;
1435          glGetIntegerv(GL_CULL_FACE_MODE, &result);
1436          return JS::Value(result);
1437      }
1438      case GL_CURRENT_PROGRAM: {
1439          GLint result;
1440          glGetIntegerv(GL_CURRENT_PROGRAM, &result);
1441          if (!result)
1442              return JS::js_null();
1443          return WebGLProgram::create(m_realm, *this, result);
1444      }
1445      case GL_DEPTH_BITS: {
1446          GLint result;
1447          glGetIntegerv(GL_DEPTH_BITS, &result);
1448          return JS::Value(result);
1449      }
1450      case GL_DEPTH_CLEAR_VALUE: {
1451          GLint result;
1452          glGetIntegerv(GL_DEPTH_CLEAR_VALUE, &result);
1453          return JS::Value(result);
1454      }
1455      case GL_DEPTH_FUNC: {
1456          GLint result;
1457          glGetIntegerv(GL_DEPTH_FUNC, &result);
1458          return JS::Value(result);
1459      }
1460      case GL_DEPTH_RANGE: {
1461          Array<GLfloat, 2> result;
1462          glGetFloatv(GL_DEPTH_RANGE, result.data());
1463          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLfloat)));
1464          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1465          return JS::Float32Array::create(m_realm, 2, array_buffer);
1466      }
1467      case GL_DEPTH_TEST: {
1468          GLint result;
1469          glGetIntegerv(GL_DEPTH_TEST, &result);
1470          return JS::Value(result);
1471      }
1472      case GL_DEPTH_WRITEMASK: {
1473          GLint result;
1474          glGetIntegerv(GL_DEPTH_WRITEMASK, &result);
1475          return JS::Value(result);
1476      }
1477      case GL_DITHER: {
1478          GLint result;
1479          glGetIntegerv(GL_DITHER, &result);
1480          return JS::Value(result);
1481      }
1482      case GL_ELEMENT_ARRAY_BUFFER_BINDING: {
1483          GLint result;
1484          glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &result);
1485          if (!result)
1486              return JS::js_null();
1487          return WebGLBuffer::create(m_realm, *this, result);
1488      }
1489      case GL_FRAMEBUFFER_BINDING: {
1490          GLint result;
1491          glGetIntegerv(GL_FRAMEBUFFER_BINDING, &result);
1492          if (!result)
1493              return JS::js_null();
1494          return WebGLFramebuffer::create(m_realm, *this, result);
1495      }
1496      case GL_FRONT_FACE: {
1497          GLint result;
1498          glGetIntegerv(GL_FRONT_FACE, &result);
1499          return JS::Value(result);
1500      }
1501      case GL_GENERATE_MIPMAP_HINT: {
1502          GLint result;
1503          glGetIntegerv(GL_GENERATE_MIPMAP_HINT, &result);
1504          return JS::Value(result);
1505      }
1506      case GL_GREEN_BITS: {
1507          GLint result;
1508          glGetIntegerv(GL_GREEN_BITS, &result);
1509          return JS::Value(result);
1510      }
1511      case GL_IMPLEMENTATION_COLOR_READ_FORMAT: {
1512          GLint result;
1513          glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &result);
1514          return JS::Value(result);
1515      }
1516      case GL_IMPLEMENTATION_COLOR_READ_TYPE: {
1517          GLint result;
1518          glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE, &result);
1519          return JS::Value(result);
1520      }
1521      case GL_LINE_WIDTH: {
1522          GLint result;
1523          glGetIntegerv(GL_LINE_WIDTH, &result);
1524          return JS::Value(result);
1525      }
1526      case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: {
1527          GLint result;
1528          glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &result);
1529          return JS::Value(result);
1530      }
1531      case GL_MAX_CUBE_MAP_TEXTURE_SIZE: {
1532          GLint result;
1533          glGetIntegerv(GL_MAX_CUBE_MAP_TEXTURE_SIZE, &result);
1534          return JS::Value(result);
1535      }
1536      case GL_MAX_FRAGMENT_UNIFORM_VECTORS: {
1537          GLint result;
1538          glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &result);
1539          return JS::Value(result);
1540      }
1541      case GL_MAX_RENDERBUFFER_SIZE: {
1542          GLint result;
1543          glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &result);
1544          return JS::Value(result);
1545      }
1546      case GL_MAX_TEXTURE_IMAGE_UNITS: {
1547          GLint result;
1548          glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &result);
1549          return JS::Value(result);
1550      }
1551      case GL_MAX_TEXTURE_SIZE: {
1552          GLint result;
1553          glGetIntegerv(GL_MAX_TEXTURE_SIZE, &result);
1554          return JS::Value(result);
1555      }
1556      case GL_MAX_VARYING_VECTORS: {
1557          GLint result;
1558          glGetIntegerv(GL_MAX_VARYING_VECTORS, &result);
1559          return JS::Value(result);
1560      }
1561      case GL_MAX_VERTEX_ATTRIBS: {
1562          GLint result;
1563          glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &result);
1564          return JS::Value(result);
1565      }
1566      case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: {
1567          GLint result;
1568          glGetIntegerv(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, &result);
1569          return JS::Value(result);
1570      }
1571      case GL_MAX_VERTEX_UNIFORM_VECTORS: {
1572          GLint result;
1573          glGetIntegerv(GL_MAX_VERTEX_UNIFORM_VECTORS, &result);
1574          return JS::Value(result);
1575      }
1576      case GL_MAX_VIEWPORT_DIMS: {
1577          Array<GLint, 2> result;
1578          glGetIntegerv(GL_MAX_VIEWPORT_DIMS, result.data());
1579          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLint)));
1580          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1581          return JS::Int32Array::create(m_realm, 2, array_buffer);
1582      }
1583      case GL_PACK_ALIGNMENT: {
1584          GLint result;
1585          glGetIntegerv(GL_PACK_ALIGNMENT, &result);
1586          return JS::Value(result);
1587      }
1588      case GL_POLYGON_OFFSET_FACTOR: {
1589          GLint result;
1590          glGetIntegerv(GL_POLYGON_OFFSET_FACTOR, &result);
1591          return JS::Value(result);
1592      }
1593      case GL_POLYGON_OFFSET_FILL: {
1594          GLint result;
1595          glGetIntegerv(GL_POLYGON_OFFSET_FILL, &result);
1596          return JS::Value(result);
1597      }
1598      case GL_POLYGON_OFFSET_UNITS: {
1599          GLint result;
1600          glGetIntegerv(GL_POLYGON_OFFSET_UNITS, &result);
1601          return JS::Value(result);
1602      }
1603      case GL_RED_BITS: {
1604          GLint result;
1605          glGetIntegerv(GL_RED_BITS, &result);
1606          return JS::Value(result);
1607      }
1608      case GL_RENDERBUFFER_BINDING: {
1609          GLint result;
1610          glGetIntegerv(GL_RENDERBUFFER_BINDING, &result);
1611          if (!result)
1612              return JS::js_null();
1613          return WebGLRenderbuffer::create(m_realm, *this, result);
1614      }
1615      case GL_RENDERER: {
1616          auto result = reinterpret_cast<const char*>(glGetString(GL_RENDERER));
1617          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1618      case GL_SAMPLE_ALPHA_TO_COVERAGE: {
1619          GLint result;
1620          glGetIntegerv(GL_SAMPLE_ALPHA_TO_COVERAGE, &result);
1621          return JS::Value(result);
1622      }
1623      case GL_SAMPLE_BUFFERS: {
1624          GLint result;
1625          glGetIntegerv(GL_SAMPLE_BUFFERS, &result);
1626          return JS::Value(result);
1627      }
1628      case GL_SAMPLE_COVERAGE: {
1629          GLint result;
1630          glGetIntegerv(GL_SAMPLE_COVERAGE, &result);
1631          return JS::Value(result);
1632      }
1633      case GL_SAMPLE_COVERAGE_INVERT: {
1634          GLint result;
1635          glGetIntegerv(GL_SAMPLE_COVERAGE_INVERT, &result);
1636          return JS::Value(result);
1637      }
1638      case GL_SAMPLE_COVERAGE_VALUE: {
1639          GLint result;
1640          glGetIntegerv(GL_SAMPLE_COVERAGE_VALUE, &result);
1641          return JS::Value(result);
1642      }
1643      case GL_SAMPLES: {
1644          GLint result;
1645          glGetIntegerv(GL_SAMPLES, &result);
1646          return JS::Value(result);
1647      }
1648      case GL_SCISSOR_BOX: {
1649          Array<GLint, 4> result;
1650          glGetIntegerv(GL_SCISSOR_BOX, result.data());
1651          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLint)));
1652          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1653          return JS::Int32Array::create(m_realm, 4, array_buffer);
1654      }
1655      case GL_SCISSOR_TEST: {
1656          GLint result;
1657          glGetIntegerv(GL_SCISSOR_TEST, &result);
1658          return JS::Value(result);
1659      }
1660      case GL_SHADING_LANGUAGE_VERSION: {
1661          auto result = reinterpret_cast<const char*>(glGetString(GL_SHADING_LANGUAGE_VERSION));
1662          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1663      case GL_STENCIL_BACK_FAIL: {
1664          GLint result;
1665          glGetIntegerv(GL_STENCIL_BACK_FAIL, &result);
1666          return JS::Value(result);
1667      }
1668      case GL_STENCIL_BACK_FUNC: {
1669          GLint result;
1670          glGetIntegerv(GL_STENCIL_BACK_FUNC, &result);
1671          return JS::Value(result);
1672      }
1673      case GL_STENCIL_BACK_PASS_DEPTH_FAIL: {
1674          GLint result;
1675          glGetIntegerv(GL_STENCIL_BACK_PASS_DEPTH_FAIL, &result);
1676          return JS::Value(result);
1677      }
1678      case GL_STENCIL_BACK_PASS_DEPTH_PASS: {
1679          GLint result;
1680          glGetIntegerv(GL_STENCIL_BACK_PASS_DEPTH_PASS, &result);
1681          return JS::Value(result);
1682      }
1683      case GL_STENCIL_BACK_REF: {
1684          GLint result;
1685          glGetIntegerv(GL_STENCIL_BACK_REF, &result);
1686          return JS::Value(result);
1687      }
1688      case GL_STENCIL_BACK_VALUE_MASK: {
1689          GLint result;
1690          glGetIntegerv(GL_STENCIL_BACK_VALUE_MASK, &result);
1691          return JS::Value(result);
1692      }
1693      case GL_STENCIL_BACK_WRITEMASK: {
1694          GLint result;
1695          glGetIntegerv(GL_STENCIL_BACK_WRITEMASK, &result);
1696          return JS::Value(result);
1697      }
1698      case GL_STENCIL_BITS: {
1699          GLint result;
1700          glGetIntegerv(GL_STENCIL_BITS, &result);
1701          return JS::Value(result);
1702      }
1703      case GL_STENCIL_CLEAR_VALUE: {
1704          GLint result;
1705          glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &result);
1706          return JS::Value(result);
1707      }
1708      case GL_STENCIL_FAIL: {
1709          GLint result;
1710          glGetIntegerv(GL_STENCIL_FAIL, &result);
1711          return JS::Value(result);
1712      }
1713      case GL_STENCIL_FUNC: {
1714          GLint result;
1715          glGetIntegerv(GL_STENCIL_FUNC, &result);
1716          return JS::Value(result);
1717      }
1718      case GL_STENCIL_PASS_DEPTH_FAIL: {
1719          GLint result;
1720          glGetIntegerv(GL_STENCIL_PASS_DEPTH_FAIL, &result);
1721          return JS::Value(result);
1722      }
1723      case GL_STENCIL_PASS_DEPTH_PASS: {
1724          GLint result;
1725          glGetIntegerv(GL_STENCIL_PASS_DEPTH_PASS, &result);
1726          return JS::Value(result);
1727      }
1728      case GL_STENCIL_REF: {
1729          GLint result;
1730          glGetIntegerv(GL_STENCIL_REF, &result);
1731          return JS::Value(result);
1732      }
1733      case GL_STENCIL_TEST: {
1734          GLint result;
1735          glGetIntegerv(GL_STENCIL_TEST, &result);
1736          return JS::Value(result);
1737      }
1738      case GL_STENCIL_VALUE_MASK: {
1739          GLint result;
1740          glGetIntegerv(GL_STENCIL_VALUE_MASK, &result);
1741          return JS::Value(result);
1742      }
1743      case GL_STENCIL_WRITEMASK: {
1744          GLint result;
1745          glGetIntegerv(GL_STENCIL_WRITEMASK, &result);
1746          return JS::Value(result);
1747      }
1748      case GL_SUBPIXEL_BITS: {
1749          GLint result;
1750          glGetIntegerv(GL_SUBPIXEL_BITS, &result);
1751          return JS::Value(result);
1752      }
1753      case GL_TEXTURE_BINDING_2D: {
1754          GLint result;
1755          glGetIntegerv(GL_TEXTURE_BINDING_2D, &result);
1756          if (!result)
1757              return JS::js_null();
1758          return WebGLTexture::create(m_realm, *this, result);
1759      }
1760      case GL_TEXTURE_BINDING_CUBE_MAP: {
1761          GLint result;
1762          glGetIntegerv(GL_TEXTURE_BINDING_CUBE_MAP, &result);
1763          if (!result)
1764              return JS::js_null();
1765          return WebGLTexture::create(m_realm, *this, result);
1766      }
1767      case GL_UNPACK_ALIGNMENT: {
1768          GLint result;
1769          glGetIntegerv(GL_UNPACK_ALIGNMENT, &result);
1770          return JS::Value(result);
1771      }
1772      case GL_VENDOR: {
1773          auto result = reinterpret_cast<const char*>(glGetString(GL_VENDOR));
1774          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1775      case GL_VERSION: {
1776          auto result = reinterpret_cast<const char*>(glGetString(GL_VERSION));
1777          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1778      case GL_VIEWPORT: {
1779          Array<GLint, 4> result;
1780          glGetIntegerv(GL_VIEWPORT, result.data());
1781          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLint)));
1782          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1783          return JS::Int32Array::create(m_realm, 4, array_buffer);
1784      }
1785      case GL_MAX_SAMPLES: {
1786          GLint result;
1787          glGetIntegerv(GL_MAX_SAMPLES, &result);
1788          return JS::Value(result);
1789      }
1790      case GL_MAX_3D_TEXTURE_SIZE: {
1791          GLint result;
1792          glGetIntegerv(GL_MAX_3D_TEXTURE_SIZE, &result);
1793          return JS::Value(result);
1794      }
1795      case GL_MAX_ARRAY_TEXTURE_LAYERS: {
1796          GLint result;
1797          glGetIntegerv(GL_MAX_ARRAY_TEXTURE_LAYERS, &result);
1798          return JS::Value(result);
1799      }
1800      case GL_MAX_COLOR_ATTACHMENTS: {
1801          GLint result;
1802          glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS, &result);
1803          return JS::Value(result);
1804      }
1805      case GL_MAX_VERTEX_UNIFORM_COMPONENTS: {
1806          GLint result;
1807          glGetIntegerv(GL_MAX_VERTEX_UNIFORM_COMPONENTS, &result);
1808          return JS::Value(result);
1809      }
1810      case GL_MAX_UNIFORM_BLOCK_SIZE: {
1811          GLint64 result;
1812          glGetInteger64v(GL_MAX_UNIFORM_BLOCK_SIZE, &result);
1813          return JS::Value(static_cast<double>(result));
1814      }
1815      case GL_MAX_UNIFORM_BUFFER_BINDINGS: {
1816          GLint result;
1817          glGetIntegerv(GL_MAX_UNIFORM_BUFFER_BINDINGS, &result);
1818          return JS::Value(result);
1819      }
1820      case GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT: {
1821          GLint result;
1822          glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &result);
1823          return JS::Value(result);
1824      }
1825      case GL_MAX_DRAW_BUFFERS: {
1826          GLint result;
1827          glGetIntegerv(GL_MAX_DRAW_BUFFERS, &result);
1828          return JS::Value(result);
1829      }
1830      case GL_MAX_VERTEX_UNIFORM_BLOCKS: {
1831          GLint result;
1832          glGetIntegerv(GL_MAX_VERTEX_UNIFORM_BLOCKS, &result);
1833          return JS::Value(result);
1834      }
1835      case GL_MAX_FRAGMENT_INPUT_COMPONENTS: {
1836          GLint result;
1837          glGetIntegerv(GL_MAX_FRAGMENT_INPUT_COMPONENTS, &result);
1838          return JS::Value(result);
1839      }
1840      case GL_MAX_COMBINED_UNIFORM_BLOCKS: {
1841          GLint result;
1842          glGetIntegerv(GL_MAX_COMBINED_UNIFORM_BLOCKS, &result);
1843          return JS::Value(result);
1844      }
1845      default:
1846          dbgln("Unknown WebGL parameter name: {:x}", pname);
1847          set_error(GL_INVALID_ENUM);
1848          return JS::js_null();
1849      }
1850  }
1851  
1852  WebIDL::UnsignedLong WebGL2RenderingContextImpl::get_error()
1853  {
1854      m_context->make_current();
1855      return glGetError();
1856  }
1857  
1858  JS::Value WebGL2RenderingContextImpl::get_program_parameter(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong pname)
1859  {
1860      m_context->make_current();
1861  
1862      GLuint program_handle = 0;
1863      if (program) {
1864          auto handle_or_error = program->handle(this);
1865          if (handle_or_error.is_error()) {
1866              set_error(GL_INVALID_OPERATION);
1867              return JS::js_null();
1868          }
1869          program_handle = handle_or_error.release_value();
1870      }
1871  
1872      GLint result = 0;
1873      glGetProgramiv(program_handle, pname, &result);
1874      return JS::Value(result);
1875  }
1876  
1877  Optional<String> WebGL2RenderingContextImpl::get_program_info_log(GC::Root<WebGLProgram> program)
1878  {
1879      m_context->make_current();
1880  
1881      GLuint program_handle = 0;
1882      if (program) {
1883          auto handle_or_error = program->handle(this);
1884          if (handle_or_error.is_error()) {
1885              set_error(GL_INVALID_OPERATION);
1886              return {};
1887          }
1888          program_handle = handle_or_error.release_value();
1889      }
1890  
1891      GLint info_log_length = 0;
1892      glGetProgramiv(program_handle, GL_INFO_LOG_LENGTH, &info_log_length);
1893      Vector<GLchar> info_log;
1894      info_log.resize(info_log_length);
1895      if (!info_log_length)
1896          return String {};
1897      glGetProgramInfoLog(program_handle, info_log_length, nullptr, info_log.data());
1898      return String::from_utf8_without_validation(ReadonlyBytes { info_log.data(), static_cast<size_t>(info_log_length - 1) });
1899  }
1900  
1901  JS::Value WebGL2RenderingContextImpl::get_shader_parameter(GC::Root<WebGLShader> shader, WebIDL::UnsignedLong pname)
1902  {
1903      m_context->make_current();
1904  
1905      GLuint shader_handle = 0;
1906      if (shader) {
1907          auto handle_or_error = shader->handle(this);
1908          if (handle_or_error.is_error()) {
1909              set_error(GL_INVALID_OPERATION);
1910              return JS::js_null();
1911          }
1912          shader_handle = handle_or_error.release_value();
1913      }
1914  
1915      GLint result = 0;
1916      glGetShaderiv(shader_handle, pname, &result);
1917      return JS::Value(result);
1918  }
1919  
1920  GC::Root<WebGLShaderPrecisionFormat> WebGL2RenderingContextImpl::get_shader_precision_format(WebIDL::UnsignedLong shadertype, WebIDL::UnsignedLong precisiontype)
1921  {
1922      m_context->make_current();
1923  
1924      GLint range[2];
1925      GLint precision;
1926      glGetShaderPrecisionFormat(shadertype, precisiontype, range, &precision);
1927      return WebGLShaderPrecisionFormat::create(m_realm, range[0], range[1], precision);
1928  }
1929  
1930  Optional<String> WebGL2RenderingContextImpl::get_shader_info_log(GC::Root<WebGLShader> shader)
1931  {
1932      m_context->make_current();
1933  
1934      GLuint shader_handle = 0;
1935      if (shader) {
1936          auto handle_or_error = shader->handle(this);
1937          if (handle_or_error.is_error()) {
1938              set_error(GL_INVALID_OPERATION);
1939              return {};
1940          }
1941          shader_handle = handle_or_error.release_value();
1942      }
1943  
1944      GLint info_log_length = 0;
1945      glGetShaderiv(shader_handle, GL_INFO_LOG_LENGTH, &info_log_length);
1946      Vector<GLchar> info_log;
1947      info_log.resize(info_log_length);
1948      if (!info_log_length)
1949          return String {};
1950      glGetShaderInfoLog(shader_handle, info_log_length, nullptr, info_log.data());
1951      return String::from_utf8_without_validation(ReadonlyBytes { info_log.data(), static_cast<size_t>(info_log_length - 1) });
1952  }
1953  
1954  GC::Root<WebGLUniformLocation> WebGL2RenderingContextImpl::get_uniform_location(GC::Root<WebGLProgram> program, String name)
1955  {
1956      m_context->make_current();
1957  
1958      GLuint program_handle = 0;
1959      if (program) {
1960          auto handle_or_error = program->handle(this);
1961          if (handle_or_error.is_error()) {
1962              set_error(GL_INVALID_OPERATION);
1963              return {};
1964          }
1965          program_handle = handle_or_error.release_value();
1966      }
1967  
1968      auto name_null_terminated = null_terminated_string(name);
1969      return WebGLUniformLocation::create(m_realm, glGetUniformLocation(program_handle, name_null_terminated.data()));
1970  }
1971  
1972  void WebGL2RenderingContextImpl::hint(WebIDL::UnsignedLong target, WebIDL::UnsignedLong mode)
1973  {
1974      m_context->make_current();
1975      glHint(target, mode);
1976  }
1977  
1978  bool WebGL2RenderingContextImpl::is_buffer(GC::Root<WebGLBuffer> buffer)
1979  {
1980      m_context->make_current();
1981  
1982      auto buffer_handle = 0;
1983      if (buffer) {
1984          auto handle_or_error = buffer->handle(this);
1985          if (handle_or_error.is_error()) {
1986              set_error(GL_INVALID_OPERATION);
1987              return false;
1988          }
1989          buffer_handle = handle_or_error.release_value();
1990      }
1991      return glIsBuffer(buffer_handle);
1992  }
1993  
1994  bool WebGL2RenderingContextImpl::is_enabled(WebIDL::UnsignedLong cap)
1995  {
1996      m_context->make_current();
1997      return glIsEnabled(cap);
1998  }
1999  
2000  bool WebGL2RenderingContextImpl::is_framebuffer(GC::Root<WebGLFramebuffer> framebuffer)
2001  {
2002      m_context->make_current();
2003  
2004      auto framebuffer_handle = 0;
2005      if (framebuffer) {
2006          auto handle_or_error = framebuffer->handle(this);
2007          if (handle_or_error.is_error()) {
2008              set_error(GL_INVALID_OPERATION);
2009              return false;
2010          }
2011          framebuffer_handle = handle_or_error.release_value();
2012      }
2013      return glIsFramebuffer(framebuffer_handle);
2014  }
2015  
2016  bool WebGL2RenderingContextImpl::is_program(GC::Root<WebGLProgram> program)
2017  {
2018      m_context->make_current();
2019  
2020      auto program_handle = 0;
2021      if (program) {
2022          auto handle_or_error = program->handle(this);
2023          if (handle_or_error.is_error()) {
2024              set_error(GL_INVALID_OPERATION);
2025              return false;
2026          }
2027          program_handle = handle_or_error.release_value();
2028      }
2029      return glIsProgram(program_handle);
2030  }
2031  
2032  bool WebGL2RenderingContextImpl::is_renderbuffer(GC::Root<WebGLRenderbuffer> renderbuffer)
2033  {
2034      m_context->make_current();
2035  
2036      auto renderbuffer_handle = 0;
2037      if (renderbuffer) {
2038          auto handle_or_error = renderbuffer->handle(this);
2039          if (handle_or_error.is_error()) {
2040              set_error(GL_INVALID_OPERATION);
2041              return false;
2042          }
2043          renderbuffer_handle = handle_or_error.release_value();
2044      }
2045      return glIsRenderbuffer(renderbuffer_handle);
2046  }
2047  
2048  bool WebGL2RenderingContextImpl::is_shader(GC::Root<WebGLShader> shader)
2049  {
2050      m_context->make_current();
2051  
2052      auto shader_handle = 0;
2053      if (shader) {
2054          auto handle_or_error = shader->handle(this);
2055          if (handle_or_error.is_error()) {
2056              set_error(GL_INVALID_OPERATION);
2057              return false;
2058          }
2059          shader_handle = handle_or_error.release_value();
2060      }
2061      return glIsShader(shader_handle);
2062  }
2063  
2064  bool WebGL2RenderingContextImpl::is_texture(GC::Root<WebGLTexture> texture)
2065  {
2066      m_context->make_current();
2067  
2068      auto texture_handle = 0;
2069      if (texture) {
2070          auto handle_or_error = texture->handle(this);
2071          if (handle_or_error.is_error()) {
2072              set_error(GL_INVALID_OPERATION);
2073              return false;
2074          }
2075          texture_handle = handle_or_error.release_value();
2076      }
2077      return glIsTexture(texture_handle);
2078  }
2079  
2080  void WebGL2RenderingContextImpl::line_width(float width)
2081  {
2082      m_context->make_current();
2083      glLineWidth(width);
2084  }
2085  
2086  void WebGL2RenderingContextImpl::link_program(GC::Root<WebGLProgram> program)
2087  {
2088      m_context->make_current();
2089  
2090      auto program_handle = 0;
2091      if (program) {
2092          auto handle_or_error = program->handle(this);
2093          if (handle_or_error.is_error()) {
2094              set_error(GL_INVALID_OPERATION);
2095              return ;
2096          }
2097          program_handle = handle_or_error.release_value();
2098      }
2099      glLinkProgram(program_handle);
2100  }
2101  
2102  void WebGL2RenderingContextImpl::pixel_storei(WebIDL::UnsignedLong pname, WebIDL::Long param)
2103  {
2104      m_context->make_current();
2105      glPixelStorei(pname, param);
2106  }
2107  
2108  void WebGL2RenderingContextImpl::polygon_offset(float factor, float units)
2109  {
2110      m_context->make_current();
2111      glPolygonOffset(factor, units);
2112  }
2113  
2114  void WebGL2RenderingContextImpl::renderbuffer_storage(WebIDL::UnsignedLong target, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height)
2115  {
2116      m_context->make_current();
2117      glRenderbufferStorage(target, internalformat, width, height);
2118  }
2119  
2120  void WebGL2RenderingContextImpl::sample_coverage(float value, bool invert)
2121  {
2122      m_context->make_current();
2123      glSampleCoverage(value, invert);
2124  }
2125  
2126  void WebGL2RenderingContextImpl::scissor(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height)
2127  {
2128      m_context->make_current();
2129      glScissor(x, y, width, height);
2130  }
2131  
2132  void WebGL2RenderingContextImpl::shader_source(GC::Root<WebGLShader> shader, String source)
2133  {
2134      m_context->make_current();
2135  
2136      GLuint shader_handle = 0;
2137      if (shader) {
2138          auto handle_or_error = shader->handle(this);
2139          if (handle_or_error.is_error()) {
2140              set_error(GL_INVALID_OPERATION);
2141              return ;
2142          }
2143          shader_handle = handle_or_error.release_value();
2144      }
2145  
2146      Vector<GLchar*> strings;
2147      auto string = null_terminated_string(source);
2148      strings.append(string.data());
2149      Vector<GLint> length;
2150      length.append(source.bytes().size());
2151      glShaderSource(shader_handle, 1, strings.data(), length.data());
2152  }
2153  
2154  void WebGL2RenderingContextImpl::stencil_func(WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask)
2155  {
2156      m_context->make_current();
2157      glStencilFunc(func, ref, mask);
2158  }
2159  
2160  void WebGL2RenderingContextImpl::stencil_func_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask)
2161  {
2162      m_context->make_current();
2163      glStencilFuncSeparate(face, func, ref, mask);
2164  }
2165  
2166  void WebGL2RenderingContextImpl::stencil_mask(WebIDL::UnsignedLong mask)
2167  {
2168      m_context->make_current();
2169      glStencilMask(mask);
2170  }
2171  
2172  void WebGL2RenderingContextImpl::stencil_mask_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong mask)
2173  {
2174      m_context->make_current();
2175      glStencilMaskSeparate(face, mask);
2176  }
2177  
2178  void WebGL2RenderingContextImpl::stencil_op(WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass)
2179  {
2180      m_context->make_current();
2181      glStencilOp(fail, zfail, zpass);
2182  }
2183  
2184  void WebGL2RenderingContextImpl::stencil_op_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass)
2185  {
2186      m_context->make_current();
2187      glStencilOpSeparate(face, fail, zfail, zpass);
2188  }
2189  
2190  void WebGL2RenderingContextImpl::tex_parameterf(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, float param)
2191  {
2192      m_context->make_current();
2193      glTexParameterf(target, pname, param);
2194  }
2195  
2196  void WebGL2RenderingContextImpl::tex_parameteri(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, WebIDL::Long param)
2197  {
2198      m_context->make_current();
2199      glTexParameteri(target, pname, param);
2200  }
2201  
2202  void WebGL2RenderingContextImpl::uniform1f(GC::Root<WebGLUniformLocation> location, float x)
2203  {
2204      m_context->make_current();
2205      glUniform1f(location ? location->handle() : 0, x);
2206  }
2207  
2208  void WebGL2RenderingContextImpl::uniform2f(GC::Root<WebGLUniformLocation> location, float x, float y)
2209  {
2210      m_context->make_current();
2211      glUniform2f(location ? location->handle() : 0, x, y);
2212  }
2213  
2214  void WebGL2RenderingContextImpl::uniform3f(GC::Root<WebGLUniformLocation> location, float x, float y, float z)
2215  {
2216      m_context->make_current();
2217      glUniform3f(location ? location->handle() : 0, x, y, z);
2218  }
2219  
2220  void WebGL2RenderingContextImpl::uniform4f(GC::Root<WebGLUniformLocation> location, float x, float y, float z, float w)
2221  {
2222      m_context->make_current();
2223      glUniform4f(location ? location->handle() : 0, x, y, z, w);
2224  }
2225  
2226  void WebGL2RenderingContextImpl::uniform1i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x)
2227  {
2228      m_context->make_current();
2229      glUniform1i(location ? location->handle() : 0, x);
2230  }
2231  
2232  void WebGL2RenderingContextImpl::uniform2i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y)
2233  {
2234      m_context->make_current();
2235      glUniform2i(location ? location->handle() : 0, x, y);
2236  }
2237  
2238  void WebGL2RenderingContextImpl::uniform3i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z)
2239  {
2240      m_context->make_current();
2241      glUniform3i(location ? location->handle() : 0, x, y, z);
2242  }
2243  
2244  void WebGL2RenderingContextImpl::uniform4i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z, WebIDL::Long w)
2245  {
2246      m_context->make_current();
2247      glUniform4i(location ? location->handle() : 0, x, y, z, w);
2248  }
2249  
2250  void WebGL2RenderingContextImpl::use_program(GC::Root<WebGLProgram> program)
2251  {
2252      m_context->make_current();
2253  
2254      auto program_handle = 0;
2255      if (program) {
2256          auto handle_or_error = program->handle(this);
2257          if (handle_or_error.is_error()) {
2258              set_error(GL_INVALID_OPERATION);
2259              return ;
2260          }
2261          program_handle = handle_or_error.release_value();
2262      }
2263      glUseProgram(program_handle);
2264  }
2265  
2266  void WebGL2RenderingContextImpl::validate_program(GC::Root<WebGLProgram> program)
2267  {
2268      m_context->make_current();
2269  
2270      auto program_handle = 0;
2271      if (program) {
2272          auto handle_or_error = program->handle(this);
2273          if (handle_or_error.is_error()) {
2274              set_error(GL_INVALID_OPERATION);
2275              return ;
2276          }
2277          program_handle = handle_or_error.release_value();
2278      }
2279      glValidateProgram(program_handle);
2280  }
2281  
2282  void WebGL2RenderingContextImpl::vertex_attrib1f(WebIDL::UnsignedLong index, float x)
2283  {
2284      m_context->make_current();
2285      glVertexAttrib1f(index, x);
2286  }
2287  
2288  void WebGL2RenderingContextImpl::vertex_attrib2f(WebIDL::UnsignedLong index, float x, float y)
2289  {
2290      m_context->make_current();
2291      glVertexAttrib2f(index, x, y);
2292  }
2293  
2294  void WebGL2RenderingContextImpl::vertex_attrib3f(WebIDL::UnsignedLong index, float x, float y, float z)
2295  {
2296      m_context->make_current();
2297      glVertexAttrib3f(index, x, y, z);
2298  }
2299  
2300  void WebGL2RenderingContextImpl::vertex_attrib4f(WebIDL::UnsignedLong index, float x, float y, float z, float w)
2301  {
2302      m_context->make_current();
2303      glVertexAttrib4f(index, x, y, z, w);
2304  }
2305  
2306  void WebGL2RenderingContextImpl::vertex_attrib1fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
2307  {
2308      m_context->make_current();
2309  
2310      if (values.has<Vector<float>>()) {
2311          auto& data = values.get<Vector<float>>();
2312          glVertexAttrib1fv(index, data.data());
2313          return;
2314      }
2315  
2316      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
2317      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
2318      float const* data = float32_array.data().data();
2319      glVertexAttrib1fv(index, data);
2320  }
2321  
2322  void WebGL2RenderingContextImpl::vertex_attrib2fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
2323  {
2324      m_context->make_current();
2325  
2326      if (values.has<Vector<float>>()) {
2327          auto& data = values.get<Vector<float>>();
2328          glVertexAttrib2fv(index, data.data());
2329          return;
2330      }
2331  
2332      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
2333      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
2334      float const* data = float32_array.data().data();
2335      glVertexAttrib2fv(index, data);
2336  }
2337  
2338  void WebGL2RenderingContextImpl::vertex_attrib3fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
2339  {
2340      m_context->make_current();
2341  
2342      if (values.has<Vector<float>>()) {
2343          auto& data = values.get<Vector<float>>();
2344          glVertexAttrib3fv(index, data.data());
2345          return;
2346      }
2347  
2348      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
2349      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
2350      float const* data = float32_array.data().data();
2351      glVertexAttrib3fv(index, data);
2352  }
2353  
2354  void WebGL2RenderingContextImpl::vertex_attrib4fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
2355  {
2356      m_context->make_current();
2357  
2358      if (values.has<Vector<float>>()) {
2359          auto& data = values.get<Vector<float>>();
2360          glVertexAttrib4fv(index, data.data());
2361          return;
2362      }
2363  
2364      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
2365      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
2366      float const* data = float32_array.data().data();
2367      glVertexAttrib4fv(index, data);
2368  }
2369  
2370  void WebGL2RenderingContextImpl::vertex_attrib_pointer(WebIDL::UnsignedLong index, WebIDL::Long size, WebIDL::UnsignedLong type, bool normalized, WebIDL::Long stride, WebIDL::LongLong offset)
2371  {
2372      m_context->make_current();
2373  
2374      glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast<void*>(offset));
2375  }
2376  
2377  void WebGL2RenderingContextImpl::viewport(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height)
2378  {
2379      m_context->make_current();
2380      glViewport(x, y, width, height);
2381  }
2382  
2383  }
</document_content>
</document>
<document index="50">
<source>./LadybirdBuild/WebGLRenderingContextImpl.h</source>
<document_content>
  1  
  2  #pragma once
  3  
  4  #include <AK/NonnullOwnPtr.h>
  5  #include <LibGC/Ptr.h>
  6  #include <LibGfx/Bitmap.h>
  7  #include <LibWeb/Bindings/PlatformObject.h>
  8  #include <LibWeb/Forward.h>
  9  #include <LibWeb/WebGL/WebGLRenderingContextBase.h>
 10  #include <LibWeb/WebIDL/Types.h>
 11  
 12  namespace Web::WebGL {
 13  
 14  using namespace Web::HTML;
 15  
 16  class WebGLRenderingContextImpl : public WebGLRenderingContextBase {
 17  public:
 18      WebGLRenderingContextImpl(JS::Realm&, NonnullOwnPtr<OpenGLContext>);
 19  
 20      OpenGLContext& context() { return *m_context; }
 21  
 22      virtual void present() = 0;
 23      virtual void needs_to_present() = 0;
 24      virtual void set_error(GLenum) = 0;
 25      void buffer_data(WebIDL::UnsignedLong target, WebIDL::LongLong size, WebIDL::UnsignedLong usage);
 26      void buffer_data(WebIDL::UnsignedLong target, GC::Root<WebIDL::BufferSource> data, WebIDL::UnsignedLong usage);
 27      void buffer_sub_data(WebIDL::UnsignedLong target, WebIDL::LongLong offset, GC::Root<WebIDL::BufferSource> data);
 28      void read_pixels(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels);
 29      void tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels);
 30      void tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, Variant<GC::Root<ImageBitmap>, GC::Root<ImageData>, GC::Root<HTMLImageElement>, GC::Root<HTMLCanvasElement>, GC::Root<HTMLVideoElement>> source);
 31      void tex_sub_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels);
 32      void uniform1fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v);
 33      void uniform2fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v);
 34      void uniform3fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v);
 35      void uniform4fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v);
 36      void uniform1iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v);
 37      void uniform2iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v);
 38      void uniform3iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v);
 39      void uniform4iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v);
 40      void uniform_matrix2fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> value);
 41      void uniform_matrix3fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> value);
 42      void uniform_matrix4fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> value);
 43      void active_texture(WebIDL::UnsignedLong texture);
 44      void attach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader);
 45      void bind_attrib_location(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index, String name);
 46      void bind_buffer(WebIDL::UnsignedLong target, GC::Root<WebGLBuffer> buffer);
 47      void bind_framebuffer(WebIDL::UnsignedLong target, GC::Root<WebGLFramebuffer> framebuffer);
 48      void bind_renderbuffer(WebIDL::UnsignedLong target, GC::Root<WebGLRenderbuffer> renderbuffer);
 49      void bind_texture(WebIDL::UnsignedLong target, GC::Root<WebGLTexture> texture);
 50      void blend_color(float red, float green, float blue, float alpha);
 51      void blend_equation(WebIDL::UnsignedLong mode);
 52      void blend_equation_separate(WebIDL::UnsignedLong mode_rgb, WebIDL::UnsignedLong mode_alpha);
 53      void blend_func(WebIDL::UnsignedLong sfactor, WebIDL::UnsignedLong dfactor);
 54      void blend_func_separate(WebIDL::UnsignedLong src_rgb, WebIDL::UnsignedLong dst_rgb, WebIDL::UnsignedLong src_alpha, WebIDL::UnsignedLong dst_alpha);
 55      WebIDL::UnsignedLong check_framebuffer_status(WebIDL::UnsignedLong target);
 56      void clear(WebIDL::UnsignedLong mask);
 57      void clear_color(float red, float green, float blue, float alpha);
 58      void clear_depth(float depth);
 59      void clear_stencil(WebIDL::Long s);
 60      void color_mask(bool red, bool green, bool blue, bool alpha);
 61      void compile_shader(GC::Root<WebGLShader> shader);
 62      GC::Root<WebGLBuffer> create_buffer();
 63      GC::Root<WebGLFramebuffer> create_framebuffer();
 64      GC::Root<WebGLProgram> create_program();
 65      GC::Root<WebGLRenderbuffer> create_renderbuffer();
 66      GC::Root<WebGLShader> create_shader(WebIDL::UnsignedLong type);
 67      GC::Root<WebGLTexture> create_texture();
 68      void cull_face(WebIDL::UnsignedLong mode);
 69      void delete_buffer(GC::Root<WebGLBuffer> buffer);
 70      void delete_framebuffer(GC::Root<WebGLFramebuffer> framebuffer);
 71      void delete_program(GC::Root<WebGLProgram> program);
 72      void delete_shader(GC::Root<WebGLShader> shader);
 73      void delete_texture(GC::Root<WebGLTexture> texture);
 74      void depth_func(WebIDL::UnsignedLong func);
 75      void depth_mask(bool flag);
 76      void depth_range(float z_near, float z_far);
 77      void detach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader);
 78      void disable(WebIDL::UnsignedLong cap);
 79      void disable_vertex_attrib_array(WebIDL::UnsignedLong index);
 80      void draw_arrays(WebIDL::UnsignedLong mode, WebIDL::Long first, WebIDL::Long count);
 81      void draw_elements(WebIDL::UnsignedLong mode, WebIDL::Long count, WebIDL::UnsignedLong type, WebIDL::LongLong offset);
 82      void enable(WebIDL::UnsignedLong cap);
 83      void enable_vertex_attrib_array(WebIDL::UnsignedLong index);
 84      void finish();
 85      void flush();
 86      void framebuffer_renderbuffer(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong renderbuffertarget, GC::Root<WebGLRenderbuffer> renderbuffer);
 87      void framebuffer_texture2d(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong textarget, GC::Root<WebGLTexture> texture, WebIDL::Long level);
 88      void front_face(WebIDL::UnsignedLong mode);
 89      void generate_mipmap(WebIDL::UnsignedLong target);
 90      GC::Root<WebGLActiveInfo> get_active_attrib(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index);
 91      GC::Root<WebGLActiveInfo> get_active_uniform(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index);
 92      WebIDL::Long get_attrib_location(GC::Root<WebGLProgram> program, String name);
 93      JS::Value get_buffer_parameter(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname);
 94      JS::Value get_parameter(WebIDL::UnsignedLong pname);
 95      WebIDL::UnsignedLong get_error();
 96      JS::Value get_program_parameter(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong pname);
 97      Optional<String> get_program_info_log(GC::Root<WebGLProgram> program);
 98      JS::Value get_shader_parameter(GC::Root<WebGLShader> shader, WebIDL::UnsignedLong pname);
 99      GC::Root<WebGLShaderPrecisionFormat> get_shader_precision_format(WebIDL::UnsignedLong shadertype, WebIDL::UnsignedLong precisiontype);
100      Optional<String> get_shader_info_log(GC::Root<WebGLShader> shader);
101      GC::Root<WebGLUniformLocation> get_uniform_location(GC::Root<WebGLProgram> program, String name);
102      void hint(WebIDL::UnsignedLong target, WebIDL::UnsignedLong mode);
103      bool is_buffer(GC::Root<WebGLBuffer> buffer);
104      bool is_enabled(WebIDL::UnsignedLong cap);
105      bool is_framebuffer(GC::Root<WebGLFramebuffer> framebuffer);
106      bool is_program(GC::Root<WebGLProgram> program);
107      bool is_renderbuffer(GC::Root<WebGLRenderbuffer> renderbuffer);
108      bool is_shader(GC::Root<WebGLShader> shader);
109      bool is_texture(GC::Root<WebGLTexture> texture);
110      void line_width(float width);
111      void link_program(GC::Root<WebGLProgram> program);
112      void pixel_storei(WebIDL::UnsignedLong pname, WebIDL::Long param);
113      void polygon_offset(float factor, float units);
114      void renderbuffer_storage(WebIDL::UnsignedLong target, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height);
115      void sample_coverage(float value, bool invert);
116      void scissor(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height);
117      void shader_source(GC::Root<WebGLShader> shader, String source);
118      void stencil_func(WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask);
119      void stencil_func_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask);
120      void stencil_mask(WebIDL::UnsignedLong mask);
121      void stencil_mask_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong mask);
122      void stencil_op(WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass);
123      void stencil_op_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass);
124      void tex_parameterf(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, float param);
125      void tex_parameteri(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, WebIDL::Long param);
126      void uniform1f(GC::Root<WebGLUniformLocation> location, float x);
127      void uniform2f(GC::Root<WebGLUniformLocation> location, float x, float y);
128      void uniform3f(GC::Root<WebGLUniformLocation> location, float x, float y, float z);
129      void uniform4f(GC::Root<WebGLUniformLocation> location, float x, float y, float z, float w);
130      void uniform1i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x);
131      void uniform2i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y);
132      void uniform3i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z);
133      void uniform4i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z, WebIDL::Long w);
134      void use_program(GC::Root<WebGLProgram> program);
135      void validate_program(GC::Root<WebGLProgram> program);
136      void vertex_attrib1f(WebIDL::UnsignedLong index, float x);
137      void vertex_attrib2f(WebIDL::UnsignedLong index, float x, float y);
138      void vertex_attrib3f(WebIDL::UnsignedLong index, float x, float y, float z);
139      void vertex_attrib4f(WebIDL::UnsignedLong index, float x, float y, float z, float w);
140      void vertex_attrib1fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
141      void vertex_attrib2fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
142      void vertex_attrib3fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
143      void vertex_attrib4fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values);
144      void vertex_attrib_pointer(WebIDL::UnsignedLong index, WebIDL::Long size, WebIDL::UnsignedLong type, bool normalized, WebIDL::Long stride, WebIDL::LongLong offset);
145      void viewport(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height);
146  
147  private:
148      GC::Ref<JS::Realm> m_realm;
149      NonnullOwnPtr<OpenGLContext> m_context;
150  };
151  
152  }
</document_content>
</document>
<document index="51">
<source>./LadybirdBuild/WebGLRenderingContextImpl.cpp</source>
<document_content>
   1  
   2  #include <GLES2/gl2.h>
   3  #include <GLES2/gl2ext.h>
   4  
   5  #include <LibJS/Runtime/ArrayBuffer.h>
   6  #include <LibJS/Runtime/DataView.h>
   7  #include <LibJS/Runtime/TypedArray.h>
   8  #include <LibWeb/HTML/HTMLCanvasElement.h>
   9  #include <LibWeb/HTML/HTMLImageElement.h>
  10  #include <LibWeb/HTML/HTMLVideoElement.h>
  11  #include <LibWeb/HTML/ImageBitmap.h>
  12  #include <LibWeb/HTML/ImageData.h>
  13  #include <LibWeb/WebGL/OpenGLContext.h>
  14  #include <LibWeb/WebGL/WebGLActiveInfo.h>
  15  #include <LibWeb/WebGL/WebGLBuffer.h>
  16  #include <LibWeb/WebGL/WebGLFramebuffer.h>
  17  #include <LibWeb/WebGL/WebGLProgram.h>
  18  #include <LibWeb/WebGL/WebGLRenderbuffer.h>
  19  #include <LibWeb/WebGL/WebGLRenderingContextImpl.h>
  20  #include <LibWeb/WebGL/WebGLSampler.h>
  21  #include <LibWeb/WebGL/WebGLShader.h>
  22  #include <LibWeb/WebGL/WebGLSync.h>
  23  #include <LibWeb/WebGL/WebGLShaderPrecisionFormat.h>
  24  #include <LibWeb/WebGL/WebGLTexture.h>
  25  #include <LibWeb/WebGL/WebGLUniformLocation.h>
  26  #include <LibWeb/WebGL/WebGLVertexArrayObject.h>
  27  #include <LibWeb/WebIDL/Buffers.h>
  28  
  29  namespace Web::WebGL {
  30  
  31  static Vector<GLchar> null_terminated_string(StringView string)
  32  {
  33      Vector<GLchar> result;
  34      for (auto c : string.bytes())
  35          result.append(c);
  36      result.append('\0');
  37      return result;
  38  }
  39  
  40  WebGLRenderingContextImpl::WebGLRenderingContextImpl(JS::Realm& realm, NonnullOwnPtr<OpenGLContext> context)
  41      : m_realm(realm)
  42      , m_context(move(context))
  43  {
  44  }
  45  
  46  
  47  void WebGLRenderingContextImpl::buffer_data(WebIDL::UnsignedLong target, WebIDL::LongLong size, WebIDL::UnsignedLong usage)
  48  {
  49      m_context->make_current();
  50  
  51      glBufferData(target, size, 0, usage);
  52  }
  53  
  54  void WebGLRenderingContextImpl::buffer_data(WebIDL::UnsignedLong target, GC::Root<WebIDL::BufferSource> data, WebIDL::UnsignedLong usage)
  55  {
  56      m_context->make_current();
  57  
  58      void const* ptr = nullptr;
  59      size_t byte_size = 0;
  60      if (data->is_typed_array_base()) {
  61          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*data->raw_object());
  62          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
  63          byte_size = typed_array_base.viewed_array_buffer()->byte_length();
  64      } else if (data->is_data_view()) {
  65          auto& data_view = static_cast<JS::DataView&>(*data->raw_object());
  66          ptr = data_view.viewed_array_buffer()->buffer().data();
  67          byte_size = data_view.viewed_array_buffer()->byte_length();
  68      } else if (data->is_array_buffer()) {
  69          auto& array_buffer = static_cast<JS::ArrayBuffer&>(*data->raw_object());
  70          ptr = array_buffer.buffer().data();
  71          byte_size = array_buffer.byte_length();
  72      } else {
  73          VERIFY_NOT_REACHED();
  74      }
  75      glBufferData(target, byte_size, ptr, usage);
  76  }
  77  
  78  void WebGLRenderingContextImpl::buffer_sub_data(WebIDL::UnsignedLong target, WebIDL::LongLong offset, GC::Root<WebIDL::BufferSource> data)
  79  {
  80      m_context->make_current();
  81  
  82      void const* ptr = nullptr;
  83      size_t byte_size = 0;
  84      if (data->is_typed_array_base()) {
  85          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*data->raw_object());
  86          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
  87          byte_size = typed_array_base.viewed_array_buffer()->byte_length();
  88      } else if (data->is_data_view()) {
  89          auto& data_view = static_cast<JS::DataView&>(*data->raw_object());
  90          ptr = data_view.viewed_array_buffer()->buffer().data();
  91          byte_size = data_view.viewed_array_buffer()->byte_length();
  92      } else if (data->is_array_buffer()) {
  93          auto& array_buffer = static_cast<JS::ArrayBuffer&>(*data->raw_object());
  94          ptr = array_buffer.buffer().data();
  95          byte_size = array_buffer.byte_length();
  96      } else {
  97          VERIFY_NOT_REACHED();
  98      }
  99      glBufferSubData(target, offset, byte_size, ptr);
 100  }
 101  
 102  void WebGLRenderingContextImpl::read_pixels(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels)
 103  {
 104      m_context->make_current();
 105  
 106      if (!pixels) {
 107          return;
 108      }
 109  
 110      void *ptr = nullptr;
 111      if (pixels->is_data_view()) {
 112          auto& data_view = static_cast<JS::DataView&>(*pixels->raw_object());
 113          ptr = data_view.viewed_array_buffer()->buffer().data();
 114      } else if (pixels->is_typed_array_base()) {
 115          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*pixels->raw_object());
 116          ptr = typed_array_base.viewed_array_buffer()->buffer().data();
 117      } else {
 118          VERIFY_NOT_REACHED();
 119      }
 120  
 121      glReadPixels(x, y, width, height, format, type, ptr);
 122  }
 123  
 124  void WebGLRenderingContextImpl::tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::Long width, WebIDL::Long height, WebIDL::Long border, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels)
 125  {
 126      m_context->make_current();
 127  
 128      void const* pixels_ptr = nullptr;
 129      if (pixels) {
 130          auto const& viewed_array_buffer = pixels->viewed_array_buffer();
 131          auto const& byte_buffer = viewed_array_buffer->buffer();
 132          pixels_ptr = byte_buffer.data();
 133      }
 134      glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels_ptr);
 135  }
 136  
 137  void WebGLRenderingContextImpl::tex_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long internalformat, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, Variant<GC::Root<ImageBitmap>, GC::Root<ImageData>, GC::Root<HTMLImageElement>, GC::Root<HTMLCanvasElement>, GC::Root<HTMLVideoElement>> source)
 138  {
 139      m_context->make_current();
 140  
 141      auto bitmap = source.visit(
 142          [](GC::Root<HTMLImageElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 143              return source->immutable_bitmap();
 144          },
 145          [](GC::Root<HTMLCanvasElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 146              auto surface = source->surface();
 147              if (!surface)
 148                  return {};
 149              auto bitmap = MUST(Gfx::Bitmap::create(Gfx::BitmapFormat::RGBA8888, Gfx::AlphaType::Premultiplied, surface->size()));
 150              surface->read_into_bitmap(*bitmap);
 151              return Gfx::ImmutableBitmap::create(*bitmap);
 152          },
 153          [](GC::Root<HTMLVideoElement> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 154              return Gfx::ImmutableBitmap::create(*source->bitmap());
 155          },
 156          [](GC::Root<ImageBitmap> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 157              return Gfx::ImmutableBitmap::create(*source->bitmap());
 158          },
 159          [](GC::Root<ImageData> const& source) -> RefPtr<Gfx::ImmutableBitmap> {
 160              return Gfx::ImmutableBitmap::create(source->bitmap());
 161          });
 162      if (!bitmap)
 163          return;
 164  
 165      void const* pixels_ptr = bitmap->bitmap()->begin();
 166      int width = bitmap->width();
 167      int height = bitmap->height();
 168      glTexImage2D(target, level, internalformat, width, height, 0, format, type, pixels_ptr);
 169  }
 170  
 171  void WebGLRenderingContextImpl::tex_sub_image2d(WebIDL::UnsignedLong target, WebIDL::Long level, WebIDL::Long xoffset, WebIDL::Long yoffset, WebIDL::Long width, WebIDL::Long height, WebIDL::UnsignedLong format, WebIDL::UnsignedLong type, GC::Root<WebIDL::ArrayBufferView> pixels)
 172  {
 173      m_context->make_current();
 174  
 175      void const* pixels_ptr = nullptr;
 176      if (pixels) {
 177          auto const& viewed_array_buffer = pixels->viewed_array_buffer();
 178          auto const& byte_buffer = viewed_array_buffer->buffer();
 179          pixels_ptr = byte_buffer.data();
 180      }
 181      glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels_ptr);
 182  }
 183  
 184  void WebGLRenderingContextImpl::uniform1fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v)
 185  {
 186      m_context->make_current();
 187  
 188      float const* data = nullptr;
 189      size_t count = 0;
 190      if (v.has<Vector<float>>()) {
 191          auto& vector = v.get<Vector<float>>();
 192          data = vector.data();
 193          count = vector.size();
 194      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 195          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 196          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 197          data = typed_array.data().data();
 198          count = typed_array.array_length().length();
 199      } else {
 200          VERIFY_NOT_REACHED();
 201      }
 202  
 203      glUniform1fv(location->handle(), count / 1, data);
 204  }
 205  
 206  void WebGLRenderingContextImpl::uniform2fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v)
 207  {
 208      m_context->make_current();
 209  
 210      float const* data = nullptr;
 211      size_t count = 0;
 212      if (v.has<Vector<float>>()) {
 213          auto& vector = v.get<Vector<float>>();
 214          data = vector.data();
 215          count = vector.size();
 216      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 217          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 218          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 219          data = typed_array.data().data();
 220          count = typed_array.array_length().length();
 221      } else {
 222          VERIFY_NOT_REACHED();
 223      }
 224  
 225      glUniform2fv(location->handle(), count / 2, data);
 226  }
 227  
 228  void WebGLRenderingContextImpl::uniform3fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v)
 229  {
 230      m_context->make_current();
 231  
 232      float const* data = nullptr;
 233      size_t count = 0;
 234      if (v.has<Vector<float>>()) {
 235          auto& vector = v.get<Vector<float>>();
 236          data = vector.data();
 237          count = vector.size();
 238      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 239          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 240          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 241          data = typed_array.data().data();
 242          count = typed_array.array_length().length();
 243      } else {
 244          VERIFY_NOT_REACHED();
 245      }
 246  
 247      glUniform3fv(location->handle(), count / 3, data);
 248  }
 249  
 250  void WebGLRenderingContextImpl::uniform4fv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> v)
 251  {
 252      m_context->make_current();
 253  
 254      float const* data = nullptr;
 255      size_t count = 0;
 256      if (v.has<Vector<float>>()) {
 257          auto& vector = v.get<Vector<float>>();
 258          data = vector.data();
 259          count = vector.size();
 260      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 261          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 262          auto& typed_array = verify_cast<JS::Float32Array>(typed_array_base);
 263          data = typed_array.data().data();
 264          count = typed_array.array_length().length();
 265      } else {
 266          VERIFY_NOT_REACHED();
 267      }
 268  
 269      glUniform4fv(location->handle(), count / 4, data);
 270  }
 271  
 272  void WebGLRenderingContextImpl::uniform1iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v)
 273  {
 274      m_context->make_current();
 275  
 276      int const* data = nullptr;
 277      size_t count = 0;
 278      if (v.has<Vector<int>>()) {
 279          auto& vector = v.get<Vector<int>>();
 280          data = vector.data();
 281          count = vector.size();
 282      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 283          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 284          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 285          data = typed_array.data().data();
 286          count = typed_array.array_length().length();
 287      } else {
 288          VERIFY_NOT_REACHED();
 289      }
 290  
 291      glUniform1iv(location->handle(), count / 1, data);
 292  }
 293  
 294  void WebGLRenderingContextImpl::uniform2iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v)
 295  {
 296      m_context->make_current();
 297  
 298      int const* data = nullptr;
 299      size_t count = 0;
 300      if (v.has<Vector<int>>()) {
 301          auto& vector = v.get<Vector<int>>();
 302          data = vector.data();
 303          count = vector.size();
 304      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 305          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 306          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 307          data = typed_array.data().data();
 308          count = typed_array.array_length().length();
 309      } else {
 310          VERIFY_NOT_REACHED();
 311      }
 312  
 313      glUniform2iv(location->handle(), count / 2, data);
 314  }
 315  
 316  void WebGLRenderingContextImpl::uniform3iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v)
 317  {
 318      m_context->make_current();
 319  
 320      int const* data = nullptr;
 321      size_t count = 0;
 322      if (v.has<Vector<int>>()) {
 323          auto& vector = v.get<Vector<int>>();
 324          data = vector.data();
 325          count = vector.size();
 326      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 327          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 328          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 329          data = typed_array.data().data();
 330          count = typed_array.array_length().length();
 331      } else {
 332          VERIFY_NOT_REACHED();
 333      }
 334  
 335      glUniform3iv(location->handle(), count / 3, data);
 336  }
 337  
 338  void WebGLRenderingContextImpl::uniform4iv(GC::Root<WebGLUniformLocation> location, Variant<GC::Root<WebIDL::BufferSource>, Vector<WebIDL::Long>> v)
 339  {
 340      m_context->make_current();
 341  
 342      int const* data = nullptr;
 343      size_t count = 0;
 344      if (v.has<Vector<int>>()) {
 345          auto& vector = v.get<Vector<int>>();
 346          data = vector.data();
 347          count = vector.size();
 348      } else if (v.has<GC::Root<WebIDL::BufferSource>>()) {
 349          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*v.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 350          auto& typed_array = verify_cast<JS::Int32Array>(typed_array_base);
 351          data = typed_array.data().data();
 352          count = typed_array.array_length().length();
 353      } else {
 354          VERIFY_NOT_REACHED();
 355      }
 356  
 357      glUniform4iv(location->handle(), count / 4, data);
 358  }
 359  
 360  void WebGLRenderingContextImpl::uniform_matrix2fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> value)
 361  {
 362      m_context->make_current();
 363  
 364      auto matrix_size = 2 * 2;
 365      float const* raw_data = nullptr;
 366      u64 count = 0;
 367      if (value.has<Vector<float>>()) {
 368          auto& vector_data = value.get<Vector<float>>();
 369          raw_data = vector_data.data();
 370          count = vector_data.size() / matrix_size;
 371      } else {
 372          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*value.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 373          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 374          raw_data = float32_array.data().data();
 375          count = float32_array.array_length().length() / matrix_size;
 376      }
 377  
 378      glUniformMatrix2fv(location->handle(), count, transpose, raw_data);
 379  }
 380  
 381  void WebGLRenderingContextImpl::uniform_matrix3fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> value)
 382  {
 383      m_context->make_current();
 384  
 385      auto matrix_size = 3 * 3;
 386      float const* raw_data = nullptr;
 387      u64 count = 0;
 388      if (value.has<Vector<float>>()) {
 389          auto& vector_data = value.get<Vector<float>>();
 390          raw_data = vector_data.data();
 391          count = vector_data.size() / matrix_size;
 392      } else {
 393          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*value.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 394          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 395          raw_data = float32_array.data().data();
 396          count = float32_array.array_length().length() / matrix_size;
 397      }
 398  
 399      glUniformMatrix3fv(location->handle(), count, transpose, raw_data);
 400  }
 401  
 402  void WebGLRenderingContextImpl::uniform_matrix4fv(GC::Root<WebGLUniformLocation> location, bool transpose, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> value)
 403  {
 404      m_context->make_current();
 405  
 406      auto matrix_size = 4 * 4;
 407      float const* raw_data = nullptr;
 408      u64 count = 0;
 409      if (value.has<Vector<float>>()) {
 410          auto& vector_data = value.get<Vector<float>>();
 411          raw_data = vector_data.data();
 412          count = vector_data.size() / matrix_size;
 413      } else {
 414          auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*value.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
 415          auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
 416          raw_data = float32_array.data().data();
 417          count = float32_array.array_length().length() / matrix_size;
 418      }
 419  
 420      glUniformMatrix4fv(location->handle(), count, transpose, raw_data);
 421  }
 422  
 423  void WebGLRenderingContextImpl::active_texture(WebIDL::UnsignedLong texture)
 424  {
 425      m_context->make_current();
 426      glActiveTexture(texture);
 427  }
 428  
 429  void WebGLRenderingContextImpl::attach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader)
 430  {
 431      m_context->make_current();
 432  
 433      auto program_handle = 0;
 434      if (program) {
 435          auto handle_or_error = program->handle(this);
 436          if (handle_or_error.is_error()) {
 437              set_error(GL_INVALID_OPERATION);
 438              return ;
 439          }
 440          program_handle = handle_or_error.release_value();
 441      }
 442  
 443      auto shader_handle = 0;
 444      if (shader) {
 445          auto handle_or_error = shader->handle(this);
 446          if (handle_or_error.is_error()) {
 447              set_error(GL_INVALID_OPERATION);
 448              return ;
 449          }
 450          shader_handle = handle_or_error.release_value();
 451      }
 452      glAttachShader(program_handle, shader_handle);
 453  }
 454  
 455  void WebGLRenderingContextImpl::bind_attrib_location(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index, String name)
 456  {
 457      m_context->make_current();
 458  
 459      auto program_handle = 0;
 460      if (program) {
 461          auto handle_or_error = program->handle(this);
 462          if (handle_or_error.is_error()) {
 463              set_error(GL_INVALID_OPERATION);
 464              return ;
 465          }
 466          program_handle = handle_or_error.release_value();
 467      }
 468  
 469      auto name_null_terminated = null_terminated_string(name);
 470      glBindAttribLocation(program_handle, index, name_null_terminated.data());
 471  }
 472  
 473  void WebGLRenderingContextImpl::bind_buffer(WebIDL::UnsignedLong target, GC::Root<WebGLBuffer> buffer)
 474  {
 475      m_context->make_current();
 476  
 477      auto buffer_handle = 0;
 478      if (buffer) {
 479          auto handle_or_error = buffer->handle(this);
 480          if (handle_or_error.is_error()) {
 481              set_error(GL_INVALID_OPERATION);
 482              return ;
 483          }
 484          buffer_handle = handle_or_error.release_value();
 485      }
 486      glBindBuffer(target, buffer_handle);
 487  }
 488  
 489  void WebGLRenderingContextImpl::bind_framebuffer(WebIDL::UnsignedLong target, GC::Root<WebGLFramebuffer> framebuffer)
 490  {
 491      m_context->make_current();
 492  
 493      auto framebuffer_handle = 0;
 494      if (framebuffer) {
 495          auto handle_or_error = framebuffer->handle(this);
 496          if (handle_or_error.is_error()) {
 497              set_error(GL_INVALID_OPERATION);
 498              return ;
 499          }
 500          framebuffer_handle = handle_or_error.release_value();
 501      }
 502      glBindFramebuffer(target, framebuffer_handle);
 503  }
 504  
 505  void WebGLRenderingContextImpl::bind_renderbuffer(WebIDL::UnsignedLong target, GC::Root<WebGLRenderbuffer> renderbuffer)
 506  {
 507      m_context->make_current();
 508  
 509      auto renderbuffer_handle = 0;
 510      if (renderbuffer) {
 511          auto handle_or_error = renderbuffer->handle(this);
 512          if (handle_or_error.is_error()) {
 513              set_error(GL_INVALID_OPERATION);
 514              return ;
 515          }
 516          renderbuffer_handle = handle_or_error.release_value();
 517      }
 518      glBindRenderbuffer(target, renderbuffer_handle);
 519  }
 520  
 521  void WebGLRenderingContextImpl::bind_texture(WebIDL::UnsignedLong target, GC::Root<WebGLTexture> texture)
 522  {
 523      m_context->make_current();
 524  
 525      auto texture_handle = 0;
 526      if (texture) {
 527          auto handle_or_error = texture->handle(this);
 528          if (handle_or_error.is_error()) {
 529              set_error(GL_INVALID_OPERATION);
 530              return ;
 531          }
 532          texture_handle = handle_or_error.release_value();
 533      }
 534      glBindTexture(target, texture_handle);
 535  }
 536  
 537  void WebGLRenderingContextImpl::blend_color(float red, float green, float blue, float alpha)
 538  {
 539      m_context->make_current();
 540      glBlendColor(red, green, blue, alpha);
 541  }
 542  
 543  void WebGLRenderingContextImpl::blend_equation(WebIDL::UnsignedLong mode)
 544  {
 545      m_context->make_current();
 546      glBlendEquation(mode);
 547  }
 548  
 549  void WebGLRenderingContextImpl::blend_equation_separate(WebIDL::UnsignedLong mode_rgb, WebIDL::UnsignedLong mode_alpha)
 550  {
 551      m_context->make_current();
 552      glBlendEquationSeparate(mode_rgb, mode_alpha);
 553  }
 554  
 555  void WebGLRenderingContextImpl::blend_func(WebIDL::UnsignedLong sfactor, WebIDL::UnsignedLong dfactor)
 556  {
 557      m_context->make_current();
 558      glBlendFunc(sfactor, dfactor);
 559  }
 560  
 561  void WebGLRenderingContextImpl::blend_func_separate(WebIDL::UnsignedLong src_rgb, WebIDL::UnsignedLong dst_rgb, WebIDL::UnsignedLong src_alpha, WebIDL::UnsignedLong dst_alpha)
 562  {
 563      m_context->make_current();
 564      glBlendFuncSeparate(src_rgb, dst_rgb, src_alpha, dst_alpha);
 565  }
 566  
 567  WebIDL::UnsignedLong WebGLRenderingContextImpl::check_framebuffer_status(WebIDL::UnsignedLong target)
 568  {
 569      m_context->make_current();
 570      return glCheckFramebufferStatus(target);
 571  }
 572  
 573  void WebGLRenderingContextImpl::clear(WebIDL::UnsignedLong mask)
 574  {
 575      m_context->make_current();
 576      glClear(mask);
 577  }
 578  
 579  void WebGLRenderingContextImpl::clear_color(float red, float green, float blue, float alpha)
 580  {
 581      m_context->make_current();
 582      m_context->notify_content_will_change();
 583      needs_to_present();
 584      glClearColor(red, green, blue, alpha);
 585  }
 586  
 587  void WebGLRenderingContextImpl::clear_depth(float depth)
 588  {
 589      m_context->make_current();
 590      glClearDepthf(depth);
 591  }
 592  
 593  void WebGLRenderingContextImpl::clear_stencil(WebIDL::Long s)
 594  {
 595      m_context->make_current();
 596      glClearStencil(s);
 597  }
 598  
 599  void WebGLRenderingContextImpl::color_mask(bool red, bool green, bool blue, bool alpha)
 600  {
 601      m_context->make_current();
 602      glColorMask(red, green, blue, alpha);
 603  }
 604  
 605  void WebGLRenderingContextImpl::compile_shader(GC::Root<WebGLShader> shader)
 606  {
 607      m_context->make_current();
 608  
 609      auto shader_handle = 0;
 610      if (shader) {
 611          auto handle_or_error = shader->handle(this);
 612          if (handle_or_error.is_error()) {
 613              set_error(GL_INVALID_OPERATION);
 614              return ;
 615          }
 616          shader_handle = handle_or_error.release_value();
 617      }
 618      glCompileShader(shader_handle);
 619  }
 620  
 621  GC::Root<WebGLBuffer> WebGLRenderingContextImpl::create_buffer()
 622  {
 623      m_context->make_current();
 624  
 625      GLuint handle = 0;
 626      glGenBuffers(1, &handle);
 627      return WebGLBuffer::create(m_realm, *this, handle);
 628  }
 629  
 630  GC::Root<WebGLFramebuffer> WebGLRenderingContextImpl::create_framebuffer()
 631  {
 632      m_context->make_current();
 633  
 634      GLuint handle = 0;
 635      glGenFramebuffers(1, &handle);
 636      return WebGLFramebuffer::create(m_realm, *this, handle);
 637  }
 638  
 639  GC::Root<WebGLProgram> WebGLRenderingContextImpl::create_program()
 640  {
 641      m_context->make_current();
 642      return WebGLProgram::create(m_realm, *this, glCreateProgram());
 643  }
 644  
 645  GC::Root<WebGLRenderbuffer> WebGLRenderingContextImpl::create_renderbuffer()
 646  {
 647      m_context->make_current();
 648  
 649      GLuint handle = 0;
 650      glGenRenderbuffers(1, &handle);
 651      return WebGLRenderbuffer::create(m_realm, *this, handle);
 652  }
 653  
 654  GC::Root<WebGLShader> WebGLRenderingContextImpl::create_shader(WebIDL::UnsignedLong type)
 655  {
 656      m_context->make_current();
 657      return WebGLShader::create(m_realm, *this, glCreateShader(type));
 658  }
 659  
 660  GC::Root<WebGLTexture> WebGLRenderingContextImpl::create_texture()
 661  {
 662      m_context->make_current();
 663  
 664      GLuint handle = 0;
 665      glGenTextures(1, &handle);
 666      return WebGLTexture::create(m_realm, *this, handle);
 667  }
 668  
 669  void WebGLRenderingContextImpl::cull_face(WebIDL::UnsignedLong mode)
 670  {
 671      m_context->make_current();
 672      glCullFace(mode);
 673  }
 674  
 675  void WebGLRenderingContextImpl::delete_buffer(GC::Root<WebGLBuffer> buffer)
 676  {
 677      m_context->make_current();
 678  
 679      GLuint buffer_handle = 0;
 680      if (buffer) {
 681          auto handle_or_error = buffer->handle(this);
 682          if (handle_or_error.is_error()) {
 683              set_error(GL_INVALID_OPERATION);
 684              return ;
 685          }
 686          buffer_handle = handle_or_error.release_value();
 687      }
 688  
 689      glDeleteBuffers(1, &buffer_handle);
 690  }
 691  
 692  void WebGLRenderingContextImpl::delete_framebuffer(GC::Root<WebGLFramebuffer> framebuffer)
 693  {
 694      m_context->make_current();
 695  
 696      GLuint framebuffer_handle = 0;
 697      if (framebuffer) {
 698          auto handle_or_error = framebuffer->handle(this);
 699          if (handle_or_error.is_error()) {
 700              set_error(GL_INVALID_OPERATION);
 701              return ;
 702          }
 703          framebuffer_handle = handle_or_error.release_value();
 704      }
 705  
 706      glDeleteFramebuffers(1, &framebuffer_handle);
 707  }
 708  
 709  void WebGLRenderingContextImpl::delete_program(GC::Root<WebGLProgram> program)
 710  {
 711      m_context->make_current();
 712  
 713      auto program_handle = 0;
 714      if (program) {
 715          auto handle_or_error = program->handle(this);
 716          if (handle_or_error.is_error()) {
 717              set_error(GL_INVALID_OPERATION);
 718              return ;
 719          }
 720          program_handle = handle_or_error.release_value();
 721      }
 722      glDeleteProgram(program_handle);
 723  }
 724  
 725  void WebGLRenderingContextImpl::delete_shader(GC::Root<WebGLShader> shader)
 726  {
 727      m_context->make_current();
 728  
 729      auto shader_handle = 0;
 730      if (shader) {
 731          auto handle_or_error = shader->handle(this);
 732          if (handle_or_error.is_error()) {
 733              set_error(GL_INVALID_OPERATION);
 734              return ;
 735          }
 736          shader_handle = handle_or_error.release_value();
 737      }
 738      glDeleteShader(shader_handle);
 739  }
 740  
 741  void WebGLRenderingContextImpl::delete_texture(GC::Root<WebGLTexture> texture)
 742  {
 743      m_context->make_current();
 744  
 745      GLuint texture_handle = 0;
 746      if (texture) {
 747          auto handle_or_error = texture->handle(this);
 748          if (handle_or_error.is_error()) {
 749              set_error(GL_INVALID_OPERATION);
 750              return ;
 751          }
 752          texture_handle = handle_or_error.release_value();
 753      }
 754  
 755      glDeleteTextures(1, &texture_handle);
 756  }
 757  
 758  void WebGLRenderingContextImpl::depth_func(WebIDL::UnsignedLong func)
 759  {
 760      m_context->make_current();
 761      glDepthFunc(func);
 762  }
 763  
 764  void WebGLRenderingContextImpl::depth_mask(bool flag)
 765  {
 766      m_context->make_current();
 767      glDepthMask(flag);
 768  }
 769  
 770  void WebGLRenderingContextImpl::depth_range(float z_near, float z_far)
 771  {
 772      m_context->make_current();
 773      glDepthRangef(z_near, z_far);
 774  }
 775  
 776  void WebGLRenderingContextImpl::detach_shader(GC::Root<WebGLProgram> program, GC::Root<WebGLShader> shader)
 777  {
 778      m_context->make_current();
 779  
 780      auto program_handle = 0;
 781      if (program) {
 782          auto handle_or_error = program->handle(this);
 783          if (handle_or_error.is_error()) {
 784              set_error(GL_INVALID_OPERATION);
 785              return ;
 786          }
 787          program_handle = handle_or_error.release_value();
 788      }
 789  
 790      auto shader_handle = 0;
 791      if (shader) {
 792          auto handle_or_error = shader->handle(this);
 793          if (handle_or_error.is_error()) {
 794              set_error(GL_INVALID_OPERATION);
 795              return ;
 796          }
 797          shader_handle = handle_or_error.release_value();
 798      }
 799      glDetachShader(program_handle, shader_handle);
 800  }
 801  
 802  void WebGLRenderingContextImpl::disable(WebIDL::UnsignedLong cap)
 803  {
 804      m_context->make_current();
 805      glDisable(cap);
 806  }
 807  
 808  void WebGLRenderingContextImpl::disable_vertex_attrib_array(WebIDL::UnsignedLong index)
 809  {
 810      m_context->make_current();
 811      glDisableVertexAttribArray(index);
 812  }
 813  
 814  void WebGLRenderingContextImpl::draw_arrays(WebIDL::UnsignedLong mode, WebIDL::Long first, WebIDL::Long count)
 815  {
 816      m_context->make_current();
 817      m_context->notify_content_will_change();
 818      needs_to_present();
 819      glDrawArrays(mode, first, count);
 820  }
 821  
 822  void WebGLRenderingContextImpl::draw_elements(WebIDL::UnsignedLong mode, WebIDL::Long count, WebIDL::UnsignedLong type, WebIDL::LongLong offset)
 823  {
 824      m_context->make_current();
 825      m_context->notify_content_will_change();
 826  
 827      glDrawElements(mode, count, type, reinterpret_cast<void*>(offset));
 828      needs_to_present();
 829  }
 830  
 831  void WebGLRenderingContextImpl::enable(WebIDL::UnsignedLong cap)
 832  {
 833      m_context->make_current();
 834      glEnable(cap);
 835  }
 836  
 837  void WebGLRenderingContextImpl::enable_vertex_attrib_array(WebIDL::UnsignedLong index)
 838  {
 839      m_context->make_current();
 840      glEnableVertexAttribArray(index);
 841  }
 842  
 843  void WebGLRenderingContextImpl::finish()
 844  {
 845      m_context->make_current();
 846      glFinish();
 847  }
 848  
 849  void WebGLRenderingContextImpl::flush()
 850  {
 851      m_context->make_current();
 852      glFlush();
 853  }
 854  
 855  void WebGLRenderingContextImpl::framebuffer_renderbuffer(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong renderbuffertarget, GC::Root<WebGLRenderbuffer> renderbuffer)
 856  {
 857      m_context->make_current();
 858  
 859      auto renderbuffer_handle = 0;
 860      if (renderbuffer) {
 861          auto handle_or_error = renderbuffer->handle(this);
 862          if (handle_or_error.is_error()) {
 863              set_error(GL_INVALID_OPERATION);
 864              return ;
 865          }
 866          renderbuffer_handle = handle_or_error.release_value();
 867      }
 868      glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer_handle);
 869  }
 870  
 871  void WebGLRenderingContextImpl::framebuffer_texture2d(WebIDL::UnsignedLong target, WebIDL::UnsignedLong attachment, WebIDL::UnsignedLong textarget, GC::Root<WebGLTexture> texture, WebIDL::Long level)
 872  {
 873      m_context->make_current();
 874  
 875      auto texture_handle = 0;
 876      if (texture) {
 877          auto handle_or_error = texture->handle(this);
 878          if (handle_or_error.is_error()) {
 879              set_error(GL_INVALID_OPERATION);
 880              return ;
 881          }
 882          texture_handle = handle_or_error.release_value();
 883      }
 884      glFramebufferTexture2D(target, attachment, textarget, texture_handle, level);
 885  }
 886  
 887  void WebGLRenderingContextImpl::front_face(WebIDL::UnsignedLong mode)
 888  {
 889      m_context->make_current();
 890      glFrontFace(mode);
 891  }
 892  
 893  void WebGLRenderingContextImpl::generate_mipmap(WebIDL::UnsignedLong target)
 894  {
 895      m_context->make_current();
 896      glGenerateMipmap(target);
 897  }
 898  
 899  GC::Root<WebGLActiveInfo> WebGLRenderingContextImpl::get_active_attrib(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index)
 900  {
 901      m_context->make_current();
 902  
 903      GLuint program_handle = 0;
 904      if (program) {
 905          auto handle_or_error = program->handle(this);
 906          if (handle_or_error.is_error()) {
 907              set_error(GL_INVALID_OPERATION);
 908              return {};
 909          }
 910          program_handle = handle_or_error.release_value();
 911      }
 912  
 913      GLint size = 0;
 914      GLenum type = 0;
 915      GLsizei buf_size = 256;
 916      GLsizei length = 0;
 917      GLchar name[256];
 918      glGetActiveAttrib(program_handle, index, buf_size, &length, &size, &type, name);
 919      auto readonly_bytes = ReadonlyBytes { name, static_cast<size_t>(length) };
 920      return WebGLActiveInfo::create(m_realm, String::from_utf8_without_validation(readonly_bytes), type, size);
 921  }
 922  
 923  GC::Root<WebGLActiveInfo> WebGLRenderingContextImpl::get_active_uniform(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong index)
 924  {
 925      m_context->make_current();
 926  
 927      GLuint program_handle = 0;
 928      if (program) {
 929          auto handle_or_error = program->handle(this);
 930          if (handle_or_error.is_error()) {
 931              set_error(GL_INVALID_OPERATION);
 932              return {};
 933          }
 934          program_handle = handle_or_error.release_value();
 935      }
 936  
 937      GLint size = 0;
 938      GLenum type = 0;
 939      GLsizei buf_size = 256;
 940      GLsizei length = 0;
 941      GLchar name[256];
 942      glGetActiveUniform(program_handle, index, buf_size, &length, &size, &type, name);
 943      auto readonly_bytes = ReadonlyBytes { name, static_cast<size_t>(length) };
 944      return WebGLActiveInfo::create(m_realm, String::from_utf8_without_validation(readonly_bytes), type, size);
 945  }
 946  
 947  WebIDL::Long WebGLRenderingContextImpl::get_attrib_location(GC::Root<WebGLProgram> program, String name)
 948  {
 949      m_context->make_current();
 950  
 951      auto program_handle = 0;
 952      if (program) {
 953          auto handle_or_error = program->handle(this);
 954          if (handle_or_error.is_error()) {
 955              set_error(GL_INVALID_OPERATION);
 956              return -1;
 957          }
 958          program_handle = handle_or_error.release_value();
 959      }
 960  
 961      auto name_null_terminated = null_terminated_string(name);
 962      return glGetAttribLocation(program_handle, name_null_terminated.data());
 963  }
 964  
 965  JS::Value WebGLRenderingContextImpl::get_buffer_parameter(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname)
 966  {
 967      m_context->make_current();
 968      switch (pname) {
 969      case GL_BUFFER_SIZE: {
 970          GLint result;
 971          glGetBufferParameteriv(target, GL_BUFFER_SIZE, &result);
 972          return JS::Value(result);
 973      }
 974  
 975      case GL_BUFFER_USAGE: {
 976          GLint result;
 977          glGetBufferParameteriv(target, GL_BUFFER_USAGE, &result);
 978          return JS::Value(result);
 979      }
 980  
 981      default:
 982          dbgln("Unknown WebGL buffer parameter name: {:x}", pname);
 983          set_error(GL_INVALID_ENUM);
 984          return JS::js_null();
 985      }
 986  }
 987  
 988  JS::Value WebGLRenderingContextImpl::get_parameter(WebIDL::UnsignedLong pname)
 989  {
 990      m_context->make_current();
 991      switch (pname) {
 992      case GL_ACTIVE_TEXTURE: {
 993          GLint result;
 994          glGetIntegerv(GL_ACTIVE_TEXTURE, &result);
 995          return JS::Value(result);
 996      }
 997      case GL_ALIASED_LINE_WIDTH_RANGE: {
 998          Array<GLfloat, 2> result;
 999          glGetFloatv(GL_ALIASED_LINE_WIDTH_RANGE, result.data());
1000          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLfloat)));
1001          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1002          return JS::Float32Array::create(m_realm, 2, array_buffer);
1003      }
1004      case GL_ALIASED_POINT_SIZE_RANGE: {
1005          Array<GLfloat, 2> result;
1006          glGetFloatv(GL_ALIASED_POINT_SIZE_RANGE, result.data());
1007          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLfloat)));
1008          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1009          return JS::Float32Array::create(m_realm, 2, array_buffer);
1010      }
1011      case GL_ALPHA_BITS: {
1012          GLint result;
1013          glGetIntegerv(GL_ALPHA_BITS, &result);
1014          return JS::Value(result);
1015      }
1016      case GL_ARRAY_BUFFER_BINDING: {
1017          GLint result;
1018          glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &result);
1019          if (!result)
1020              return JS::js_null();
1021          return WebGLBuffer::create(m_realm, *this, result);
1022      }
1023      case GL_BLEND: {
1024          GLint result;
1025          glGetIntegerv(GL_BLEND, &result);
1026          return JS::Value(result);
1027      }
1028      case GL_BLEND_COLOR: {
1029          Array<GLfloat, 4> result;
1030          glGetFloatv(GL_BLEND_COLOR, result.data());
1031          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLfloat)));
1032          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1033          return JS::Float32Array::create(m_realm, 4, array_buffer);
1034      }
1035      case GL_BLEND_DST_ALPHA: {
1036          GLint result;
1037          glGetIntegerv(GL_BLEND_DST_ALPHA, &result);
1038          return JS::Value(result);
1039      }
1040      case GL_BLEND_DST_RGB: {
1041          GLint result;
1042          glGetIntegerv(GL_BLEND_DST_RGB, &result);
1043          return JS::Value(result);
1044      }
1045      case GL_BLEND_EQUATION_ALPHA: {
1046          GLint result;
1047          glGetIntegerv(GL_BLEND_EQUATION_ALPHA, &result);
1048          return JS::Value(result);
1049      }
1050      case GL_BLEND_EQUATION_RGB: {
1051          GLint result;
1052          glGetIntegerv(GL_BLEND_EQUATION_RGB, &result);
1053          return JS::Value(result);
1054      }
1055      case GL_BLEND_SRC_ALPHA: {
1056          GLint result;
1057          glGetIntegerv(GL_BLEND_SRC_ALPHA, &result);
1058          return JS::Value(result);
1059      }
1060      case GL_BLEND_SRC_RGB: {
1061          GLint result;
1062          glGetIntegerv(GL_BLEND_SRC_RGB, &result);
1063          return JS::Value(result);
1064      }
1065      case GL_BLUE_BITS: {
1066          GLint result;
1067          glGetIntegerv(GL_BLUE_BITS, &result);
1068          return JS::Value(result);
1069      }
1070      case GL_COLOR_CLEAR_VALUE: {
1071          Array<GLfloat, 4> result;
1072          glGetFloatv(GL_COLOR_CLEAR_VALUE, result.data());
1073          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLfloat)));
1074          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1075          return JS::Float32Array::create(m_realm, 4, array_buffer);
1076      }
1077      case GL_CULL_FACE: {
1078          GLint result;
1079          glGetIntegerv(GL_CULL_FACE, &result);
1080          return JS::Value(result);
1081      }
1082      case GL_CULL_FACE_MODE: {
1083          GLint result;
1084          glGetIntegerv(GL_CULL_FACE_MODE, &result);
1085          return JS::Value(result);
1086      }
1087      case GL_CURRENT_PROGRAM: {
1088          GLint result;
1089          glGetIntegerv(GL_CURRENT_PROGRAM, &result);
1090          if (!result)
1091              return JS::js_null();
1092          return WebGLProgram::create(m_realm, *this, result);
1093      }
1094      case GL_DEPTH_BITS: {
1095          GLint result;
1096          glGetIntegerv(GL_DEPTH_BITS, &result);
1097          return JS::Value(result);
1098      }
1099      case GL_DEPTH_CLEAR_VALUE: {
1100          GLint result;
1101          glGetIntegerv(GL_DEPTH_CLEAR_VALUE, &result);
1102          return JS::Value(result);
1103      }
1104      case GL_DEPTH_FUNC: {
1105          GLint result;
1106          glGetIntegerv(GL_DEPTH_FUNC, &result);
1107          return JS::Value(result);
1108      }
1109      case GL_DEPTH_RANGE: {
1110          Array<GLfloat, 2> result;
1111          glGetFloatv(GL_DEPTH_RANGE, result.data());
1112          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLfloat)));
1113          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1114          return JS::Float32Array::create(m_realm, 2, array_buffer);
1115      }
1116      case GL_DEPTH_TEST: {
1117          GLint result;
1118          glGetIntegerv(GL_DEPTH_TEST, &result);
1119          return JS::Value(result);
1120      }
1121      case GL_DEPTH_WRITEMASK: {
1122          GLint result;
1123          glGetIntegerv(GL_DEPTH_WRITEMASK, &result);
1124          return JS::Value(result);
1125      }
1126      case GL_DITHER: {
1127          GLint result;
1128          glGetIntegerv(GL_DITHER, &result);
1129          return JS::Value(result);
1130      }
1131      case GL_ELEMENT_ARRAY_BUFFER_BINDING: {
1132          GLint result;
1133          glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &result);
1134          if (!result)
1135              return JS::js_null();
1136          return WebGLBuffer::create(m_realm, *this, result);
1137      }
1138      case GL_FRAMEBUFFER_BINDING: {
1139          GLint result;
1140          glGetIntegerv(GL_FRAMEBUFFER_BINDING, &result);
1141          if (!result)
1142              return JS::js_null();
1143          return WebGLFramebuffer::create(m_realm, *this, result);
1144      }
1145      case GL_FRONT_FACE: {
1146          GLint result;
1147          glGetIntegerv(GL_FRONT_FACE, &result);
1148          return JS::Value(result);
1149      }
1150      case GL_GENERATE_MIPMAP_HINT: {
1151          GLint result;
1152          glGetIntegerv(GL_GENERATE_MIPMAP_HINT, &result);
1153          return JS::Value(result);
1154      }
1155      case GL_GREEN_BITS: {
1156          GLint result;
1157          glGetIntegerv(GL_GREEN_BITS, &result);
1158          return JS::Value(result);
1159      }
1160      case GL_IMPLEMENTATION_COLOR_READ_FORMAT: {
1161          GLint result;
1162          glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_FORMAT, &result);
1163          return JS::Value(result);
1164      }
1165      case GL_IMPLEMENTATION_COLOR_READ_TYPE: {
1166          GLint result;
1167          glGetIntegerv(GL_IMPLEMENTATION_COLOR_READ_TYPE, &result);
1168          return JS::Value(result);
1169      }
1170      case GL_LINE_WIDTH: {
1171          GLint result;
1172          glGetIntegerv(GL_LINE_WIDTH, &result);
1173          return JS::Value(result);
1174      }
1175      case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS: {
1176          GLint result;
1177          glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &result);
1178          return JS::Value(result);
1179      }
1180      case GL_MAX_CUBE_MAP_TEXTURE_SIZE: {
1181          GLint result;
1182          glGetIntegerv(GL_MAX_CUBE_MAP_TEXTURE_SIZE, &result);
1183          return JS::Value(result);
1184      }
1185      case GL_MAX_FRAGMENT_UNIFORM_VECTORS: {
1186          GLint result;
1187          glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS, &result);
1188          return JS::Value(result);
1189      }
1190      case GL_MAX_RENDERBUFFER_SIZE: {
1191          GLint result;
1192          glGetIntegerv(GL_MAX_RENDERBUFFER_SIZE, &result);
1193          return JS::Value(result);
1194      }
1195      case GL_MAX_TEXTURE_IMAGE_UNITS: {
1196          GLint result;
1197          glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &result);
1198          return JS::Value(result);
1199      }
1200      case GL_MAX_TEXTURE_SIZE: {
1201          GLint result;
1202          glGetIntegerv(GL_MAX_TEXTURE_SIZE, &result);
1203          return JS::Value(result);
1204      }
1205      case GL_MAX_VARYING_VECTORS: {
1206          GLint result;
1207          glGetIntegerv(GL_MAX_VARYING_VECTORS, &result);
1208          return JS::Value(result);
1209      }
1210      case GL_MAX_VERTEX_ATTRIBS: {
1211          GLint result;
1212          glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &result);
1213          return JS::Value(result);
1214      }
1215      case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS: {
1216          GLint result;
1217          glGetIntegerv(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS, &result);
1218          return JS::Value(result);
1219      }
1220      case GL_MAX_VERTEX_UNIFORM_VECTORS: {
1221          GLint result;
1222          glGetIntegerv(GL_MAX_VERTEX_UNIFORM_VECTORS, &result);
1223          return JS::Value(result);
1224      }
1225      case GL_MAX_VIEWPORT_DIMS: {
1226          Array<GLint, 2> result;
1227          glGetIntegerv(GL_MAX_VIEWPORT_DIMS, result.data());
1228          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 2 * sizeof(GLint)));
1229          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1230          return JS::Int32Array::create(m_realm, 2, array_buffer);
1231      }
1232      case GL_PACK_ALIGNMENT: {
1233          GLint result;
1234          glGetIntegerv(GL_PACK_ALIGNMENT, &result);
1235          return JS::Value(result);
1236      }
1237      case GL_POLYGON_OFFSET_FACTOR: {
1238          GLint result;
1239          glGetIntegerv(GL_POLYGON_OFFSET_FACTOR, &result);
1240          return JS::Value(result);
1241      }
1242      case GL_POLYGON_OFFSET_FILL: {
1243          GLint result;
1244          glGetIntegerv(GL_POLYGON_OFFSET_FILL, &result);
1245          return JS::Value(result);
1246      }
1247      case GL_POLYGON_OFFSET_UNITS: {
1248          GLint result;
1249          glGetIntegerv(GL_POLYGON_OFFSET_UNITS, &result);
1250          return JS::Value(result);
1251      }
1252      case GL_RED_BITS: {
1253          GLint result;
1254          glGetIntegerv(GL_RED_BITS, &result);
1255          return JS::Value(result);
1256      }
1257      case GL_RENDERBUFFER_BINDING: {
1258          GLint result;
1259          glGetIntegerv(GL_RENDERBUFFER_BINDING, &result);
1260          if (!result)
1261              return JS::js_null();
1262          return WebGLRenderbuffer::create(m_realm, *this, result);
1263      }
1264      case GL_RENDERER: {
1265          auto result = reinterpret_cast<const char*>(glGetString(GL_RENDERER));
1266          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1267      case GL_SAMPLE_ALPHA_TO_COVERAGE: {
1268          GLint result;
1269          glGetIntegerv(GL_SAMPLE_ALPHA_TO_COVERAGE, &result);
1270          return JS::Value(result);
1271      }
1272      case GL_SAMPLE_BUFFERS: {
1273          GLint result;
1274          glGetIntegerv(GL_SAMPLE_BUFFERS, &result);
1275          return JS::Value(result);
1276      }
1277      case GL_SAMPLE_COVERAGE: {
1278          GLint result;
1279          glGetIntegerv(GL_SAMPLE_COVERAGE, &result);
1280          return JS::Value(result);
1281      }
1282      case GL_SAMPLE_COVERAGE_INVERT: {
1283          GLint result;
1284          glGetIntegerv(GL_SAMPLE_COVERAGE_INVERT, &result);
1285          return JS::Value(result);
1286      }
1287      case GL_SAMPLE_COVERAGE_VALUE: {
1288          GLint result;
1289          glGetIntegerv(GL_SAMPLE_COVERAGE_VALUE, &result);
1290          return JS::Value(result);
1291      }
1292      case GL_SAMPLES: {
1293          GLint result;
1294          glGetIntegerv(GL_SAMPLES, &result);
1295          return JS::Value(result);
1296      }
1297      case GL_SCISSOR_BOX: {
1298          Array<GLint, 4> result;
1299          glGetIntegerv(GL_SCISSOR_BOX, result.data());
1300          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLint)));
1301          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1302          return JS::Int32Array::create(m_realm, 4, array_buffer);
1303      }
1304      case GL_SCISSOR_TEST: {
1305          GLint result;
1306          glGetIntegerv(GL_SCISSOR_TEST, &result);
1307          return JS::Value(result);
1308      }
1309      case GL_SHADING_LANGUAGE_VERSION: {
1310          auto result = reinterpret_cast<const char*>(glGetString(GL_SHADING_LANGUAGE_VERSION));
1311          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1312      case GL_STENCIL_BACK_FAIL: {
1313          GLint result;
1314          glGetIntegerv(GL_STENCIL_BACK_FAIL, &result);
1315          return JS::Value(result);
1316      }
1317      case GL_STENCIL_BACK_FUNC: {
1318          GLint result;
1319          glGetIntegerv(GL_STENCIL_BACK_FUNC, &result);
1320          return JS::Value(result);
1321      }
1322      case GL_STENCIL_BACK_PASS_DEPTH_FAIL: {
1323          GLint result;
1324          glGetIntegerv(GL_STENCIL_BACK_PASS_DEPTH_FAIL, &result);
1325          return JS::Value(result);
1326      }
1327      case GL_STENCIL_BACK_PASS_DEPTH_PASS: {
1328          GLint result;
1329          glGetIntegerv(GL_STENCIL_BACK_PASS_DEPTH_PASS, &result);
1330          return JS::Value(result);
1331      }
1332      case GL_STENCIL_BACK_REF: {
1333          GLint result;
1334          glGetIntegerv(GL_STENCIL_BACK_REF, &result);
1335          return JS::Value(result);
1336      }
1337      case GL_STENCIL_BACK_VALUE_MASK: {
1338          GLint result;
1339          glGetIntegerv(GL_STENCIL_BACK_VALUE_MASK, &result);
1340          return JS::Value(result);
1341      }
1342      case GL_STENCIL_BACK_WRITEMASK: {
1343          GLint result;
1344          glGetIntegerv(GL_STENCIL_BACK_WRITEMASK, &result);
1345          return JS::Value(result);
1346      }
1347      case GL_STENCIL_BITS: {
1348          GLint result;
1349          glGetIntegerv(GL_STENCIL_BITS, &result);
1350          return JS::Value(result);
1351      }
1352      case GL_STENCIL_CLEAR_VALUE: {
1353          GLint result;
1354          glGetIntegerv(GL_STENCIL_CLEAR_VALUE, &result);
1355          return JS::Value(result);
1356      }
1357      case GL_STENCIL_FAIL: {
1358          GLint result;
1359          glGetIntegerv(GL_STENCIL_FAIL, &result);
1360          return JS::Value(result);
1361      }
1362      case GL_STENCIL_FUNC: {
1363          GLint result;
1364          glGetIntegerv(GL_STENCIL_FUNC, &result);
1365          return JS::Value(result);
1366      }
1367      case GL_STENCIL_PASS_DEPTH_FAIL: {
1368          GLint result;
1369          glGetIntegerv(GL_STENCIL_PASS_DEPTH_FAIL, &result);
1370          return JS::Value(result);
1371      }
1372      case GL_STENCIL_PASS_DEPTH_PASS: {
1373          GLint result;
1374          glGetIntegerv(GL_STENCIL_PASS_DEPTH_PASS, &result);
1375          return JS::Value(result);
1376      }
1377      case GL_STENCIL_REF: {
1378          GLint result;
1379          glGetIntegerv(GL_STENCIL_REF, &result);
1380          return JS::Value(result);
1381      }
1382      case GL_STENCIL_TEST: {
1383          GLint result;
1384          glGetIntegerv(GL_STENCIL_TEST, &result);
1385          return JS::Value(result);
1386      }
1387      case GL_STENCIL_VALUE_MASK: {
1388          GLint result;
1389          glGetIntegerv(GL_STENCIL_VALUE_MASK, &result);
1390          return JS::Value(result);
1391      }
1392      case GL_STENCIL_WRITEMASK: {
1393          GLint result;
1394          glGetIntegerv(GL_STENCIL_WRITEMASK, &result);
1395          return JS::Value(result);
1396      }
1397      case GL_SUBPIXEL_BITS: {
1398          GLint result;
1399          glGetIntegerv(GL_SUBPIXEL_BITS, &result);
1400          return JS::Value(result);
1401      }
1402      case GL_TEXTURE_BINDING_2D: {
1403          GLint result;
1404          glGetIntegerv(GL_TEXTURE_BINDING_2D, &result);
1405          if (!result)
1406              return JS::js_null();
1407          return WebGLTexture::create(m_realm, *this, result);
1408      }
1409      case GL_TEXTURE_BINDING_CUBE_MAP: {
1410          GLint result;
1411          glGetIntegerv(GL_TEXTURE_BINDING_CUBE_MAP, &result);
1412          if (!result)
1413              return JS::js_null();
1414          return WebGLTexture::create(m_realm, *this, result);
1415      }
1416      case GL_UNPACK_ALIGNMENT: {
1417          GLint result;
1418          glGetIntegerv(GL_UNPACK_ALIGNMENT, &result);
1419          return JS::Value(result);
1420      }
1421      case GL_VENDOR: {
1422          auto result = reinterpret_cast<const char*>(glGetString(GL_VENDOR));
1423          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1424      case GL_VERSION: {
1425          auto result = reinterpret_cast<const char*>(glGetString(GL_VERSION));
1426          return JS::PrimitiveString::create(m_realm->vm(), ByteString { result });    }
1427      case GL_VIEWPORT: {
1428          Array<GLint, 4> result;
1429          glGetIntegerv(GL_VIEWPORT, result.data());
1430          auto byte_buffer = MUST(ByteBuffer::copy(result.data(), 4 * sizeof(GLint)));
1431          auto array_buffer = JS::ArrayBuffer::create(m_realm, move(byte_buffer));
1432          return JS::Int32Array::create(m_realm, 4, array_buffer);
1433      }
1434      default:
1435          dbgln("Unknown WebGL parameter name: {:x}", pname);
1436          set_error(GL_INVALID_ENUM);
1437          return JS::js_null();
1438      }
1439  }
1440  
1441  WebIDL::UnsignedLong WebGLRenderingContextImpl::get_error()
1442  {
1443      m_context->make_current();
1444      return glGetError();
1445  }
1446  
1447  JS::Value WebGLRenderingContextImpl::get_program_parameter(GC::Root<WebGLProgram> program, WebIDL::UnsignedLong pname)
1448  {
1449      m_context->make_current();
1450  
1451      GLuint program_handle = 0;
1452      if (program) {
1453          auto handle_or_error = program->handle(this);
1454          if (handle_or_error.is_error()) {
1455              set_error(GL_INVALID_OPERATION);
1456              return JS::js_null();
1457          }
1458          program_handle = handle_or_error.release_value();
1459      }
1460  
1461      GLint result = 0;
1462      glGetProgramiv(program_handle, pname, &result);
1463      return JS::Value(result);
1464  }
1465  
1466  Optional<String> WebGLRenderingContextImpl::get_program_info_log(GC::Root<WebGLProgram> program)
1467  {
1468      m_context->make_current();
1469  
1470      GLuint program_handle = 0;
1471      if (program) {
1472          auto handle_or_error = program->handle(this);
1473          if (handle_or_error.is_error()) {
1474              set_error(GL_INVALID_OPERATION);
1475              return {};
1476          }
1477          program_handle = handle_or_error.release_value();
1478      }
1479  
1480      GLint info_log_length = 0;
1481      glGetProgramiv(program_handle, GL_INFO_LOG_LENGTH, &info_log_length);
1482      Vector<GLchar> info_log;
1483      info_log.resize(info_log_length);
1484      if (!info_log_length)
1485          return String {};
1486      glGetProgramInfoLog(program_handle, info_log_length, nullptr, info_log.data());
1487      return String::from_utf8_without_validation(ReadonlyBytes { info_log.data(), static_cast<size_t>(info_log_length - 1) });
1488  }
1489  
1490  JS::Value WebGLRenderingContextImpl::get_shader_parameter(GC::Root<WebGLShader> shader, WebIDL::UnsignedLong pname)
1491  {
1492      m_context->make_current();
1493  
1494      GLuint shader_handle = 0;
1495      if (shader) {
1496          auto handle_or_error = shader->handle(this);
1497          if (handle_or_error.is_error()) {
1498              set_error(GL_INVALID_OPERATION);
1499              return JS::js_null();
1500          }
1501          shader_handle = handle_or_error.release_value();
1502      }
1503  
1504      GLint result = 0;
1505      glGetShaderiv(shader_handle, pname, &result);
1506      return JS::Value(result);
1507  }
1508  
1509  GC::Root<WebGLShaderPrecisionFormat> WebGLRenderingContextImpl::get_shader_precision_format(WebIDL::UnsignedLong shadertype, WebIDL::UnsignedLong precisiontype)
1510  {
1511      m_context->make_current();
1512  
1513      GLint range[2];
1514      GLint precision;
1515      glGetShaderPrecisionFormat(shadertype, precisiontype, range, &precision);
1516      return WebGLShaderPrecisionFormat::create(m_realm, range[0], range[1], precision);
1517  }
1518  
1519  Optional<String> WebGLRenderingContextImpl::get_shader_info_log(GC::Root<WebGLShader> shader)
1520  {
1521      m_context->make_current();
1522  
1523      GLuint shader_handle = 0;
1524      if (shader) {
1525          auto handle_or_error = shader->handle(this);
1526          if (handle_or_error.is_error()) {
1527              set_error(GL_INVALID_OPERATION);
1528              return {};
1529          }
1530          shader_handle = handle_or_error.release_value();
1531      }
1532  
1533      GLint info_log_length = 0;
1534      glGetShaderiv(shader_handle, GL_INFO_LOG_LENGTH, &info_log_length);
1535      Vector<GLchar> info_log;
1536      info_log.resize(info_log_length);
1537      if (!info_log_length)
1538          return String {};
1539      glGetShaderInfoLog(shader_handle, info_log_length, nullptr, info_log.data());
1540      return String::from_utf8_without_validation(ReadonlyBytes { info_log.data(), static_cast<size_t>(info_log_length - 1) });
1541  }
1542  
1543  GC::Root<WebGLUniformLocation> WebGLRenderingContextImpl::get_uniform_location(GC::Root<WebGLProgram> program, String name)
1544  {
1545      m_context->make_current();
1546  
1547      GLuint program_handle = 0;
1548      if (program) {
1549          auto handle_or_error = program->handle(this);
1550          if (handle_or_error.is_error()) {
1551              set_error(GL_INVALID_OPERATION);
1552              return {};
1553          }
1554          program_handle = handle_or_error.release_value();
1555      }
1556  
1557      auto name_null_terminated = null_terminated_string(name);
1558      return WebGLUniformLocation::create(m_realm, glGetUniformLocation(program_handle, name_null_terminated.data()));
1559  }
1560  
1561  void WebGLRenderingContextImpl::hint(WebIDL::UnsignedLong target, WebIDL::UnsignedLong mode)
1562  {
1563      m_context->make_current();
1564      glHint(target, mode);
1565  }
1566  
1567  bool WebGLRenderingContextImpl::is_buffer(GC::Root<WebGLBuffer> buffer)
1568  {
1569      m_context->make_current();
1570  
1571      auto buffer_handle = 0;
1572      if (buffer) {
1573          auto handle_or_error = buffer->handle(this);
1574          if (handle_or_error.is_error()) {
1575              set_error(GL_INVALID_OPERATION);
1576              return false;
1577          }
1578          buffer_handle = handle_or_error.release_value();
1579      }
1580      return glIsBuffer(buffer_handle);
1581  }
1582  
1583  bool WebGLRenderingContextImpl::is_enabled(WebIDL::UnsignedLong cap)
1584  {
1585      m_context->make_current();
1586      return glIsEnabled(cap);
1587  }
1588  
1589  bool WebGLRenderingContextImpl::is_framebuffer(GC::Root<WebGLFramebuffer> framebuffer)
1590  {
1591      m_context->make_current();
1592  
1593      auto framebuffer_handle = 0;
1594      if (framebuffer) {
1595          auto handle_or_error = framebuffer->handle(this);
1596          if (handle_or_error.is_error()) {
1597              set_error(GL_INVALID_OPERATION);
1598              return false;
1599          }
1600          framebuffer_handle = handle_or_error.release_value();
1601      }
1602      return glIsFramebuffer(framebuffer_handle);
1603  }
1604  
1605  bool WebGLRenderingContextImpl::is_program(GC::Root<WebGLProgram> program)
1606  {
1607      m_context->make_current();
1608  
1609      auto program_handle = 0;
1610      if (program) {
1611          auto handle_or_error = program->handle(this);
1612          if (handle_or_error.is_error()) {
1613              set_error(GL_INVALID_OPERATION);
1614              return false;
1615          }
1616          program_handle = handle_or_error.release_value();
1617      }
1618      return glIsProgram(program_handle);
1619  }
1620  
1621  bool WebGLRenderingContextImpl::is_renderbuffer(GC::Root<WebGLRenderbuffer> renderbuffer)
1622  {
1623      m_context->make_current();
1624  
1625      auto renderbuffer_handle = 0;
1626      if (renderbuffer) {
1627          auto handle_or_error = renderbuffer->handle(this);
1628          if (handle_or_error.is_error()) {
1629              set_error(GL_INVALID_OPERATION);
1630              return false;
1631          }
1632          renderbuffer_handle = handle_or_error.release_value();
1633      }
1634      return glIsRenderbuffer(renderbuffer_handle);
1635  }
1636  
1637  bool WebGLRenderingContextImpl::is_shader(GC::Root<WebGLShader> shader)
1638  {
1639      m_context->make_current();
1640  
1641      auto shader_handle = 0;
1642      if (shader) {
1643          auto handle_or_error = shader->handle(this);
1644          if (handle_or_error.is_error()) {
1645              set_error(GL_INVALID_OPERATION);
1646              return false;
1647          }
1648          shader_handle = handle_or_error.release_value();
1649      }
1650      return glIsShader(shader_handle);
1651  }
1652  
1653  bool WebGLRenderingContextImpl::is_texture(GC::Root<WebGLTexture> texture)
1654  {
1655      m_context->make_current();
1656  
1657      auto texture_handle = 0;
1658      if (texture) {
1659          auto handle_or_error = texture->handle(this);
1660          if (handle_or_error.is_error()) {
1661              set_error(GL_INVALID_OPERATION);
1662              return false;
1663          }
1664          texture_handle = handle_or_error.release_value();
1665      }
1666      return glIsTexture(texture_handle);
1667  }
1668  
1669  void WebGLRenderingContextImpl::line_width(float width)
1670  {
1671      m_context->make_current();
1672      glLineWidth(width);
1673  }
1674  
1675  void WebGLRenderingContextImpl::link_program(GC::Root<WebGLProgram> program)
1676  {
1677      m_context->make_current();
1678  
1679      auto program_handle = 0;
1680      if (program) {
1681          auto handle_or_error = program->handle(this);
1682          if (handle_or_error.is_error()) {
1683              set_error(GL_INVALID_OPERATION);
1684              return ;
1685          }
1686          program_handle = handle_or_error.release_value();
1687      }
1688      glLinkProgram(program_handle);
1689  }
1690  
1691  void WebGLRenderingContextImpl::pixel_storei(WebIDL::UnsignedLong pname, WebIDL::Long param)
1692  {
1693      m_context->make_current();
1694      glPixelStorei(pname, param);
1695  }
1696  
1697  void WebGLRenderingContextImpl::polygon_offset(float factor, float units)
1698  {
1699      m_context->make_current();
1700      glPolygonOffset(factor, units);
1701  }
1702  
1703  void WebGLRenderingContextImpl::renderbuffer_storage(WebIDL::UnsignedLong target, WebIDL::UnsignedLong internalformat, WebIDL::Long width, WebIDL::Long height)
1704  {
1705      m_context->make_current();
1706      glRenderbufferStorage(target, internalformat, width, height);
1707  }
1708  
1709  void WebGLRenderingContextImpl::sample_coverage(float value, bool invert)
1710  {
1711      m_context->make_current();
1712      glSampleCoverage(value, invert);
1713  }
1714  
1715  void WebGLRenderingContextImpl::scissor(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height)
1716  {
1717      m_context->make_current();
1718      glScissor(x, y, width, height);
1719  }
1720  
1721  void WebGLRenderingContextImpl::shader_source(GC::Root<WebGLShader> shader, String source)
1722  {
1723      m_context->make_current();
1724  
1725      GLuint shader_handle = 0;
1726      if (shader) {
1727          auto handle_or_error = shader->handle(this);
1728          if (handle_or_error.is_error()) {
1729              set_error(GL_INVALID_OPERATION);
1730              return ;
1731          }
1732          shader_handle = handle_or_error.release_value();
1733      }
1734  
1735      Vector<GLchar*> strings;
1736      auto string = null_terminated_string(source);
1737      strings.append(string.data());
1738      Vector<GLint> length;
1739      length.append(source.bytes().size());
1740      glShaderSource(shader_handle, 1, strings.data(), length.data());
1741  }
1742  
1743  void WebGLRenderingContextImpl::stencil_func(WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask)
1744  {
1745      m_context->make_current();
1746      glStencilFunc(func, ref, mask);
1747  }
1748  
1749  void WebGLRenderingContextImpl::stencil_func_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong func, WebIDL::Long ref, WebIDL::UnsignedLong mask)
1750  {
1751      m_context->make_current();
1752      glStencilFuncSeparate(face, func, ref, mask);
1753  }
1754  
1755  void WebGLRenderingContextImpl::stencil_mask(WebIDL::UnsignedLong mask)
1756  {
1757      m_context->make_current();
1758      glStencilMask(mask);
1759  }
1760  
1761  void WebGLRenderingContextImpl::stencil_mask_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong mask)
1762  {
1763      m_context->make_current();
1764      glStencilMaskSeparate(face, mask);
1765  }
1766  
1767  void WebGLRenderingContextImpl::stencil_op(WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass)
1768  {
1769      m_context->make_current();
1770      glStencilOp(fail, zfail, zpass);
1771  }
1772  
1773  void WebGLRenderingContextImpl::stencil_op_separate(WebIDL::UnsignedLong face, WebIDL::UnsignedLong fail, WebIDL::UnsignedLong zfail, WebIDL::UnsignedLong zpass)
1774  {
1775      m_context->make_current();
1776      glStencilOpSeparate(face, fail, zfail, zpass);
1777  }
1778  
1779  void WebGLRenderingContextImpl::tex_parameterf(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, float param)
1780  {
1781      m_context->make_current();
1782      glTexParameterf(target, pname, param);
1783  }
1784  
1785  void WebGLRenderingContextImpl::tex_parameteri(WebIDL::UnsignedLong target, WebIDL::UnsignedLong pname, WebIDL::Long param)
1786  {
1787      m_context->make_current();
1788      glTexParameteri(target, pname, param);
1789  }
1790  
1791  void WebGLRenderingContextImpl::uniform1f(GC::Root<WebGLUniformLocation> location, float x)
1792  {
1793      m_context->make_current();
1794      glUniform1f(location ? location->handle() : 0, x);
1795  }
1796  
1797  void WebGLRenderingContextImpl::uniform2f(GC::Root<WebGLUniformLocation> location, float x, float y)
1798  {
1799      m_context->make_current();
1800      glUniform2f(location ? location->handle() : 0, x, y);
1801  }
1802  
1803  void WebGLRenderingContextImpl::uniform3f(GC::Root<WebGLUniformLocation> location, float x, float y, float z)
1804  {
1805      m_context->make_current();
1806      glUniform3f(location ? location->handle() : 0, x, y, z);
1807  }
1808  
1809  void WebGLRenderingContextImpl::uniform4f(GC::Root<WebGLUniformLocation> location, float x, float y, float z, float w)
1810  {
1811      m_context->make_current();
1812      glUniform4f(location ? location->handle() : 0, x, y, z, w);
1813  }
1814  
1815  void WebGLRenderingContextImpl::uniform1i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x)
1816  {
1817      m_context->make_current();
1818      glUniform1i(location ? location->handle() : 0, x);
1819  }
1820  
1821  void WebGLRenderingContextImpl::uniform2i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y)
1822  {
1823      m_context->make_current();
1824      glUniform2i(location ? location->handle() : 0, x, y);
1825  }
1826  
1827  void WebGLRenderingContextImpl::uniform3i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z)
1828  {
1829      m_context->make_current();
1830      glUniform3i(location ? location->handle() : 0, x, y, z);
1831  }
1832  
1833  void WebGLRenderingContextImpl::uniform4i(GC::Root<WebGLUniformLocation> location, WebIDL::Long x, WebIDL::Long y, WebIDL::Long z, WebIDL::Long w)
1834  {
1835      m_context->make_current();
1836      glUniform4i(location ? location->handle() : 0, x, y, z, w);
1837  }
1838  
1839  void WebGLRenderingContextImpl::use_program(GC::Root<WebGLProgram> program)
1840  {
1841      m_context->make_current();
1842  
1843      auto program_handle = 0;
1844      if (program) {
1845          auto handle_or_error = program->handle(this);
1846          if (handle_or_error.is_error()) {
1847              set_error(GL_INVALID_OPERATION);
1848              return ;
1849          }
1850          program_handle = handle_or_error.release_value();
1851      }
1852      glUseProgram(program_handle);
1853  }
1854  
1855  void WebGLRenderingContextImpl::validate_program(GC::Root<WebGLProgram> program)
1856  {
1857      m_context->make_current();
1858  
1859      auto program_handle = 0;
1860      if (program) {
1861          auto handle_or_error = program->handle(this);
1862          if (handle_or_error.is_error()) {
1863              set_error(GL_INVALID_OPERATION);
1864              return ;
1865          }
1866          program_handle = handle_or_error.release_value();
1867      }
1868      glValidateProgram(program_handle);
1869  }
1870  
1871  void WebGLRenderingContextImpl::vertex_attrib1f(WebIDL::UnsignedLong index, float x)
1872  {
1873      m_context->make_current();
1874      glVertexAttrib1f(index, x);
1875  }
1876  
1877  void WebGLRenderingContextImpl::vertex_attrib2f(WebIDL::UnsignedLong index, float x, float y)
1878  {
1879      m_context->make_current();
1880      glVertexAttrib2f(index, x, y);
1881  }
1882  
1883  void WebGLRenderingContextImpl::vertex_attrib3f(WebIDL::UnsignedLong index, float x, float y, float z)
1884  {
1885      m_context->make_current();
1886      glVertexAttrib3f(index, x, y, z);
1887  }
1888  
1889  void WebGLRenderingContextImpl::vertex_attrib4f(WebIDL::UnsignedLong index, float x, float y, float z, float w)
1890  {
1891      m_context->make_current();
1892      glVertexAttrib4f(index, x, y, z, w);
1893  }
1894  
1895  void WebGLRenderingContextImpl::vertex_attrib1fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
1896  {
1897      m_context->make_current();
1898  
1899      if (values.has<Vector<float>>()) {
1900          auto& data = values.get<Vector<float>>();
1901          glVertexAttrib1fv(index, data.data());
1902          return;
1903      }
1904  
1905      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
1906      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
1907      float const* data = float32_array.data().data();
1908      glVertexAttrib1fv(index, data);
1909  }
1910  
1911  void WebGLRenderingContextImpl::vertex_attrib2fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
1912  {
1913      m_context->make_current();
1914  
1915      if (values.has<Vector<float>>()) {
1916          auto& data = values.get<Vector<float>>();
1917          glVertexAttrib2fv(index, data.data());
1918          return;
1919      }
1920  
1921      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
1922      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
1923      float const* data = float32_array.data().data();
1924      glVertexAttrib2fv(index, data);
1925  }
1926  
1927  void WebGLRenderingContextImpl::vertex_attrib3fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
1928  {
1929      m_context->make_current();
1930  
1931      if (values.has<Vector<float>>()) {
1932          auto& data = values.get<Vector<float>>();
1933          glVertexAttrib3fv(index, data.data());
1934          return;
1935      }
1936  
1937      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
1938      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
1939      float const* data = float32_array.data().data();
1940      glVertexAttrib3fv(index, data);
1941  }
1942  
1943  void WebGLRenderingContextImpl::vertex_attrib4fv(WebIDL::UnsignedLong index, Variant<GC::Root<WebIDL::BufferSource>, Vector<float>> values)
1944  {
1945      m_context->make_current();
1946  
1947      if (values.has<Vector<float>>()) {
1948          auto& data = values.get<Vector<float>>();
1949          glVertexAttrib4fv(index, data.data());
1950          return;
1951      }
1952  
1953      auto& typed_array_base = static_cast<JS::TypedArrayBase&>(*values.get<GC::Root<WebIDL::BufferSource>>()->raw_object());
1954      auto& float32_array = verify_cast<JS::Float32Array>(typed_array_base);
1955      float const* data = float32_array.data().data();
1956      glVertexAttrib4fv(index, data);
1957  }
1958  
1959  void WebGLRenderingContextImpl::vertex_attrib_pointer(WebIDL::UnsignedLong index, WebIDL::Long size, WebIDL::UnsignedLong type, bool normalized, WebIDL::Long stride, WebIDL::LongLong offset)
1960  {
1961      m_context->make_current();
1962  
1963      glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast<void*>(offset));
1964  }
1965  
1966  void WebGLRenderingContextImpl::viewport(WebIDL::Long x, WebIDL::Long y, WebIDL::Long width, WebIDL::Long height)
1967  {
1968      m_context->make_current();
1969      glViewport(x, y, width, height);
1970  }
1971  
1972  }
</document_content>
</document>
</documents>
